Hydra: Fast Isomorphic State Channels
Manuel M. T. Chakravarty1, Sandro Coretti1, Matthias Fitzi1, Peter GaË‡ zi1, Philipp Kant1,
Aggelos Kiayias2, and Alexander Russell 3
1IOHK. firstname.lastname@iohk.io.
2University of Edinburgh and IOHK. akiayias@inf.ed.ac.uk.
3University of Connecticut and IOHK. acr@cse.uconn.edu.
Abstract
State channels are an attractive layer-two solution for improving the throughput and latency
of blockchains. They oï¬€er optimistic oï¬€chain settlement of payments and expedient oï¬€chain evo-
lution of smart contracts between multiple parties without imposing any additional assumptions
beyond those of the underlying blockchain. In the case of disputes, or if a party fails to respond,
cryptographic evidence collected in the oï¬€chain channel is used to settle the last conï¬rmed state
onchain, such that in-progress contracts can be continued under mainchain consensus.
A serious disadvantage present in current layer-two state channel protocols is that existing
layer-one smart contract infrastructure and contract code cannot be reused oï¬€chain without
change.
In this paper, we introduce Hydra, an isomorphic multi-party state channel. Hydra simpliï¬es
oï¬€chain protocol and smart contract development by directly adopting the layer-one smart
contract system, in this way allowing the same code to be used both on- and oï¬€-chain. Taking
advantage of the extended UTxO model , we develop a fast oï¬€-chain protocol for evolution of
Hydra heads (our isomorphic state channels) that has smaller round complexity than all previous
proposals and enables the state channel processing to advance on-demand, concurrently and
asynchronously.
We establish strong security properties for the protocol, and we present and evaluate ex-
tensive simulation results that demonstrate that Hydra approaches the physical limits of the
network in terms of transaction conï¬rmation time and throughput while keeping storage require-
ments at the lowest possible. Finally, our experimental methodology may be of independent
interest in the general context of evaluating consensus protocols.
1 Introduction
Permissionless distributed ledger protocols suï¬€er from serious scalability limitations, including high
transaction latency (the time required to settle a transaction), low throughput (the number of
transactions that can be settled per unit of time), and excessive storage required to maintain the
state of the system and its transaction history, which can be ever growing.
Several solutions have been proposed to mitigate these problems by adapting the details of the
underlying ledger protocols. Such direct adaptations for scalability are often referred to aslayer-one
solutions.
Layer-one solutions face an inherent limitation, however, as settlement remains a cumbersome
process that involves the participation of a large, dynamic set of participants and requires exchange
1

of signiï¬cant amounts of data. An alternative approach to improve scalability, which is our emphasis
in this work, is layer-two (sometimes referred to also as oï¬€chain) solutions that overlay a new
protocol on top of the (layer-one) blockchain. Layer-two solutions allow parties to securely transfer
funds from the blockchain into an oï¬€chain protocol instance, settle transactions in this instance
(quasi) independently of the underlying chain, and safely transfer funds back to the underlying
chain as needed.
Oï¬€chain solutions have the advantage that they do not require additional trust assumptions
about the honesty of parties beyond those of the underlying blockchain, and that they can be very
eï¬ƒcient in the optimistic case where all participants in the oï¬€chain protocol instance behave as
expected. In particular, such an instance operates among a small number of parties that commu-
nicate with each other directly, and in a way that allows them to forget about recent transactions
as soon as they respectively update (and secure) their local states.
The most prominent oï¬€chain scalability solution is the concept of payment channels [9, 33, 16].
A payment channel is established among two parties, allowing them to pay funds back and forth
on this channel; in the optimistic case, this can take place without notifying the layer-one protocol.
Payment channels have been extended to payment-channel networks, e.g., the Bitcoin Lightning
Network [33]. Such networks, in principle, allow for oï¬€chain fund transfers among any two parties
that are connected via a path of payment channels.
As a drawback, in a traditional payment-channel network a transaction between two parties
that do not share a direct payment channel requires interaction among all parties on a payment-
channel path between them (so-calledintermediaries), even in the optimistic case. Virtual payment
channels, e.g., Perun [19], address this and do not require interaction with intermediate parties (in
the optimistic case).
State channels [5] extend the concept of payment channels to states in order to support smart
contracts. State-channel networks [21, 15, 29] likewise extend the concept of state channels to
networks (analogously to the network extension discussed above). Still, these networks only allow
for the establishment of pairwise state channels over the network.
Multi-party state channels were introduced in [31] together with a high-level description of a
respective protocol. A multi-party state channel allows a set of parties to maintain a â€œcommonâ€
state whereon they can compute without interacting with the blockchain (in the optimistic case).
In [18], the notion of multi-party virtual state channels was introduced, state channels among
multiple parties that can be setup without blockchain interaction (given that a connected graph of
pairwise state channels among the parties already exists); and a respective protocol was presented.
Despite the above signiï¬cant advances, important challenges remain, both in terms of establish-
ing high oï¬€chain processing performance that approximates the physical limits of the underlying
network as well as in the sense of imposing signiï¬cant conceptual and engineering overhead over
layer-one as the oï¬€chain contract state must be veriï¬ed in a non-native representation; the rea-
son is that the state of the contracts evolved in a speciï¬c state channel needs to be isolated and
represented in a form that permits it to be manipulated both oï¬€chain and by the onchain smart
contract scripting system in case of an oï¬€chain dispute. This lead to designs where the computa-
tions performed oï¬€chain are no longer in the representation used by the ledger itself; i.e., they are
non-native. For example, the sample Solidity contract of [31] serializes the state into a bytes32
array. The smart contracts themselves need to be adapted correspondingly. In other words, the
scripting system of the ledger and of state channels attached to the ledger diverge in a substantial
way, eï¬€ectively imposing two distinct scripting systems.
2

Hydra. In Hydra, we tackle both problems, oï¬€chain processing performance and state represen-
tation, with the introduction of isomorphic multi-party state channels. These are state channels
that are capable of expediently reusing the exact state representation of the underlying ledger and,
hence, inherit the ledgerâ€™s scripting system as is. Thus, state channels eï¬€ectively yield parallel,
oï¬€chain ledger siblings, which we call headsâ€”the ledger becomes multi-headed. The creation of
a new head follows a similar commitment scheme as is common in state channels. However, once
a state channel is closed, either cooperatively or due to a dispute, the head state is seamlessly
absorbed into the underlying ledger state and the same smart contract code as used oï¬€chain is
now used onchain. This is possible, even without a priori registration of the contracts used in a
head, because one and the same state representation and contract (binary) code is used oï¬€chain
and onchain.
Not every blockchain scripting system is conducive to isomorphic state channels. Building them
requires to eï¬ƒciently carve out arbitrary chunks of blockchain state, process them independently,
and be able at any time to eï¬ƒciently merge them back in. We observe that the Bitcoin-style UTxO
ledger model [6, 34] is particularly well suited as a uniform representation of onchain and oï¬€chain
state, while simultaneously promising increased parallelism in transaction processing inside multi-
party state channels. While the main restriction of the plain UTxO model has traditionally been
its limited scripting capabilities, the introduction of the Extended UTxO model (EUTxO) [13] has
lifted this restriction and enabled support for general state machines. Extended UTxO models
form the basis for the smart contract platforms of existing blockchains, such as Cardano [14] and
Ergo [17]; hence, the work presented in this paper would also be of immediate practical relevance.
Just like the UTxO ledger representation, the EUTxO ledger representation makes all data
dependencies explicitly without introducing false dependencies â€” in other words, two transactions
do only directly or indirectly depend on each other if there is an actual data dependency between
them. This avoids the over-sequentialization of systems depending on a global state. Hence, the
length of the longest path through the EUTxO graph coincides with the depth complexity of the
workload entailed by transaction processing and validation. This is the optimum as far as parallel
transaction processing is concerned [10].
Exploiting the EUTxO ledger representation, we are able to design an oï¬€chain protocol with
unparalleled performance. In particular, the Hydra head protocol is capable of oï¬€chain processing
asynchronously and concurrently between diï¬€erent members of the head, utilizing merely 3 rounds
of interaction for updates. In contrast previous works in multiparty state channels either required
a synchronous operation or imposed 4 rounds to facilitate sequentializing inputs and organizing the
oï¬€chain state.
In more detail, in Hydra, a set of parties coordinates to commit a set of UTxOs (owned by the
parties) into an oï¬€chain protocol, called the head protocol. That UTxO set constitutes the initial
head state, which the parties can then evolve by handling smart contracts and transactions among
themselves without blockchain interactionâ€”in the optimistic case.
Due to the isomorphic nature of Hydra heads, transaction validation, including script execution,
proceeds according to the exact same rules as onchain. In fact, the exact same validation code
can be used. This guarantees that onchain and oï¬€chain semantics coincide, leading to signiï¬cant
engineering simpliï¬cations. In case of disputes or in case some party wishes to terminate the oï¬€chain
protocol, the parties decommit the current state of the head back to the blockchain. Ultimately, a
decommit will result in an updated blockchain state that is consistent with the oï¬€chain protocol
evolution on the initially committed UTxO set. To reduce mainchain overhead, the mainchain is
3

oblivious of the detailed transaction history of the head protocol that lead to the updated state.
Crucially, the time required to decommit is independent of the number of parties participating in
a head or the size of the head state. Moreover, the decommit process is designed such that, when
the latest state in the head is very large, the head state can be decommitted in small (but parallel)
chunks. Finally, Hydra allows incremental commits and decommits, i.e., UTxOs can be added to
and removed from a running head without closing it.
Cross-head networking. In this paper, we focus solely on the analysis of the Hydra head protocol;
nevertheless, the existence of multiple, partially overlapping heads oï¬€ the mainchain can give rise to
cross-head communication (as in the Lightning Network [33]), using similar techniques to [21, 18].
Online participation requirements. The Hydra head protocol is geared towards the scenario
where the participants who are required to validate transactions are online and responsive. As in
e.g. [33], being oï¬„ine will prevent progress, and also participation in a potential onchain dispute
resolution. The scenario where a number of parties are regularly oï¬„ine is also of interest but not
in scope for the current version.
Performance evaluation methodology and experimental results. As transaction-processing per-
formance is the fundamental motivation for layer-two protocols, these properties of the Hydra
protocol are particularly important to establish. While transactions-per-second (TPS) is an imme-
diate ï¬gure of merit for deployed systems, it is sensitive to changes in the underlying hardware or
network; in particular, it is an unreliable means for experimentally comparing various algorithmic
proposals unless the experiments precisely duplicate the computing environment which is also sen-
sitive to user inputs. To avoid these diï¬ƒculties and second-guessing speciï¬c usage scenarios, we
adopt a â€œbaseline relativeâ€ approach to establish performance guarantees, which demonstrates that
Hydra achieves performance that approaches the theoretical optimum for any consensus protocol.
Our experimental results are obtained by simulation, which additionally permits a high-precision
exploration of the speciï¬c design choices adopted by the Hydra protocol. We consider two major
types of baselines elaborated below.
The universal baseline. As mentioned above, we begin by considering a baseline reï¬‚ecting the weak-
est obligations of any consensus algorithm. Speciï¬cally, the universal baseline merely con-
siders the cost of processing each transaction and disseminating the transactions across the
network; observe that any iterated consensus algorithm that yields full state at each node
must necessarily carry out both operations. We demonstrate that Hydra achieves eï¬ƒciency
that rivals even this ideal for most scenarios. As this protocol-independent baseline is one
against which any iterated consensus algorithm can be compared, near optimality with respect
to this baseline implicitly demonstrates that Hydra is competitive with any other consensus
layer. In our experiments we compare Hydra with the universal baseline for a number of
diï¬€erent scenarios that reï¬‚ect user behavior.
The unlimited baseline. The second baseline focuses on the characteristics of the protocol itself. In
particular it asks how does the protocol implementation compare to an idealized execution of
the protocol by a set of nodes that experience no local contention for resources. This baseline
comparison is meant to be complementary to the universal baseline and helps answer the
following question. Whenever there is divergence between the universal baseline and the
actual consensus protocol execution in the experiment, how much of this divergence is to
be attributed to the inherent cost of running the consensus protocol vs. the costs arising
due to contention for resources within each node. Even good consensus protocol designs are
4

expected to diverge from the universal baseline: after all, consensus is a diï¬ƒcult problem to
solve. However good protocol designs should always approximate their unlimited baseline. In
our experiments we demonstrate that this is the case for Hydra in all the diï¬€erent scenarios
of our experimental setup.
Experimental results. We conducted detailed simulations of head performance under a variety
of load and networking scenarios, including both geographically localized heads and heads with
participants spread over multiple continents, incurring large network delays. We found that our
head protocol, in the optimistic case, achieves progress that rivals the speed and throughput of
the network in all conï¬gurations; this is aided by the concurrency aï¬€orded by the partial-only
transaction ordering permitted by the graph-structure underlying UTxO ledgers.
Comparison to previous work. A number of previous works study state channel protocols.
The protocol by Miller et al. [31] allows a set of parties to initiate a smart contract instance (state)
onchain and take it oï¬€chain. The state can then be evolved oï¬€chain without chain interaction in the
all-honest case. By concurrently handling disputes in a shared contract, dispute resolution remains
in O(âˆ†) time, where âˆ† is the settlement time for an onchain transaction. The oï¬€chain protocol
proceeds in phases of 4 asynchronous rounds where a leader coordinates the conï¬rmation of new
transactions among the participants in the oï¬€chain protocol. Similarly to Hydra, the protocol
allows to add/remove funds from the oï¬€chain contract while it is running.
The protocol by Dziembowski et al. [18] is based on pairwise state channels and allows the
instantiation of a multi-party state channel among any set of parties that are connected by paths
of pairwise state channelsâ€”the instantiation of the multi-party channel does not require any inter-
action with the mainchain. The oï¬€chain protocol proceeds in phases of 4 synchronous rounds to
conï¬rm new transactions without the need for a coordinating leader.
The Hydra oï¬€chain protocol is fully asynchronous; in the optimistic case, transactions are
conï¬rmed in 3 (asynchronous) rounds independently of each other, and without having to involve a
leader. A leader is only required for the resolution of transaction conï¬‚icts and for periodic â€œgarbage
collectionâ€ that allows the protocol to maintain state size independent of the size of the transaction
history.
In comparison to prior solutions cited above, Hydra provides faster conï¬rmation times in the
oï¬€chain protocol; this is an advantage enabled by the structural organization of transactions in
the EUTxO model, whereas prior protocols are hindered by a monolithic state organization. An
additional advantage over [31] and [18] is that those ï¬x the set of contracts that can be evolved in a
given state channel at channel creation time; Hydra does not require such an a priori commitment:
new contracts can be introduced in a head after creation in the native EUTxO language of the
underlying blockchain. Another signiï¬cant diï¬€erence to [18] is that their protocol calls for parties
to lock funds on the mainchain on behalf of other partiesâ€”caused by asymmetries induced by
the composition along paths of pairwise state channels, whereas in Hydra as well as in [31], the
parties only need to lock funds on behalf of themselves. Finally, Hydra is isomorphic and thus
reuses the existing smart contract system and code for oï¬€chain computations. This is not the case
for [31] and [18]. For example, if we consider the sample Solidity contract of [31], it would have
to implement a state machine capable of executing EVM bytecode to achieve contract (system)
reuseâ€”and hence, isomorphic state channels.
We note that there is also a large number of non-peer reviewed proposals for state-channel-based
solutions such as [28, 15, 29, 3]. These proposals come with various degrees of formal speciï¬cation
5

and provable security guarantees and their systematization is outside of our current scope; it suï¬ƒces
to observe that none of them provides the isomorphism property or comes with a complete formal
security analysis and an experimental evaluation.
Two concepts related, but distinct, from state channels aresidechains (e.g., [7, 24, 26]) and non-
custodial chains (e.g., [32, 27, 20, 4]), including plasma and rollups. Sidechains enable the transfer of
assets between a mainchain and a sidechain via a pegging mechanism, with the mainchain protected
from sidechain security failures by a â€œï¬rewall propertyâ€; the sidechain has its own consensus rules
and, contrary to a state channel, funds may be lost in case of a sidechain security collapse. Non-
custodial chains, on the other hand, delegate mainchain transaction processing to an untrusted
aggregator and are capable, as in state channels, to protect against a security failure. Nevertheless,
the aggregator is a single-point-of-failure and its corruption, in a setting where a large number
users are served by the same non-custodial chain, gives rise to the â€œmass-exitâ€ problem (see e.g.,
[20]); note that state channels, in contrast, can scale to a large number of users via state channel
networks [21] without requiring many users per channel. We note ï¬nally that work in progress on
optimistic rollups, reported in [4], claims a feature similar to our isomorphic property, nevertheless
without the latency beneï¬ts of our approach as their settlement still advances with the underlying
mainchain.
2 Preliminaries
2.1 Multisignatures
A multisignature scheme [25, 30] is a tuple of algorithms MS = ( MS-Setup,MS-KG,MS-AVK,
MS-Sign,MS-ASig,MS-Verify) such that Î  â†MS-Setup(1k) generates public parameters; with these
in place, (vk,sk) â†MS-KG(Î ) can be used to generate fresh key pairs. Then
â€¢Ïƒâ†MS-Sign(Î ,sk,m) signs a message m using key sk;
â€¢ ËœÏƒâ†MS-ASig(Î ,m, V,S) aggregates a set Sof signatures into a single, aggregate signature ËœÏƒ.
The algorithm avk â†MS-AVK(Î ,V) aggregates a tuple Vof veriï¬cation keys vk into a single, aggre-
gate veriï¬cation keyavk which can be used for veriï¬cation: MS-Verify(Î ,avk,m, ËœÏƒ) âˆˆ{true,false}
veriï¬es an aggregate signature under an aggregate veriï¬cation key. In the following, we often make
the parameter Î  implicit in the function calls for better readability.
Intuitively, the security of a multisignature scheme guarantees that, if avk is produced from
a tuple of veriï¬cation keys V via MS-AVK, then no aggregate signature Ëœ Ïƒ can pass veriï¬cation
MS-Verify(avk,m, ËœÏƒ) unless all honest parties holding keys in Vsigned m. A full treatment appears
in Appendix A.
2.2 Extended UTxO model & state machines
The basis for our fast isomorphic state channels is Bitcoinâ€™s UTxO ledger model [6, 34]. It arranges
transactions in a directed acyclic graph structure, thus making the available parallelism explicit:
any two transactions that are not directly or indirectly dependent on each other can be processed
independently.
6

(5, Î½1)
(1, Î½2) Ï1Ï2
(2, Î½3)
(6, Î½4)
(9, Î½5)
(3, Î½6) (14, Î½7)Ï3
Ï4
Ï5
Ï6
Ï7
Ï8
Figure 1: Example of a plain UTxO graph
UTxO. Transactions in an UTxO ledger contain a set of inputs and outputs, where outputs
lock an amount of cryptocurrency, such that only authorized inputs of subsequent transactions can
connect and consume those funds. This arrangement results in graphs, such as the one in Figure 1,
where the boxes represent transactions with (red) inputs to the left and (black) outputs to the
right.
Each output locks some cryptocurrency, which can be transferred via a subsequent transaction
by consuming that output with a new input. The set of dangling (unconnected) outputs are the
unspent transaction outputs (UTxOs) â€” there are two of those in Figure 1. In addition to the
locked currency, each output also comes with a predicate Î½, called its validator. In Figure 1, we
use pairs (n,Î½) to indicate that a given output locks n cryptocurrency with validator predicate Î½.
Where outputs carry validators, each input comes with a redeemer value Ï. To determine
whether a given input of the currently validated transaction tx is permitted to connect to a, as
of yet, unspent output, we determine whether the validator predicate Î½ of that output applies
for the redeemer Ï; or more formally, we check that Î½(Ï,Ïƒ) = true, where the validation context
Ïƒ represents some properties of the transaction that the spending input belongs to, such as the
transactionâ€™s cryptographic hash value. For example, the validator may require the redeemer to be
a signature on the transaction hash contained in the context Ïƒ for a speciï¬c key pair, such that
only the owner of the private key can spend an output locked by that validator.
Extended UTxO. The Extended UTxO Model (EUTxO) [13] preserves this structure, while
adding support for more expressive smart contracts and, in particular, for multi-transaction state
machines, which serve as the basis for the mainchain portion of the work presented here. This
additional expressiveness is achieved by two changes to the plain UTxO scheme outlined before:
â€¢Outputs carry, in addition to a cryptocurrency value nand a validator Î½, now also a datum Î´,
which can, among other things, be used to maintain the state of long running smart contracts.
â€¢The validation context Ïƒ is extended to contain the entire validated transaction tx as well as
the UTxOs consumed by the inputs of that transaction.
In this extended model, evaluation of the validator predicate implies checking Î½(Ï,Î´,Ïƒ ) = true.
Besides maintaining contract state in Î´, the fact that the validator can inspect the entire validated
transaction tx through Ïƒenables validators to enforce that contract invariants are maintained across
entire chains of transactions.
7

Although formal results about EUTxO are rather recent, extended UTxO models already form
the basis for the smart-contract platforms of existing blockchains â€” in particular, Cardano [14]
and Ergo [17]. Consequently, the Hydra head protocol as presented in this paper is of immediate
practical relevance to these existing systems.
User-deï¬ned tokens. In addition to the basic EUTxO extension, we generalize the currency
values recorded on the ledger from integral numbers to generalized user-deï¬ned tokens [1]. Put
simply (suï¬ƒcient to understand the concepts in this paper), values are sets that keep track how
many units of which tokens of which currency are available. For example, the value {Coin â†¦â†’
{Coin â†¦â†’3},c â†¦â†’{t1 â†¦â†’1,t2 â†¦â†’1}}contains 3 Coin coins (there is only one (fungible) token Coin for
a payment currency Coin), as well as (non-fungible) tokens t1 and t2, which are both of currency c.
Values can be added naturally, e.g.,
{Coin â†¦â†’{Coin â†¦â†’3},c â†¦â†’{t1 â†¦â†’1,t2 â†¦â†’1}}
+ {Coin â†¦â†’{Coin â†¦â†’1},c â†¦â†’{t3 â†¦â†’1}}
= {Coin â†¦â†’{Coin â†¦â†’4},c â†¦â†’{t1 â†¦â†’1,t2 â†¦â†’1,t3 â†¦â†’1}}.
In the following, âˆ… is the empty value, and {t1,...,t n}:: c is used as a shorthand for {câ†¦â†’{t1 â†¦â†’
1,...,t n â†¦â†’1}}.
The EUTxO ledger consists oftransactions: Transactions are quintuples tx = (I,O, valForge,r,K)
comprising a set of inputs I, a list of outputs O, values of forged/burned tokens valForge, a slot range
r= (rmin,rmax), and a set of public keys K. Each input iâˆˆI is a pair consisting of an output refer-
ence out-ref (consisting of a transaction ID and an index identifying an output in the transaction)
and a redeemer Ï (used to supply data for validation). Each output o âˆˆO is a triple ( val,Î½,Î´ )
consisting of a value val, a validator script Î½, and a datum Î´. The slot range r indicates the slots
within which tx may be conï¬rmed and, ï¬nally, Kare the public keys under which tx is signed.
In order to validate a transaction tx with input setI, for each output o= (val,Î½,Î´ ) referenced by
an i= (out-ref,Ï) âˆˆI, the corresponding validator Î½ is run on the following inputs: Î½(val,Î´,Ï,Ïƒ ),
where the validation context Ïƒ consists of tx and all outputs referenced by some iâˆˆI (not just o).
Ultimately, tx is valid if and only if all validators return true.
State Machines. A convenient abstraction for EUTxO smart contracts spanning a sequence
of related transactions are state machines. Speciï¬cally, we adopt constraint emitting machines
(CEMs) [13]. These are based on Mealy machines and consist of a set of states Scem, a set of inputs
Icem, a predicate ï¬nalcem : Scem â†’Bool identifying ï¬nal states, and a step relation s iâˆ’â†’(sâ€²,txâ‰¡),
which takes a stateson an input ito a successor statesâ€²under the requirements that the constraints
txâ‰¡are satisï¬ed.
We implement CEMs on a EUTxO ledger (the mainchain) by representing a sequence of CEM
states as a sequence of transactions. Each of these transactions has got a state-machine input icem
and a state-machine output ocem, where the latter is locked by a validator Î½cem, implementing the
step relation. The only exceptions are the initial and ï¬nal state, which have got no state-machine
input and output, respectively.
More speciï¬cally, given two transactions tx and tx â€², they represent successive states under
s iâˆ’â†’(sâ€²,txâ‰¡) iï¬€
8

i
(s, i) â†¦ (sâ€² , txâ‰¡)
s
â‹®â‹®
ğ—ğ–ºğ—…
sâ€² 
â‹®â‹®
ğ—ğ–ºğ—…â€² 
ËœÏ
Figure 2: Transactions representing successive states in a CEM transition relation s
i
âˆ’â†’
(sâ€²,txâ‰¡). Fields val and valâ€² are the value ï¬elds of the state-machine outputs and Ëœ Ï is the
additional data.
â€¢state-machine output ocem = ( val,Î½cem,s) of tx is consumed by the state-machine input
iâ€²
cem = ( out-ref,Ï) of tx â€², whose redeemer is Ï = i (i.e., the redeemer provides the state-
machine input) and
â€¢either ï¬nalcem(sâ€²) = true and txâ€²has no state-machine output, or oâ€²
cem = (valâ€²,Î½cem,sâ€²) and
txâ€²meets all constraints imposed by tx â‰¡.
Sometimes it is useful to have additional data ËœÏ provided as part of the redeemer, i.e., Ï = (i,ËœÏ).
A state transition of the described type is represented by two connected transactions as shown in
Fig. 2. For simplicity, state-machine inputs and outputs are not shown, with the exception of the
value ï¬elds val and valâ€²of the state-machine output.
3 Protocol Overview
The Hydra protocol provides functionality to lock a set of UTxOs on a blockchain, referred to as
the mainchain, and evolve it inside a so-called oï¬€chain head, independently of the mainchain. At
any point, the head can be closed with the eï¬€ect that the locked set of UTxOs on the mainchain
is replaced by the latest set of UTxOs inside the head. The protocol guarantees full wealth preser-
vation: no generation of funds can happen oï¬€chain, and no responsive honest party involved in a
head can ever lose any funds other than by consenting to give them away.
The advantage of head evolution from a liveness viewpoint is that, under good conditions, it
can essentially proceed at network speed, thereby reducing latency and increasing throughput in
an optimal way. At the same time, the head protocol provides the same smart-contract capabilities
as the mainchain.
To avoid overloading with technical details, the main body of the paper presents a simpliï¬ed
version of Hydra to convey the basic concepts and ideas of the new protocol. Also in the overview,
we focus on the simpliï¬ed protocol and outline the diï¬€erences of the full protocol in Section 3.4. A
detailed description of the simpliï¬ed protocol is given in Sections 4â€“ 6, and Appendix B. The full
protocol is described in Appendix C.
3.1 The big picture
To create a head-protocol instance, any party may take the role of aninitiator and ask a set parties
(including himself), the head members, to participate in the head by announcing the identities of
the parties.
9

Each party then establishes pairwise authenticated channels to all other parties orâ€”if this is
not possibleâ€”aborts the protocol setup. 1
The parties then exchange, via the pairwise authenticated channels, some public-key material.
This public-key material is used both for the authentication of head-related onchain transactions
that are restricted to head members (e.g., a non-member is not allowed to close the head) and for
multisignature-based event conï¬rmation in the head.
The initiator then establishes the head by submitting an initial transaction to the mainchain
that contains the head parameters and forges special participation tokens identifying the head
members by assigning each token to the public key distributed by the respective party during the
the setup phase. The initial transaction also initializes a state machine (see Fig. 3) for the head
instance that manages the â€œtransferâ€ of UTxOs between mainchain and head.
Once the initial transaction appears on the mainchain, establishing the initial state initial, each
head member can attach a commit transaction, which locks (on the mainchain) the UTxOs that
the party wants to commit to the head.
The commit transactions are subsequently collected by the collectCom transaction causing a
transition from initial to open. Once the open state is conï¬rmed, the head members start running
the oï¬€chain head protocol, which evolves the initial UTxO set (the union over all UTxOs committed
by all head members) independently of the mainchain. For the case where some head members fail
to post a commit transaction, the head can be aborted by going directly from initial to ï¬nal.
The head protocol is designed to allow any head member at any point in time to produce,
without interaction, a certiï¬cate for the current head UTxO set. Using this certiï¬cate, the head
member may advance the state machine to the closed state.
Once in closed, the state machine grants parties a contestation period, during which each party
may (one single time) contest the closure by providing the certiï¬cate for a newer head UTxO
set. Contesting leads back to the state closed. After the contestation period has elapsed, the
state machine may proceed to the ï¬nal state. The state machine enforces that the outputs of the
transaction leading to ï¬nal correspond exactly to the latest UTxO set seen during the contestation
period.
3.2 The mainchain state machine
The mainchain part of the Hydra protocol fulï¬lls two principal functions: (1) it locks the mainchain
UTxOs committed to the head while the head is active and (2) it facilitates the settlement of the
ï¬nal head state back to the mainchain after the head is closed. In combination, these two functions
eï¬€ectively result in replacing the initial head UTxO set by the ï¬nal head UTxO set on the mainchain
in a manner that respects but does not persist the complete set of head transactions.
The state machine (Fig. 3) implementing the mainchain protocol comprises the four states
initial, open, closed, and ï¬nal, where the ï¬rst two realize the ï¬rst function (locking the initial UTxO
set) and the second two realize the second function (settling the ï¬nal UTxO set on the mainchain).
State machines inherently sequentialize all actions that involve the machine state. This simpliï¬es
both reasoning about and implementing the protocol. However, steps that could otherwise be taken
in parallel now need to be sequentialized, which might hurt performance. For the cases where this
sequentialization would severely aï¬€ect protocol performance, we employ a (to our knowledge) novel
1We generally assume that mechanisms for establishing pairwise authenticated channels are in place, e.g., by
means of a public-key infrastructure.
10

Figure 3: Mainchain state diagram for the simple version of the Hydra protocol.
technique to parallelize the progression of the state machine on the mainchain.
We use this technique to parallelize the construction of the initial UTxO set of the head.
Without parallelization, all n head members would have to post their commit transactions (their
portion of the initial UTxO set) in sequence, requiring a linear chain of n transactions, each
for one state transition at a time. Instead, we make the state machine consume all n commit
transactions in a single state transition. In Fig. 3, we represent this in the following way: the
transaction representing state initial connects to the transaction representing state open not just
via the collectCom state transition, but also via a set of commit transactions (one for each head
member).
This requires some extra care. We want to ensure that each head member posts exactly one
commit transaction and that the open transaction faithfully collects all commit transactions. We
gain this assurance by issuing a single non-fungible token to each head memberâ€”we call this the
participation token. This token must ï¬‚ow through the commit transaction of the respective head
member and the open transaction, to be valid, must collect the full set of participation tokens. We
may regard the participation token as representing a capability and obligation to participate in the
head protocol.
3.3 The head protocol
The head protocol starts with an initial set U0 of UTxOs that is identical to the UTxOs locked
onchain.
Transactions and local UTxO state. The protocol conï¬rms individual transactions in full
concurrency by collecting and distributing multisignatures on each issued transaction separately.
As soon as such a transaction is conï¬rmed, it irreversibly becomes part of the head UTxO state
evolutionâ€”the transactionâ€™s outputs are immediately spendable in the head, or can be safely trans-
ferred back onchain in case of a head closure.
Each party maintains their view of the local UTxO state L, which represents the current set of
UTxOs evolved from the initial UTxO set U0 by applying all transactions that have been conï¬rmed
so far in the head. As the protocol is asynchronous the partiesâ€™ views of the local UTxO state
generally diï¬€er.
11

Snapshots. The above transaction handling would be enough to evolve the head state. However,
an eventual onchain decommit would have to transfer the full transaction history onchain as there
would be no other way to evidence the correctness of the UTxO set to be restored onchain.
To minimize local storage requirements and allow for an onchain decommit that is independent
of the transaction history, UTxO snapshots U1,U2,... are continuously generated. For this, a
snapshot leader requests his view of the conï¬rmed state Lto be multisigned as a new snapshotâ€”
the ï¬rst head snapshot corresponding to the initial state U0. A snapshot is considered conï¬rmed if
it is associated with a valid multisignature.
In contrast to transactions, the snapshots are generated sequentially. To have the new snapshot
Ui+1 = Lmultisigned, the leader does not need to send his local state Ui+1, but only indicate, by
hashes, the set of (conï¬rmed) transactions to be applied to Ui in order to obtain Ui+1.
The other participants sign the snapshot as soon as they have (also) seen the transactions
conï¬rmed that are to be processed on top of its predecessor snapshot: a partyâ€™s conï¬rmed state is
always ahead of the latest conï¬rmed snapshot.
As soon as a snapshot is seen conï¬rmed, a participant can safely delete all transactions that
have already been processed into it as the snapshotâ€™s multisignature is now evidence that this state
once existed during the head evolution.
Closing the head. A party that wants to close the head decommits his conï¬rmed state Lby
posting, onchain, the latest seen conï¬rmed snapshot Uâ„“ together with those conï¬rmed transactions
that have not yet been processed by this snapshot. During the subsequent contestation period,
other head members can post their own local conï¬rmed states onchain.
3.4 The full protocol and further aspects
To improve on the basic protocol, we change the mainchain state machine (as described in Ap-
pendix C) to include
â€¢incremental commits and decommits (adding UTxOs to or removing them from the head
without closing),
â€¢optimistic one-step head closure without the need for onchain contestation,
â€¢pessimistic two-step head closure with an O(âˆ†) contestation period, independent of n, where
âˆ† is the onchain settlement time of a transaction, and
â€¢split onchain decommit of the ï¬nal UTxO set (in case it is too large to ï¬t into a single
transaction).
These further protocol aspects are summarized in Appendix D:
â€¢The handling of fees incentivizing parties to advance the headâ€™s state machine on the main-
chain.
â€¢The handling of time and timing issues in the (asynchronous) head protocol.
â€¢Transaction throttling in the head to avoid the headâ€™s state becoming too large under pes-
simistic conditions.
12

4 Protocol Setup
In order to create a head-protocol instance, an initiator invites a set of participants {p1,..., pn}
(himself being one of them) to join by announcing to them the protocol parameters: the list of
participants, the parameters of the (multi-)signature scheme to be used, etc.
Each party then establishes pairwise authenticated channels to all other parties.
For some digital-signature scheme, each party pi generates a key pair (ki,ver,ki,sig) and sends his
respective veriï¬cation key ki,ver to all other parties. This â€œstandardâ€ digital-signature scheme will
be used to authenticate mainchain transactions that are restricted to members of the head-protocol
instance.
For the multisignature scheme (MS)â€”see Section 2.1â€”each party pi generates a key pair
(Ki,ver,Ki,sig) â† MS-KG(Î )
and sends his veriï¬cation key Ki,ver to all other parties.
Each party then computes his aggregate key from the received veriï¬cation keys:
Kagg := â† MS-AVK(Î ,(Kj,ver)jâˆˆ[n]) .
The multisignature scheme will be used for the oï¬€chain conï¬rmation (and oï¬€chain and onchain
veriï¬cation) of head-protocol events.
At the end of this initiation, each party pi stores his signing key and all received veriï¬cation
keys for the signature scheme, (
ki,sig, kver := (kj,ver)jâˆˆ[n]
)
,
and his signing key, the veriï¬cation keys, and the aggregate veriï¬cation key for the multisignature
scheme, (
Ki,sig, Kver := (Kj,ver)jâˆˆ[n], Kagg
)
.
If any of the above fails (or the party does not agree to join the head in the ï¬rst place), the
party aborts the initiation protocol and ignores any further action. 2
The initiator now posts the initial transaction onchain as described in Section 5.
5 Mainchain
Here we describe the details of the mainchain state machine (SM) controlling a Hydra head (see
Fig. 3). For state transitions, a formal description of the conditions in tx â‰¡ is foregone in favor of
the intuitive explanations in the text and the ï¬gures.
Onchain veriï¬cation algorithms. The status of the head is maintained in a variableÎ·, which is
part of the SM state and updated by so-called onchain veriï¬cation (OCV) algorithms Initial, Close,
Contest, and Final. In the context of the mainchain protocol, these OCV algorithms are intentionally
kept as generic as possible; this keeps the mainchain SM compatible with many potential head-
protocol variants. The concrete OCV algorithms for the head protocol speciï¬ed in this paper are
given in context of the head protocol itself as they depend on the speciï¬c head-protocol internals:
2Of course, aborting the initiation can be achieved more gracefully by explicitly notifying the initiator about oneâ€™s
non-participation. Techniques are even known to ï¬nish such an initiation in agreement among all parties [23].
13

ğ—‚ğ—‡ğ—‚ğ—ğ—‚ğ–ºğ—…,
Kğ–ºğ—€ğ—€, hğ–¬ğ–³, n, T
â‹®
{p1}, Î½ğ—‚ğ—‡ğ—‚ğ—ğ–ºğ—…, k1
{pn}, Î½ğ—‚ğ—‡ğ—‚ğ—ğ–ºğ—…, kn
(rğ—†ğ—‚ğ—‡, rğ—†ğ–ºğ—‘)
commit Transaction
âˆ…
Forge {p1, â€¦ , pn} :: ğ–¼ğ—‚ğ–½
Ï
â‹®
{p1} âˆª ğ—ğ–ºğ—…â€² , Î½ğ–¼ğ—ˆğ—†, U1
ğ—ğ–ºğ—…, Î½, Î´ Signed: k1
: check that 
1.  equals 
concatenation of 
all ref.ed outputs
Î½ğ—Œğ–¾ğ—ğ—ğ—‰
U1
commited output o
ğ–¼ğ—‚ğ–½
Figure 4: initial transaction (left) with commit transaction (right) attached and one of the
locked outputs (center).
veriï¬cation of head-protocol certiï¬cates and related onchain state updates. As such, the OCV
algorithms can be seen as abstract mainchain algorithms implemented by the speciï¬c head protocol.
Consequently, the OCV implementation for our head protocol is described in Section 6.3.1.
Initial state. After the setup phase of Section 4, the head initiator posts an initial transaction
(see Fig. 4). The initial transaction establishes the SMâ€™s initial state (initial,Kagg,hMT,n,T ),where
initial is a state identiï¬er, Kagg is the aggregated multisignature key established during the setup
phase, hMT is the root of a Merkle tree for the signature veriï¬cation keys kver = (k1,...,k n) ex-
changed during the setup phase (identifying the head members), nis the number of head members,
and T is the length of the contestation period. The initial transaction also forges n participation
tokens {p1,...,p n}:: cid, where the currency ID cid is given by the unique monetary-policy script
consumed by the cid input. The script is unique as it is bound to an output and the ledger prevents
double spending. Consequently, we can use cid as a unique identiï¬er for the newly initialized head.
Crucially, the initial transaction has noutputs, where each output is locked by a validatorÎ½initial
and the ith output has ki in its data ï¬eld. Validator Î½initial ensures the following: either the output
is consumed by
1. an SM abort transaction (see below) or
2. a commit transaction (identiï¬ed by having validator Î½com in its only output), and
(a) the transaction is signed and the signature veriï¬es as valid with veriï¬cation key ki,
(b) the data ï¬eld of the output of the commit transaction is Ui = makeUTxO(o1,...,o m),
where the oj are the outputs referenced by the commit transactionâ€™s inputs andmakeUTxO
stores pairs (out-refj,oj) of outputs oj with the corresponding output reference out-refj.
The general well-formedness and validity of the initial transaction is checked on the mainchain.
The head members additionally check whether the head parameters match the parameters agreed
on during the setup phase. In case of a mismatch the head opening is considered as failed.
Committing outputs to a head. To lock outputs for a Hydra head, the ith head member will
attach a commit transaction (see Fig. 4) to the ith output of the initial transaction. Validator Î½com
ensures that the commit transaction correctly records the partial UTxO set Ui committed by the
party.
14

Collect: Initial State to Open
ğ—‚ğ—‡ğ—‚ğ—ğ—‚ğ–ºğ—…,Kğ–ºğ—€ğ—€,hğ–¬ğ–³,n,T ğ—ˆğ—‰ğ–¾ğ—‡,Kğ–ºğ—€ğ—€,Î·,hğ–¬ğ–³,n,T
â‹®
ğ–¼ğ—ˆğ—…ğ—…ğ–¾ğ–¼ğ—ğ–¢ğ—ˆğ—†
commit transactions
: check that 1.  is proof that  is contained in  2.
txâ‰¡Ï€ğ–¬ğ–³ khğ–¬ğ–³Î·=ğ–¨ğ—‡ğ—‚ğ—ğ—‚ğ–ºğ—…(U1,â€¦,Un)
âˆ… {p1,â€¦,pn}âˆªğ—ğ–ºğ—…
Ï€ğ–¬ğ–³
â‹®
{p1},Î½ğ—‚ğ—‡ğ—‚ğ—ğ–ºğ—…,k1
{pn},Î½ğ—‚ğ—‡ğ—‚ğ—ğ–ºğ—…,kn
(rğ—†ğ—‚ğ—‡,rğ—†ğ–ºğ—‘)
â€¦,Î½ğ–¼ğ—ˆğ—†,U1â‹®
â€¦,Î½ğ–¼ğ—ˆğ—†,Unâ‹®
(râ€² ğ—†ğ—‚ğ—‡,râ€² ğ—†ğ–ºğ—‘)
Forge {p1,â€¦,pn}::ğ–¼ğ—‚ğ–½ Signed: kâ€² 
Initial checks: 1.  to  are in k1 kn hğ–¬ğ–³
: check that 1.next transaction is collect oder abort SM 
Î½ğ–¼ğ—ˆğ—†
Figure 5: initial transaction (left) with collectCom transaction (right) and commit transactions
(center).
All commit transactions will in turn be collected by an SM transactionâ€”either collectCom or
abort (see below).
Collecting commits. The SM transition from initial to open is achieved by posting the collect-
Com transaction (see Fig. 5). All parameters Kagg, hMT, n, and T remain part of the state, but in
addition, a value Î·â†Initial(U1,...,U n) is stored in the state. The idea is that Î·stores information
about the initial UTxO set, which is made up of the individual UTxO sets Ui collected from the
commit transactions, in order to verify head-status information later (see below).
It is also required that all nparticipation tokens be present in the SM output of the collectCom
transaction. This ensures that the collectCom transaction collects all ncommit transactions. Note
that since Î½initial does not allow an SM commit transaction to consume the outputs of the initial
transaction, the only way to post the collectCom transaction is if each head member has posted a
commit transaction.
Finally, note that the transition requires a proof Ï€MT that the signer kâ€² is in the Merkle Tree
belonging to hMT, which ensures that only head members can post SM transactions. This will be
the case for all transitions considered in this paper (and will not be pointed out any further).
Aborting a head. The abort transaction (see Fig. 6) allows a party to abort the creation of a
head in case some parties fail to post a commit transaction. The ï¬nal state does not contain any
information (beyond its identiï¬er), but it is ensured that (1) the outputs U correspond to the union
of all committed UTxO sets Ui and (2) all participation tokens are burned.
Close transaction. In order to close a head, a head member may post the close transaction (see
Fig. 7), which results in a state transition from the open state to the closed state. For a successful
close, a head member must provide valid information Î¾ about (their view of) the current head
state. This information is passed through OCV algorithm Close, resulting in a new OCV status
Î·â€² â†Close(Kagg,Î·,Î¾ ). OCV algorithm Close uses the previous OCV status Î· and Kagg to check
the head information Î¾. Note that if a check fails, Close may output âŠ¥, but in order for a close
transaction to be valid, Î·â€²Ì¸= âŠ¥is required.
Once a close transaction has been posted, a contestation period begins which should last at
least T slots. Hence, the last slot Tï¬nal of the contestation period is recorded in the state, and it is
ensured that Tï¬nal â‰¥râ€²
max + T.
15

Abort
ğ—‚ğ—‡ğ—‚ğ—ğ—‚ğ–ºğ—…,
Kğ–ºğ—€ğ—€, hğ–¬ğ–³, n, T
â‹®
ğ–ºğ–»ğ—ˆğ—‹ğ—
{p1}, Î½ğ—‚ğ—‡ğ—ğ—‚ğ–ºğ—…, k1
{pn}, Î½ğ—‚ğ—‡ğ—ğ—‚ğ–ºğ—…, kn
(rğ—†ğ—‚ğ—‡, rğ—†ğ–ºğ—‘)
â€¦ , Î½ğ–¼ğ—ˆğ—†, U1â‹®
: check that 
1.  is proof that  is 
contained in  
2.  where  
over those who 
committed
txâ‰¡
Ï€ğ–¬ğ–³ kâ€² 
hğ–¬ğ–³
U = {Ui}i i
âˆ…
Ï€ğ–¬ğ–³
Forge {p1, â€¦ , pn} :: ğ–¼ğ—‚ğ–½
: check that 
1.  to  are in  
2.
txâ‰¡
k1 kn hğ–¬ğ–³
{p1, â€¦ , pn} :: ğ–¼ğ—‚ğ–½
ğ–¿ğ—‚ğ—‡ğ–ºğ—…
âˆ…
â‹®
(râ€² 
ğ—†ğ—‚ğ—‡, râ€² ğ—†ğ–ºğ—‘)
Signed: kâ€² 
U
Burn {p1, â€¦ , pn} :: ğ–¼ğ—‚ğ–½
}
<latexit sha1_base64="WxxOLoH8qvPV+BjLCZ5YgtKmayM=">AAAB/XicdVDLSgNBEOz1GeMr6tHLYBA8hd0o6DHoxWMU84BkCbOT2WTIzO4y0yuEJfgDXvUPvIlXv8Uf8DucJHvQBAsaiqpuqqkgkcKg6345K6tr6xubha3i9s7u3n7p4LBp4lQz3mCxjHU7oIZLEfEGCpS8nWhOVSB5KxjdTP3WI9dGxNEDjhPuKzqIRCgYRSvddye9UtmtuDOQZeLlpAw56r3Sd7cfs1TxCJmkxnQ8N0E/oxoFk3xS7KaGJ5SN6IB3LI2o4sbPZp9OyKlV+iSMtZ0IyUz9fZFRZcxYBXZTURyaRW8q/ufhUC2kY3jlZyJKUuQRm4eHqSQYk2kVpC80ZyjHllCmhf2fsCHVlKEtrGiL8RZrWCbNasU7r1TvLsq167yiAhzDCZyBB5dQg1uoQwMYhPAML/DqPDlvzrvzMV9dcfKbI/gD5/MH32SV5A==</latexit>
: check that 
1. next transaction is 
collect oder abort SM 
Î½ğ–¼ğ—ˆğ—†
commit transactions
Figure 6: initial transaction (left) with abort transaction (right) and commit transactions
(center).
Close
ğ—ˆğ—‰ğ–¾ğ—‡,Kğ–ºğ—€ğ—€,Î·,hğ–¬ğ–³,n,T
 ğ–¼ğ—…ğ—ˆğ—Œğ–¾ğ–½,Kğ–ºğ—€ğ—€,Î·â€² ,ğ’,hğ–¬ğ–³,n,T,Tğ–¿ğ—‚ğ—‡ğ–ºğ—…
ğ–¼ğ—…ğ—ˆğ—Œğ–¾
: check that 1.  is proof that  is contained in  2.  3.  4.
txâ‰¡Ï€ğ–¬ğ–³ kâ€² 
hğ–¬ğ–³ğ’={kâ€² }Tğ–¿ğ—‚ğ—‡ğ–ºğ—…=râ€² ğ—†ğ–ºğ—‘+ TÎ·â€² =ğ–¢ğ—…ğ—ˆğ—Œğ–¾(Kğ–ºğ—€ğ—€,Î·,Î¾)
(rğ—†ğ—‚ğ—‡,rğ—†ğ–ºğ—‘)
Signed: k
(râ€² ğ—†ğ—‚ğ—‡,râ€² ğ—†ğ–ºğ—‘)
Signed: kâ€² 
{p1,â€¦,pn}âˆªğ—ğ–ºğ—… {p1,â€¦,pn}âˆªğ—ğ–ºğ—…
Ï€ğ–¬ğ–³,Î¾
â‹®
Figure 7: collectCom transaction (left) with close transaction (right).
Finally, the SM state is extended by a set Cinitialized to the posterâ€™s signing key, i.e., Câ†{ kâ€²}.
Cis used to ensure that no party posts more than once during the contestation period.
Contestation. If the party ï¬rst closing a head posts outdated/incomplete information about the
current state of the head, any other party may post a contest transaction (see Fig. 8), which causes
a state transition from the closed state to itself. The transition handles update information Î¾ by
passing it through OCV algorithm Contest, resulting in a new OCV status Î·â€²â†Contest(Kagg,Î·,Î¾ ).
OCV algorithm Contest uses the previous OCV status Î· and Kagg to check the update information
Î¾. Similarly to Close, Contest may output âŠ¥, but in order for a contest transaction to be valid
Î·â€²Ì¸= âŠ¥is required.
The contest transaction is only valid if the old set Cof parties who have contested (or closed) so
far does not yet include the poster, i.e., kâ€² /âˆˆC. If this check passes, the set is extended to include
the poster of the contest transaction, i.e., Câ€² â†Câˆª{ kâ€²}. Furthermore, contest transactions may
only be posted up until Tï¬nal, i.e., it is required that râ€²
max â‰¤Tï¬nal.
Observe that during the contestation period, up to nâˆ’1 contest transactions may be posted (of
course, the parameter T has to be chosen large enough as to allow each head member to potentially
post a close/contest transaction).
Final state. Once the contestation phase is over, a head may be ï¬nalized by posting a fanout
transaction, taking the SM from closed to ï¬nal. The fanout transaction must have outputs that
correspond to the most recent head state. To that end, OCV predicateFinal checks the transactionâ€™s
16

Contest
ğ–¼ğ—…ğ—ˆğ—Œğ–¾ğ–½,Kğ–ºğ—€ğ—€,Î·â€² ,ğ’â€² ,hğ–¬ğ–³,n,T,Tğ–¿ğ—‚ğ—‡ğ–ºğ—…
ğ–¼ğ—ˆğ—‡ğ—ğ–¾ğ—Œğ—
: check that 1.  is proof that  is contained in  2.  and  3.  4.
txâ‰¡Ï€ğ–¬ğ–³ kâ€² 
hğ–¬ğ–³kâ€² âˆ‰ğ’ ğ’â€² =ğ’âˆª{kâ€² }Î·â€² =ğ–¢ğ—ˆğ—‡ğ—ğ–¾ğ—Œğ—(Kğ–ºğ—€ğ—€,Î·,Î¾)râ€² ğ—†ğ–ºğ—‘â‰¤Tğ–¿ğ—‚ğ—‡ğ–ºğ—…
(râ€² ğ—†ğ—‚ğ—‡,râ€² ğ—†ğ–ºğ—‘)
Signed: kâ€² 
ğ–¼ğ—…ğ—ˆğ—Œğ–¾ğ–½,Kğ–ºğ—€ğ—€,Î·,ğ’,hğ–¬ğ–³,n,T,Tğ–¿ğ—‚ğ—‡ğ–ºğ—…
(rğ—†ğ—‚ğ—‡,rğ—†ğ–ºğ—‘)
Signed: k
{p1,â€¦,pn}âˆªğ—ğ–ºğ—… {p1,â€¦,pn}âˆªğ—ğ–ºğ—…
Ï€ğ–¬ğ–³,Î¾
 â€² 
Figure 8: close/contest transaction (left); contest transaction (right)
Fanout
ğ–¿ğ–ºğ—‡ğ—ˆğ—ğ—
: check that 1.  is proof that  is contained in  2.  3.
txâ‰¡Ï€ğ–¬ğ–³ kâ€² 
hğ–¬ğ–³ğ–¥ğ—‚ğ—‡ğ–ºğ—…(Î·,U )râ€² ğ—†ğ—‚ğ—‡> Tğ–¿ğ—‚ğ—‡ğ–ºğ—…
Ï€ğ–¬ğ–³ ğ–¿ğ—‚ğ—‡ğ–ºğ—…
âˆ…
â‹®
(râ€² ğ—†ğ—‚ğ—‡,râ€² ğ—†ğ–ºğ—‘)
Signed: kâ€² 
U
Burn {p1,â€¦,pn}: : ğ–¼ğ—‚ğ–½
}
<latexit sha1_base64="WxxOLoH8qvPV+BjLCZ5YgtKmayM=">AAAB/XicdVDLSgNBEOz1GeMr6tHLYBA8hd0o6DHoxWMU84BkCbOT2WTIzO4y0yuEJfgDXvUPvIlXv8Uf8DucJHvQBAsaiqpuqqkgkcKg6345K6tr6xubha3i9s7u3n7p4LBp4lQz3mCxjHU7oIZLEfEGCpS8nWhOVSB5KxjdTP3WI9dGxNEDjhPuKzqIRCgYRSvddye9UtmtuDOQZeLlpAw56r3Sd7cfs1TxCJmkxnQ8N0E/oxoFk3xS7KaGJ5SN6IB3LI2o4sbPZp9OyKlV+iSMtZ0IyUz9fZFRZcxYBXZTURyaRW8q/ufhUC2kY3jlZyJKUuQRm4eHqSQYk2kVpC80ZyjHllCmhf2fsCHVlKEtrGiL8RZrWCbNasU7r1TvLsq167yiAhzDCZyBB5dQg1uoQwMYhPAML/DqPDlvzrvzMV9dcfKbI/gD5/MH32SV5A==</latexit>
ğ–¼ğ—…ğ—ˆğ—Œğ–¾ğ–½,Kğ–ºğ—€ğ—€,Î·,ğ’,hğ–¬ğ–³,n,T,Tğ–¿ğ—‚ğ—‡ğ–ºğ—…
(rğ—†ğ—‚ğ—‡,rğ—†ğ–ºğ—‘)
Signed: k
{p1,â€¦,pn}âˆªğ—ğ–ºğ—…
Figure 9: close/contest transaction (left); fanout transaction (right)
output set U against the information recorded in Î·. The fanout transaction is only valid if Final
outputs true. Moreover, to ensure that the fanout transaction is not posted too early, râ€²
min >Tï¬nal
is required. Finally, all participation tokens must be burned.
6 Simple Head Protocol Without Conï¬‚ict Resolution
This section describes the simpliï¬ed version of the head protocol, and without conï¬‚ict resolution,
with the goal to demonstrate the protocol basics without overloading the presentation with too
many details. Conï¬‚ict resolution is added to the protocol in Appendix B, and the full protocol is
sketched in Appendix C.
We ï¬rst introduce a security deï¬nition for the head protocol in Section 6.1. The protocol
machine is described in Section 6.2, the head-speciï¬c mainchain code in Section 6.3, and a security
proof for the head protocol is given in Section 6.4.
6.1 Security deï¬nition
6.1.1 Protocol syntax
The head-protocol syntax is HP = (Prot,Initial,Close,Contest,Final). The main component is the
protocol machine Prot, an instance of which is run by every head member. The other algorithms
are used for setup and onchain veriï¬cation and form the interface to the mainchain. In particular,
â€¢Î£ â†generates global parameters,
17

â€¢(Kver,Ksig) â†MS-KG(Î£) allows every head member to generate fresh public/private key
material based on the global parameters,
â€¢Kagg â†MS-AVK(Î£,(Kver,i)i) aggregates public keys, and
â€¢Initial, Close, Contest, and Final are onchain veriï¬cation algorithms (cf. Section 5).
The head-protocol machine Prot has the following interface to the environment:
â€¢input (init,i,K ver,Ksig,U0) is used to initialize the head protocol, for the party with index
i, with a vector of public-key material Kver, private-key material Ksig, and an initial UTxO
set U0;
â€¢input (new,tx) is used to submit a new transaction tx;
â€¢output (seen,tx) announces that transaction tx has been seen (by the party outputting the
message);
â€¢output (conf,tx) announces that transaction tx has been conï¬rmed (in the view of the party
outputting the message);
â€¢input (close) is used to initiate head closure (produces a certiï¬cate Î¾); and
â€¢input (cont,Î·) is used to contest (produces a certiï¬cate Î¾).
6.1.2 Protocol security
The security deï¬nition for the head protocol guarantees the following four, intuitively stated prop-
erties:
â€¢Consistency: No two uncorrupted parties see conï¬‚icting transactions conï¬rmed.
â€¢Liveness: If all parties remain uncorrupted and the adversary delivers all messages, then
every transaction becomes conï¬rmed at some point.
â€¢Soundness: The ï¬nal UTxO set accepted on the mainchain results from a set of seen trans-
actions.
â€¢Completeness: All transactions observed as conï¬rmed by an honest party at the end of the
protocol are considered on the mainchain.
Experiment for security deï¬nition. The security properties above are captured by considering
a random experiment that involves
â€¢an adversary A,
â€¢a network under full scheduling control of A, able to drop messages or delay them arbitrarily,
â€¢a setup phase,
â€¢nparties pi, corruptible by A, running the head protocol with the parameters from the setup
phase and an initial UTxO set U0 chosen by A, and
â€¢an abstract mainchain (mostly) controlled by A.
18

The experiment ends once the mainchain state machine arrives in the ï¬nal state, and the
adversary wins if certain conditions are not satisï¬ed at the end of the experiment.
In more detail, the experiment proceeds as follows:
1. Global parameters Î£ â†MS-Setup are generated, and Î£ is passed to A.
2. For each party pi, key material (Kver,i,Ksig,i) â†MS-KG(Î£) is generated, and the vector Kver
of all public keys and Kagg â†MS-AVK(Î£,Kver) are passed to A.
3. Each party piâ€™s protocol machine is initialized with ( init,i,K ver,Ksig,i,U0), where U0 is
chosen by A.
4. The adversary now gets to control inputs to parties (e.g., new transactions, close/contest
requests) and sees outputs (e.g., seen and conï¬rmed transactions). The following bookkeeping
takes place:
â€¢when an uncorrupted party pi outputs Î¾ upon close command, record (close,i,Î¾ );
â€¢when uncorrupted party pi outputs Î¾ upon (cont,Î·) command, record ( cont,i,Î·,Î¾ ).
In â€œparallelâ€ to the above, the experiment setsC,Hcont â†âˆ… and does the following to simulate
the mainchain:
(a) Initialize Î·â†(U0,0,âˆ…).
(b) When A supplies ( i,Î¾): if i is uncorrupted, Î¾ gets replaced by the Î¾ recorded in
(close,i,Î¾ ) and Hcont â†Hcont âˆª{i}. Then, Î· â†Close(Kagg,Î·,Î¾ ) and C â†Câˆª{ i}
is computed. If Close rejects, everything in this step is discarded and the step repeated.
(c) The adversary gets to repeatedly supply (i,Î¾) for i /âˆˆC; if iis uncorrupted, Î¾gets replaced
by the Î¾ recorded in (cont,i,Î¾ ) and Hcont â†Hcont âˆª{i}. Then, Î·â†Contest(Kagg,Î·,Î¾ )
and Câ†Câˆª{ i}is computed. If Contest rejects, everything in this step is discarded.
(d) When the adversary supplies Uï¬nal, bâ†Final(Î·,Uï¬nal) is computed, and the experiment
ends.
Our protocol gives diï¬€erent security guarantees depending on the level of adversarial corruption. It
provides correctness independently of both, the number of corrupted head parties and the network
conditions. But the guarantee that the protocol makes progress (i.e., that new transactions get
conï¬rmed in the head) is only provided in the case that no head parties are corrupted and that the
network conditions are good.
To capture this diï¬€erence, we distinguish:
Active Adversary. An active adversary Ahas full control over the protocol, i.e., he is fully unre-
stricted in the above security game.
Network Adversary. A network adversary Aâˆ…does not corrupt any head parties, eventually delivers
all sent network messages (i.e., does not drop any messages), and does not cause the close
event. Apart from this restriction, the adversary can act arbitrarily in the above experiment.
19

Security events. Consider the following random variables:
â€¢ Ë†Si: the set of transactions tx for which party pi, while uncorrupted, output (seen,tx);
â€¢Ci: the set of transactions tx for which party pi, while uncorrupted, output (conf,tx);
â€¢Hcont: the set of (at the time) uncorrupted parties who produced Î¾upon close/contest request
and Î¾ was applied to correct Î· (see above); and
â€¢ H: the set of parties that remained uncorrupted.
The security of the head protocol is captured by considering the following events, each corresponding
to one of the security properties introduced above:
â€¢Consistency (Head): In presence of an active adversary, the following condition holds:
For all i,j, U0 â—¦(Ci âˆªCj) Ì¸= âŠ¥, i.e., no two uncorrupted parties see conï¬‚icting transactions
conï¬rmed.
â€¢Liveness (Head): In presence of a network adversary the following condition holds: For
any transaction tx input via ( new,tx), the following eventually holds: tx âˆˆâ‹‚
iâˆˆ[n] Ci âˆ¨ âˆ€i:
U0 â—¦(Ci âˆª{tx}) = âŠ¥, i.e., every party will observe the transaction conï¬rmed or every party
will observe the transaction in conï¬‚ict with his conï¬rmed transactions. 3
â€¢Soundness (Chain): In presence of an active adversary, the following condition is satisï¬ed:
âˆƒËœS âŠ†â‹‚
iâˆˆHË†Si : Uï¬nal = U0 â—¦ËœS, i.e., the ï¬nal UTxO set results from a set of seen transactions.
â€¢Completeness (Chain): In presence of an active adversary, the following condition holds:
For ËœS as above, â‹ƒ
piâˆˆHcont Ci âŠ†ËœS, i.e., all transactions seen as conï¬rmed by an honest party
at the end of the protocol are considered.
Note that our simpliï¬ed protocol with conï¬‚ict resolution and our full protocol in Appendices B
and C achieve liveness in the above sense, but that our simpliï¬ed protocolwithout conï¬‚ict resolution
in Section 6 only achieves a weaker notion of liveness, namely liveness in a
Conï¬‚ict-Free Execution: Let N= {tx |(new,tx)}the set of all transactions input to a new event
during the execution of the head protocol. A head-protocol execution is conï¬‚ict-free iï¬€
U0 â—¦NÌ¸ = âŠ¥.
Respectively, the liveness aspect of the simpliï¬ed protocol without conï¬‚ict resolution is captured
by the following event, instead:
â€¢Conflict-Free Liveness (Head): In presence of a network adversary, a conï¬‚ict-free execu-
tion satisï¬es the following condition: For any transaction tx input via (new,tx), tx âˆˆâ‹‚
iâˆˆ[n] Ci
eventually holds.
6.2 Protocol machine
The protocol machine Prot consists of a number of subroutines that handle inputs from the en-
vironment (e.g., the client command to issue a new transaction for conï¬rmation, or the arrival
of another partyâ€™s conï¬rmation request). The protocol is depicted in Figure 10. All relevant
non-obvious notation is explained in the following paragraphs.
3In particular, liveness expresses that the protocol makes progress under reasonable network conditions if no head
parties get corrupted â€“ implying that, given any guaranteed upper bound Î´ on message delivery delay, the worst-case
transaction-conï¬rmation time is bounded in function of Î´.
20

6.2.1 Local state representation
Every party maintains local objects to represent transactions, snapshots, and his local head-UTxO
set. These objects exist in two versions, a seen object has been signed by the party (the party has
seen and approved the event); and a conï¬rmed object is associated with a valid multisignature (the
party has received a valid multisignature on the object). A seen object X is denoted by Ë†X and a
conï¬rmed object by X.
A partyâ€™s local protocol state consists of the multisignature veriï¬cation keys and its own signing
key, of snapshot counters Ë†s and s, and of variables
â€¢ Ë†Uand U, keeping track of the most recent seen resp. conï¬rmed, snapshots,
â€¢ Ë†Land L, keeping track of recent seen resp. conï¬rmed UTxO sets, and
â€¢ Ë†T and T, the sets of seen resp. conï¬rmed, transactions that have not been considered by a
snapshot yet.
Variables Ë†Uand Ustore so-called snapshot objects, which are data structures keeping information
about a snapshot. Speciï¬cally, a snapshot object Uhas the following structure:
U.s snapshot number
U.U corresponding UTxO set
U.h hash of U
U.T set of transactions relating this snapshot to its predecessor
U.S signature accumulator (array of signatures)
U.ËœÏƒ multisignature
The function snObj(s,U,T ) initializes a snapshot object and is explained later.
Similarly, Ë†T and T store sets of transaction objects. A transaction object tx has the following
structure:
tx.i index of the party issuing transaction for certiï¬cation
tx.tx transaction
tx.h hash of tx
tx.S signature accumulator (array of signatures)
tx.ËœÏƒ multisignature.
The function txObj(i,tx) initializes a transaction object by setting the appropriate ï¬elds to the
passed values (including computing the hash of tx) and the remaining ï¬elds to âˆ…resp. âŠ¥.
6.2.2 Three-round entity conï¬rmation
Transactions and snapshots are conï¬rmed in an asynchronous 3-round process: 4
â€¢req: The issuer of a transaction or snapshot requests the entity to be signed by sending the
entity description to every head member.
4Note that, as a variant, this 3-round process (with linear communication in n) can be condensed to 2 rounds
(with quadratic communication in n) by combining the last two rounds into an â€œall-to-allâ€ signature notiï¬cation.
This variant may be preferable for small n.
21

â€¢ack: The head members acknowledge the entity be replying their signatures on the entity to
the issuer.
â€¢conf: The issuer collects all signatures, combines the multisignature, and sends the multisig-
nature to all head members.
6.2.3 Code notation
Code is depicted by view of a generic head party pi. We assume that a party only accepts mes-
sages authenticated by its claimed sender (by use of the authenticated channels established during
the setup phase)â€”unauthenticated messages are simply treated as unseen by the recipient. For
simplicity, whenever a party pi sends a message to all head parties, it also sends the message to
itself.
For the transaction set Ë†T (and similarly T), Ë†T[h] denotes tx âˆˆ Ë†T such that tx.h = h, i.e., the
transaction object corresponding to the transaction with hash H(tx) = h.
The â†“operator indicates the projection of an object onto a subset of its ï¬elds. For example,
Ë†Tâ†“(h) denotes the set of hashes corresponding to the transactions in Ë†T.
The following notation is used to describe the application of transactions to a given UTxO set.
â€¢Uâ€²= U â—¦tx assigns to Uâ€²the UTxO set resulting from applying transaction tx to UTxO set
U. In case that the validation fails it returns Uâ€²= âŠ¥.
â€¢Uâ€²= U â—¦T assigns to Uâ€² the UTxO set resulting from applying all transaction in the trans-
action set T to UTxO set U. In case that not all transactions can be applied it returns
Uâ€²= âŠ¥.
In the protocol routines of Fig. 10, byrequire(P), we express that predicate P must be satisï¬ed
for the further execution of a routineâ€”while immediately terminated onÂ¬P. By wait(P) we express
a non-blocking wait for predicate P to be satisï¬ed. On Â¬P, the execution of the routine is stopped,
queued, and reactivated as soon as P is satisï¬ed. Finally, we assume the code executions of each
routine to be atomicâ€”excluding the blocks of code that may be put into the wait queue for later
execution, in which case we assume the wait block to be atomic.
6.2.4 Protocol ï¬‚ow
Initializing the head. Initially, by activation via the ( init) event, the parties store their mul-
tisignature key material form the setup phase, ad set L= Ë†L= U = Ë†U = U0 where U0 is the
initial UTxO set extracted from the Î·-state of the collectCom transaction (see Fig. 5). The initial
transaction sets are empty, T = Ë†T = âˆ…, and s= Ë†s= 0.
Conï¬rming new transactions.
(new). At any time, by calling ( new,tx), a head party can (asynchronously) inject a new trans-
action tx to the head protocolâ€”initiating a 3-round conï¬rmation process for tx as described in
Section 6.2.2. For this, the transaction must be well-formed ( valid-tx) and applicable to the current
conï¬rmed local UTxO state: Lâ—¦tx Ì¸= âŠ¥. If the checks pass, a ( reqTx,tx) request is sent out to all
parties.
22

Simpliï¬ed Hydra Head Protocol Without Conï¬‚ict Resolution
on(init,i,Kver,Ksig,U0)from client
Vâ†Kver
avkâ†MS-AVK(V)
skâ†Ksig
Ë†s,sâ†0
Ë†U,Uâ†snObj(0,U0,âˆ…)
Ë†L,Lâ†U0
Ë†T,T â†âˆ…
on(new,tx)from client
requirevalid-tx(tx) andLâ—¦txÌ¸=âŠ¥
multicast(reqTx,tx)
on(newSn)forpi
requireleader(s+ 1) =iandË†U=U
Tâ†(maxTxos(T))â†“(h)
multicast(reqSn,s+ 1,T)
on(close)from client
return(U.U,U.s,U.ËœÏƒ,Tâ†“(tx,ËœÏƒ))
on(cont,Î·)from client
(UÎ·,sÎ·,TÎ·)â†Î·
ifsâ‰¤s
Uâ†UÎ·
sâ†sÎ·
ËœÏƒâ†Îµ
else
Uâ†U.U
sâ†s
ËœÏƒâ†U.ËœÏƒ
Tâ€²â†applicable(U,Tâ†“(tx)âˆªTÎ·) \TÎ·
ifU=UÎ·
Uâ†Îµ
return
(U,s,ËœÏƒ,{tâˆˆTâ†“(tx,ËœÏƒ) |t.txâˆˆTâ€²})
on(reqTx,tx)frompj
requirevalid-tx(tx)âˆ§Ë†Lâ—¦txÌ¸=âŠ¥
waitLâ—¦txÌ¸=âŠ¥
hâ†H(tx)
Ë†T[h]â†txObj(j,tx)
Ë†Lâ†Ë†Lâ—¦tx
output(seen,tx)
Ïƒiâ†MS-Sign(sk,h)
send(ackTx,h,Ïƒi) topj
on(ackTx,h,Ïƒj)frompj
requireË†T[h].i=i
requireË†T[h].S[j] =Îµ
Ë†T[h].S[j]â†Ïƒj
ifâˆ€k: Ë†T[h].S[k]Ì¸=Îµ
ËœÏƒâ†MS-ASig(h,V,Ë†T[h].S)
ifËœÏƒÌ¸=âŠ¥
multicast(confTx,h,ËœÏƒ)
on(confTx,h,ËœÏƒ)frompj
ifMS-Verify(avk,h,ËœÏƒ)
txâ†Ë†T[h].tx
Lâ†Lâ—¦tx
Ë†T[h].ËœÏƒâ†ËœÏƒ
T[h]â†Ë†T[h]
Ë†T â†Ë†T \Ë†T[h]
output(conf,tx)
on(reqSn,s,T)frompj
requires=s+ 1 andleader(s) =j
waits= Ë†sandTâŠ†Tâ†“(h)
Ë†sâ†Ë†s+ 1
Ë†Uâ†snObj(Ë†s,U.U,T)
Ïƒiâ†MS-Sign(sk,Ë†U.hâˆ¥Ë†s)
send(ackSn,Ë†s,Ïƒi) topj
on(ackSn,s,Ïƒj)frompj
requires= Ë†sandleader(s) =i
requireË†U.S[j] =Îµ
Ë†U.S[j]â†Ïƒj
ifâˆ€k: Ë†U.S[k]Ì¸=Îµ
ËœÏƒâ†MS-ASig(Ë†U.hâˆ¥s,V,Ë†U.S)
ifËœÏƒÌ¸=âŠ¥
multicast(confSn,s,ËœÏƒ)
on(confSn,s,ËœÏƒ)frompj
requires= Ë†sÌ¸=s
ifMS-Verify(avk,Ë†U.hâˆ¥Ë†s,ËœÏƒ)
sâ†s
Ë†U.ËœÏƒâ†ËœÏƒ
Uâ†Ë†U
T â†T \ReachT(U.T)
Figure 10: Head-protocol machine for the simple protocol without conï¬‚ict resolution from the
perspective of party pi.
(reqTx). Upon receiving request ( reqTx,tx), a signature is only issued by a party pi if tx applies
to his local seen UTxO state: Ë†Lâ—¦tx Ì¸= âŠ¥. If this is the case, the party waits until his conï¬rmed
UTxO state Lhas â€œcaught upâ€: the signature is only delivered as soon as Lâ—¦ tx Ì¸= âŠ¥, i.e., a
23

transaction is only signed once it is applicable to the local conï¬rmed state.
In case the preconditions are satisï¬ed, a respective transaction object is allocated, initialized,
and added to Ë†T; Ë†Lis updated by applying tx, and ( seen,tx) is output; and, ï¬nally, a signature on
the hash of tx, Ïƒ= MS-Sign(H(tx)), is delivered back to the transaction issuer by replying with an
(ackTx,H(tx),Ïƒ).
(ackTx). Upon receiving acknowledgment (ackTx,h,Ïƒ j), the transaction issuer stores the received
signature in the respective transaction object. If a signature from each party has been collected, pi
computes the multisignature ËœÏƒ and, if valid, sends it to all parties in a ( confTx,h, ËœÏƒ) message.
(confTx). Upon receiving conï¬rmation ( confTx,h, ËœÏƒ) from the transaction issuer, containing a
valid multisignature, the multisignature is stored in the respective transaction object, Lis updated
by applying tx, and the transaction object is moved from Ë†T to T. Finally, (conf,tx) is output.
Creating snapshots. In parallel to conï¬rming transactions, parties generate snapshots in a
strictly sequential round-robin manner. We call the party responsible for issuing the ith snapshot
the leader of the ith snapshot. The issuance frequency of the snapshots tunes a tradeoï¬€ between
the transaction space that has to maintained by the parties for storing conï¬rmed but snapshot-
unprocessed transactions against the snapshot-communication overhead in the head protocol. As
the information to be exchanged among the parties for snapshot conï¬rmation is small, such snap-
shots can in principle be greedily issued as soon as the next snapshot leader sees a new conï¬rmed
transaction.
(newSn). On activation by (newSn), the snapshot leader veriï¬es whether Ë†U= Uto ensure that he is
not already in the process of snapshot creation. The leader pi then announces the transaction set T,
the not yet snapshot-processed conï¬rmed transactions to be applied to compute the new snapshot.
However, to reduce communication overhead, only the hashes of the maximal transactions of T
are announced which are the transactions of T not referenced by another transaction in T. This
maximal set is computed by functionT = maxTxos(T)â†“(h). Finally the leader sends (reqSn,s+1,T)
to all parties.
(reqSn). Upon receiving request (reqSn,s,T ), party pi checks that sis the next snapshot number
and that pj is responsible for leading its creation. Party pi then waits until the previous snapshot
is conï¬rmed (s= Ë†s) and all transactions referred in T are conï¬rmed.
Only then, pi increments his seen-snapshot counter Ë† s, and allocates a new snapshot object
calling function snObj that performs the following steps:
1. It reconstructs the transaction set to be applied to the latest conï¬rmed snapshot by calling
function ReachT(T) that computes all transactions in T reachable from the transactions (with
hashes) in T by following the output references (the inverse of maxTxos); and
2. computes the UTxO set of the new snapshot as Ë†U.U â†U.U â—¦ReachT(T), and
3. computes the hash of Ë†U.U and sets the ï¬elds for the snapshot number and the maximal
transactions applied.
24

Finally, pi computes a signatureÏƒi = MS-Sign(sk,H( Ë†U)âˆ¥Ë†s), and replies topj the message (ackSn,s,Ïƒi).5
(ackSn). Upon receiving acknowledgment ( ackSn,s,Ïƒ j), the snapshot leader stores the received
signature in the respective snapshot object. If a signature from each party has been collected, pi
computes the multisignature ËœÏƒ and, if valid, sends it to all parties in a ( confSn,h, ËœÏƒ) message.
(confSn). Upon receiving conï¬rmation (confSn,s, ËœÏƒ) from the snapshot leader, containing a valid
multisignature, pi stores the multisignature and updates s = s and U = Ë†U. Finally, the set of
conï¬rmed transactions is reduced by excluding the transactions that have been processed by U:
T â†T \ReachT(U.T).
Closing the head.
(close). In order to close a head, a party causes the ( close) event which returns the latest
conï¬rmed snapshot U.U, snapshot number U.s and the respective multisignature U.ËœÏƒ, together
with the remaining conï¬rmed transactions T
â†“(tx,ËœÏƒ)
(multisigned). These items form the certiï¬cate
Î¾ to be posted onchain (see Section 6.3.2).
(cont). In order to contest the current state closed on the mainchain, a party causes the (cont,Î·)
event with input Î· being the latest observed head status that has been aggregated onchain for this
head so far (by a sequence of close and contest transactions).
The algorithm then computes â€œdiï¬€erentialâ€ data between the current onchain head status and
the contesterâ€™s conï¬rmed view: the latest conï¬rmed snapshot (if newer than seen onchain) and the
set of conï¬rmed transactions (in his view) not yet considered by the current state Î·. These items
form the certiï¬cate Î¾ to be posted onchain (see Section 6.3.2).
We only want to pass on the (multisigned) transactions in T
â†“(tx)
\TÎ· that have not yet been
processed by the latest snapshot U. This is achieved by applying function applicable that tests, for
each transaction in tx âˆˆT
â†“(tx)
âˆªTÎ· in appropriate order, whether U â—¦tx Ì¸= âŠ¥is still applicable.
Note that the transactions in TÎ· have to be considered in this process as some transactions in T
may directly depend on them, and would otherwise not be detected to be applicable. As we only
want to extract â€œdiï¬€erentialâ€ data, the transactions in TÎ· are ï¬nally removed again as they are
already recorded in the (accumulative) Î· state.
6.3 Head-speciï¬c mainchain functionality
On an abstract level, as described in Section 5, mainchain and head functionality are clearly sepa-
rated into events that happen onchain and events that happen in the head. In particular, network
participants that are not members of the head protocol only observe mainchain events.
Still, depending on the concrete implementation of the head certiï¬cation process (which our
abstract description of the mainchain functionality is agnostic of), some mainchain functionality
has to be adapted to the speciï¬c choice made for the head protocol. This concerns two aspects:
5Note that no UTxO sets have to be exchanged in this process as the parties can locally compute a new snapshot
by the given transaction hashes.
25

Hydra Protocol
Mainchain Protocol                         ğ—Œğ—ğ–ºğ—ğ–¾ğ—†ğ–ºğ–¼ğ—ğ—‚ğ—‡ğ–¾
Head Protocol 
                                ğ—‰ğ—‹ğ—ˆğ—ğ—ˆğ–¼ğ—ˆğ—…ğ—†ğ–ºğ–¼ğ—ğ—‚ğ—‡ğ–¾
client
chain
messaging head
messagingğšŠğš‹ğšœğ–®ğ–¢ğ–µ ğš’ğš–ğš™ğš•ğ–®ğ–¢ğ–µğšŠğš‹ğšœğ–¢ğ–§ğ–¨ ğš’ğš–ğš™ğš•ğ–¢ğ–§ğ–¨
Figure 11: Hydra protocol components.
Onchain veriï¬cation (OCV). The conï¬rmation of head events by means of the multisignature
scheme must be veriï¬able onchain; and thus, the exact workings of head certiï¬cation must
be known to the mainchain protocol. Now, given that the onchain portion of the mainchain
protocol (i.e., state machine transition validation) is realized by EUTxO validator scripts,
these scripts utilize the abstract interface of the OCV. Hence, we interpret the head OCV
code as implementing the abstract mainchain OCV speciï¬cation for all network participants
(Fig. 11).
Chain/head interaction (CHI). Upon observing certain onchain events, a head memberâ€™s main-
chain functionality must interact with the head protocol. For instance, this is the case, when a
head member observes the closing of the head on the mainchain. The mainchain functionality
must then query the head protocol to know whether a contest transaction must be posted.
6.3.1 Onchain veriï¬cation (OCV)
Recall that the mainchain functionality was generically described it terms of Î·, the latest head
state as known onchain, and Î¾, a certiï¬cate posted by a head member to update Î· by delivering
head-conï¬rmed information.
We shortly recapitulate the abstract workings of OCV. After the processing of the collectCom
transaction, the initial UTxO set is stored as Î· in association of the open state. Later, a party pi
can
â€¢produce a certiï¬cate Î¾ accepted by Close(Â·) to close out the head and make (his view of) the
current head-UTxO set available on the mainchain, and,
â€¢given the current state Î· on the mainchain, produce a certiï¬cate Î¾ accepted by Contest(Î·,Â·)
to contest a closure and supply an updated view of the head-UTxO set to the mainchain.
Finally, the function Final checks the UTxO set in the transaction that moves the state machine
into its ï¬nal state against the information stored in Î·.
We now instantiate the respective onchain veriï¬cation (OCV) functionality for the head protocol
given in this sectionâ€”with its speciï¬c way of certifying head states (see Fig. 12).
Initial. The entire initial UTxO set U0 is composed from the ncommitted UTxO sets Up1 ,...,U pn,
and returned as Î·= (U0,0,âˆ…).
26

Algorithms for Onchain Veriï¬cation
Initial(Up1,...,Upn)
return(Up1 âˆªÂ·Â·Â·âˆªUpn,0,âˆ…)
Close(Kagg,Î·,Î¾)
(U,s,ËœÏƒ,T) â†Î¾
if âˆƒ(txi,ËœÏƒi) âˆˆT:
Â¬MS-AVerify(Kagg,H(txi),ËœÏƒi)
returnâŠ¥
if s= 0
(U,Â·,Â·) â†Î·
else ifÂ¬MS-AVerify(Kagg,H(U)âˆ¥s,ËœÏƒ)
returnâŠ¥
if Uâ—¦Tâ†“(tx)=âŠ¥
returnâŠ¥
return(U,s,Tâ†“(tx))
Contest(Kagg,Î·,Î¾)
(UÎ·,sÎ·,TÎ·) â†Î·
(U,s,ËœÏƒ,T) â†Î¾
if âˆƒ(txi,ËœÏƒi) âˆˆT: Â¬MS-AVerify(Kagg,H(txi),ËœÏƒi)
returnâŠ¥
if sâ‰¤sÎ·
UNâ†UÎ·
else
UNâ†U
if Â¬MS-AVerify(Kagg,H(U)âˆ¥s,ËœÏƒ) returnâŠ¥
TÎ·â†applicable(UN,TÎ·)
if UNâ—¦(TÎ·âˆªTâ†“(tx)) =âŠ¥
returnâŠ¥
return(UN,s,TÎ·âˆªTâ†“(tx))
Final(Î·,U)
(UÎ·,sÎ·,TÎ·) â†Î·
return(U=UÎ·â—¦TÎ·)
Figure 12: The algorithms used by the state machine for onchain veriï¬cation.
Close. The state machine uses the onchain veriï¬cation (OCV) algorithm Close to verify the infor-
mation submitted by the party.
Recall that, when a pi receives the close command, it simply outputs as certiï¬cate the snap-
shot number, the UTxO set, and the multisignatures corresponding to the most recent conï¬rmed
snapshot U as well as all conï¬rmed transactions in T which have not yet been considered in U,
along with the corresponding multisignatures.
OCV function Close (see Figure 12) veriï¬es all multisignatures in Î¾ = (U,s, ËœÏƒ,T ), i.e., those of
H(U)âˆ¥sand the transactions in T, and ensures that the transactions in T can be applied to U (or,
in case of s= 0, to U0). The algorithm then outputs the new state Î·â€²= (U,s,T â†“(tx)).
Contest. The state machine uses the OCV algorithm Contest to verify the â€œdiï¬€erentialâ€ data
submitted by a contesting party.
Recall that, when a pi receives the command ( cont,Î·) for Î· = ( UÎ·,sÎ·,TÎ·), he supplies his
latest snapshot U.U if it is newer than UÎ·, and those conï¬rmed transactions that have not yet been
considered by the latest snapshot. In case that UÎ· is newer than the own snapshot, the transactions
yet to be delivered can be found by trying to apply them (together withTÎ·) to UÎ·â€”as those already
considered by UÎ· can no longer be applied; this computation is performed by function applicable.
Similarly to the close case, OCV function Contest, given Î¾ = (U,s, ËœÏƒ,T ), ï¬rst checks all signa-
tures.
In case that the provided snapshot U is newer than the snapshot UÎ· from the onchain state Î·,
the set TÎ· is reduced to those transactions that are still applicable to the newer of both snapshots,
UN.
Finally, it is ensured that TÎ· âˆªTâ†“(tx) can be applied to the newest of both snapshots, and the
27

Chain/Head Interaction
on(clientTx,tx)
head.(new,tx)
on(clientClose)
Î¾â†head.(close)
chain.postTx(close,Î¾)
on(chainInitial)
requireKchainagg =Ksetupagg
requirehMT=HMerkle(kver)
chain.postTx(commit,U)
on(chainInitialTimeOut)
if (all members committed)
chain.postTx(collectCom)
else
chain.postTx(abort)
on(chainCollectCom)
(U0,Â·,Â·) â†Initial(Up1,...,Upn)
head.(init,i,Kver,Ksig,i,U0)
on(chainClose)
Î·â€²= (Uâ€²,sâ€²,Tâ€²) â†chain.Close(Kagg,Î·,Î¾)
Î¾= (U,s,ËœÏƒ,T) â†head.(cont,Î·â€²)
if s>sâ€² âˆ¨TÌ¸=âˆ…
chain.postTx(contest,Î¾)
on(chainContest)
Î·â€²= (Uâ€²,sâ€²,Tâ€²) â†chain.Contest(Kagg,Î·,Î¾)
Î¾= (U,s,ËœÏƒ,T) â†head.(cont,Î·â€²)
if s>sâ€² âˆ¨TÌ¸=âˆ…
chain.postTx(contest,Î¾)
on(chainClosedTimeOut)
chain.postTx(fanout)
Figure 13: Chain/head interaction: Additional mainchain actions for head members.
new (aggregate) state Î·â€²= (UN,s,T Î· âˆªTâ†“(tx)) is output.
Final. Given Î·= (UÎ·,sÎ·,TÎ·) and U, Final checks that U = UÎ· â—¦TÎ·.
6.3.2 Chain/head interaction (CHI)
In Fig. 13, we summarize that part of the Hydra mainchain functionality that interacts with the
head member (client) and the head protocol.
Routine clientTx handles the clientâ€™s request to issue a head transaction by delegating the
request to the head protocol. Routine clientClose handles the clientâ€™s request to close the head.
It gathers a certiï¬cate for the current local state from the head protocol, and posts this certiï¬cate
onchain.
Routine chainInitial gets triggered on seeing the headâ€™sinitial transaction onchain. It veriï¬es
the parameters recorded in the initial transaction against the parameters gathered during the setup
phase described in Section 4: in particular, the aggregate multisignature key must match, and hMT
must be the Merkle-tree hash of the gathered veriï¬cation keys kver. If successful, the clientâ€™s UTxO
set is committed onchain.
Routine chainInitialTimeOut gets triggered once the initial commit period has expired. It
then either posts a collectCom transaction containing all committed UTxO setsâ€”in case that all
head members committed a UTxO setâ€”or an abort transaction otherwise.
Routine chainCollectCom gets triggered on seeing the headâ€™s collectCom transaction onchain.
It computes, into U0, the set of committed UTxOs, and initializes the head protocol.
Routines chainClose and chainContest get triggered by observing the headâ€™sclose and contest
transactions, respectively. They compare the latest onchain state Î·to the partyâ€™s own head state by
28

calling the head protocolâ€™s cont function to obtain a certiï¬cate Î¾ for a diï¬€erential onchain update
to represent the portions of the local state not yet considered by Î·. If necessary, a corresponding
contest transaction is posted onchain.
Routine chainClosedTimeOut gets triggered once the contestation period has expired. It then
posts a fanout transaction containing the ï¬nal UTxO set.
6.4 Security proof
This section proves that the head protocol presented in Section 6 satisï¬esConsistency, Conflict-
Free Liveness, Soundness, and Completeness. The proof proceeds by establishing several
invariants that facilitate proving these properties. Throughout the proof, the assumption is made
that at most nâˆ’1 head members are corrupted. Moreover, assume no signatures are forged and no
hashes collide; these events occur with negligible probability only. Consider the following random
variables:
â€¢SNj: the UTxO set corresponding to jth snapshot, i.e., the set that gets thejth multisignature
on snapshots (SN0 = U0);
â€¢ ËœTj: the transaction set corresponding to SN j, formally deï¬ned via ËœT0 = âˆ…, and ËœTj := ËœTjâˆ’1 â—¦
ReachT(T) where T is the set proposed in ( reqSn,j,T );
â€¢Cchain: keeps track of â€œtransactions on chainâ€ and is deï¬ned as follows: upon (successful) close
resp. contest with Î¾ for Î·, let Cchain â†ËœTsâˆªT, where (Â·,s,T ) is the output of Close(Kagg,Î·,Î¾ )
resp. Contest(Kagg,Î·,Î¾ );
â€¢SNcur,i: latest conï¬rmed snapshot as seen by party pi.
Lemma 1 (Consistency). The basic head protocol satisï¬es the Consistency property.
Proof. Observe that Ci âˆªCj âŠ† Ë†Si since no transaction can be conï¬rmed without every honest
party signing oï¬€ on it. Since parties do not sign conï¬‚icting transactions, U0 â—¦Ë†Si Ì¸= âŠ¥. Thus,
U0 â—¦(Ci âˆªCj) Ì¸= âŠ¥
Invariant 1. Consider a conï¬‚ict-free execution of the basic head protocol in presence of a network
adversary. Then, for any transaction tx input to the protocol via (new) the following holds with
respect to any parties pi and pj:
âˆ€t0 : L
(t0)
i â—¦tx Ì¸= âŠ¥â‡’âˆƒ T â‰¥t0âˆ€tâ‰¥T : L
(t)
j â—¦tx Ì¸= âŠ¥ âˆ¨tx âˆˆC
(t)
j
where the superscript Â·(t) indicates the time when the respective variable is evaluated.
Proof. Assume that party pi sees tx at time t0 and L
(t0)
i â—¦tx Ì¸= âŠ¥. By conï¬‚ict-freeness and full
delivery we get that, eventually, each partypj holds C
(t)
j âŠ‡C
(t0)
i . By this time t, either L
(t)
j â—¦tx Ì¸= âŠ¥
or tx âˆˆC
(t)
j (as we have conï¬‚ict-freeness, and C
(t)
j âŠ†N).
Lemma 2 (Conï¬‚ict-Free Liveness). The basic head protocol achieves Conflict-Free live-
ness.
29

Proof. We demonstrate that a transaction tx issued by a player pi will eventually be conï¬rmed by
every player pj. By conï¬‚ict-freeness, in ( new,tx) we have that Li â—¦tx Ì¸= âŠ¥.
Assume that tx /âˆˆCj, i.e., that pj has not seen tx conï¬rmed yet. As soon as pj enters (or gets
reactivated from the wait queue) (reqTx,tx) under the condition Ljâ—¦tx Ì¸= âŠ¥(eventually guaranteed
by Invariant 1), by conï¬‚ict-freeness, also Ë†Lj â—¦tx Ì¸= âŠ¥holds, and pj acknowledges the transaction.
Thus, every pj eventually acknowledges the transaction, and tx âˆˆâˆ©iâˆˆ[n]Ci.
Invariant 2. Consider an arbitrary uncorrupted party pi. Let ËœT be the set corresponding to
SNcur,i. Then, ËœTâˆªTi = Ci, where Ti is the set T of pi.
Proof. Observe that the invariant is trivially satisï¬ed at the onset of the protocolâ€™s execution.
Furthermore, each time a new transaction is conï¬rmed via confTx, both Ti and Ci grow by the
newly conï¬rmed transaction, while ËœT remains unchanged.
The only other time one of the sets ËœT, Ti, or Ci change is when a new snapshot is conï¬rmed
via confSn. In such a case, note that Ci stays the same while any transaction removed from Ti is
considered by the new snapshot and thus added to ËœT. Hence, the invariant is still satisï¬ed.
Invariant 3. ËœT0 âŠ†ËœT1 âŠ†ËœT2 âŠ†... .
Proof. Let pi be an honest party. It is easily seen that the set of transactions considered by a new
snapshot always includes the set considered by the previous snapshot since the set of transactions
T in a reqSn satisï¬es that SNcur,i â—¦ReachTi(T) Ì¸= âŠ¥, (this is implied by Invariant 2).
Invariant 4. Cchain grows monotonically (w.r.t. âŠ†).
Proof. Consider operation Contest(Kagg,Î·,Î¾ ) and let Î· = (UÎ·,sÎ·,TÎ·) and Î¾ = (U,s, ËœÏƒ,T ). Note
that before the operation Cchain = ËœTsÎ· âˆªTÎ·. Consider now the set Tâˆ— in the output ( Â·,Â·,Tâˆ—) of
Contest. Note that after the operation Cchain = ËœTs âˆªTâˆ—. Observe that:
â€¢Since sâ‰¥sÎ·, Invariant 3 implies that a transaction tx âˆˆËœTsÎ· is also in ËœTs.
â€¢If a transaction tx âˆˆTÎ· is not in Tâˆ—, then s > sÎ· and the transaction is consumed by the
snapshot with number s, i.e., tx âˆˆËœTs.
Hence, Cchain grows monotonically.
Invariant 5. For all iâˆˆHcont, Ci âŠ†Cchain.
Proof. Take any honest party pi and let Ëœs be the current snapshot number at pi, i.e., SNcur,i = ËœTËœs.
Recall that, by Invariant 2, Ci = ËœTËœsâˆªTi. Consider a close or contest operation by pi as well as the
output (U,s,T âˆ—) of Contest, and observe that after the operation Cchain = ËœTsâˆªTâˆ—. By Invariant 3,
ËœTËœs âŠ†ËœTs and, by a similar argument as in the proof of Invariant 4, if tx âˆˆTi is not in Tâˆ—, it must
be in ËœTs. Hence, Ci âŠ†Cchain. Furthermore, since Cchain grows monotonically (Invariant 4), the
invariant remains satisï¬ed.
Invariant 6. For all uncorrupted parties pi, â‹ƒ
jâˆˆ[n] Cj âŠ†Ë†Si.
Proof. Honest parties will only output (conf,tx) if there exists a valid multisignature for tx, which
implies that each honest party output ( seen,tx) just before they signed tx.
Invariant 7. For any j, ËœTj âŠ†â‹‚
iâˆˆHCi.
30

Proof. Only transactions that have been seen as conï¬rmed by all honest parties can ever be included
in a conï¬rmed snapshot.
Invariant 8. Cchain âŠ†â‹‚
iâˆˆHË†Si.
Proof. Let Î·= (U,s,T ). Observe that Cchain = ËœTs âˆªT. Consider a transaction tx âˆˆCchain.
â€¢If tx âˆˆËœTs, then tx âˆˆâ‹‚
iâˆˆHCi âŠ†â‹‚
iâˆˆHË†Si by Invariants 7 and 6.
â€¢If tx âˆˆT, then tx âˆˆâ‹‚
iâˆˆHË†Si since no transaction can be conï¬rmed without being seen by all
honest parties.
Lemma 3 (Soundness). The basic head protocol satisï¬es the Soundness property.
Proof. Let Î·= (U,s,T ) be the value of Î· just before applying Final(Î·,Uï¬nal). Clearly, the only set
Uï¬nal that will be accepted by Final is U0 â—¦( ËœTsâˆªT). By deï¬nition ËœTsâˆªT = Cchain. Soundness now
follows from Invariant 8.
Lemma 4 (Completeness). The basic head protocol satisï¬es the Completeness property.
Proof. Follows from Invariant 5 and an argument similar to that in the proof of Lemma 3.
7 Experimental Evaluation
We will now investigate the performance of the Hydra protocol in terms of both latency (transac-
tion settlement time) and throughput (rate of transaction processing, TPS), using timing-accurate
simulations. The simulations will demonstrate that Hydra is optimal in achieving fast transac-
tion settlement, and we employ baselines to systematically gain insight into the transaction-rate
performance characteristics of the protocol.
In order to determine how quickly transactions settle in Hydra, and at which rate they can be
processed, we have to consider the following factors:
Opening and closing of a head. This consists of creating and submitting the commit/decommit
transactions, and waiting until they are conï¬rmed to be in the chain.
The performance of the head protocol. Given a geographical distribution and CPU/network
capacity of the head nodes, how long does it take to exchange the messages that lead to transactions
and snapshots being conï¬rmed?
Limitations on in-ï¬‚ight transactions. When a player wants to send two transactions, where
one uses the change from the other, they have to defer sending the second transaction until they
have conï¬rmation for the ï¬rst. Furthermore, players may want to prevent an excessive number of
conï¬rmed, but not snapshotted transactions to keep decommits smaller. Together, this limits the
number of in-ï¬‚ight (submitted but not yet conï¬rmed) transactions that any one node can have.
31

The value at risk. To minimize this, players may wait for some transactions to be conï¬rmed
before sending more transactions, further limiting the number of in-ï¬‚ight transactions.
Since the time for opening and closing a head is largely dependent on the underlying layer-
one protocol and can be amortized over the headâ€™s lifetime, we do not cover this aspect in our
simulations. Furthermore, to simplify the simulations, we model the eï¬€ect of a ï¬nite UTxO by
directly limiting the number of in-ï¬‚ight transactions per node. Thus, we focus the simulations on
the execution of the head protocol, as speciï¬ed in Fig. 10.
7.1 Methodology
The experimental setup involves a ï¬xed set of nodes, with a speciï¬ed network bandwidth per
node and geographic location of each node that determines the network latency between each pair
of nodes. Each node submits transactions with a speciï¬ed transaction concurrency c: it sends
c transactions as fast as its resources allow, and then sends another one whenever one of the
transactions it sent previously gets conï¬rmed. This controls the number of inï¬‚ight transactions to
be c per node. Snapshots are performed regularly: nodes take turns to produce snapshots, and
whenever the current leader has at least one conï¬rmed transaction, it will create a snapshot with
all the conï¬rmed transactions it knows about.
In order to properly gauge the simulation results, we compare it to baseline scenarios that are
suï¬ƒciently simple to facilitate optimistic performance limits exactly. We derive those limits by
considering each sequence of events that has to happen in order for a number of transactions to
be conï¬rmed, and summing up the time for each event in those sequences. In particular, we have
three resources that potentially limit the transaction rate:
1. The CPU capacity at each node determines how fast transactions can be validated, and
signatures be created or veriï¬ed;
2. The inbound and outbound network bandwidth limits how many message bytes can be received
and sent by each node in a given time;
3. Each message between two nodes is delayed by the network latency between those nodes.
Depending on the conï¬guration of the system, the most utilized of these resources will limit the
transaction rate. This is an idealization: in a real execution of a protocol, contention eï¬€ects will
cause even the scarcest resource to be blocked and idle occasionally. We thus expect experimental
results to be bounded by the baselines, and interpret the diï¬€erence as the impact of contention
eï¬€ects. We consider the following baselines:
Universal Baseline: Full Trust. To quantify the price we pay for consensus in Hydra, we
compare our simulations with a scenario where we assume perfect trust between all participants;
i.e., we only distribute the knowledge on transactions, without trying to achieve consensus. In
this scenario, nodes submit transactions (after checking that they are valid). Other nodes just
acknowledge that they have seen them (without validating or signing them). We still consider the
eï¬€ect of having a ï¬nite transaction concurrency.
This baseline sets an upper limit for the transaction throughput of any protocol that distributes
and validates transactions in a distributed system. Furthermore, for any consensus protocol, we
should expect some additional overhead (which might or might not reduce the actual throughput
in diï¬€erent regions of the parameter space).
32

Hydra Unlimited. This scenario resembles the head protocol, but executed under ideal cir-
cumstances, ignoring contention eï¬€ects as described above. In contrast to a real execution of the
protocol, where the snapshot size is an emergent property depending on how fast transactions
are conï¬rmed, in the baseline, we can directly control how many transactions are contained in a
snapshot.
Sprites Unlimited. In order to compare to prior work, we also include a baseline according to
an optimal execution of the oï¬€-chain protocol from [31]. A deciding diï¬€erence to the head protocol
is that in Sprites, all nodes send their inputs to a leader, which collates them and collects signatures
for a whole batch of transactions. Compared to Hydra, this batching reduces the demand on CPU
time and number of messages, since less signatures have to be performed and shared, at the expense
of additional network roundtrips and higher network bandwidth usage at the current leader node,
which has to send the batch of all transactions to every other node.
infinite concurrency finite concurrency
0.1 1.0 10.0 0.1 1.0 10.0
100
1000
bandwidth [Mbit/s]
transaction throughput [tx/s]
Baseline Hydra Unlimited Sprites Unlimited Universal
Snapshot size 1 2 5 10 infinite
Figure 14: Example baselines scenarios, for ï¬nite and inï¬nite transactions concurrency.
We show examples of baselines in Fig. 14. We draw the diï¬€erent baseline scenarios using
diï¬€erent colours. For the Hydra Unlimited case, we have multiple lines, depending on the number
of transactions in each snapshot; the more transactions are bundled in any one snapshot, the lower
the overhead per transaction.
The left panel shows the limit of inï¬nite transaction concurrency. In that case, the network
roundtrip time can be perfectly amortised and is not a limiting factor. The resulting transaction
rate has a knee shape: it is linear in the network bandwidth as long as that is the limiting factor,
and turns constant once the limit from CPU time dominates. Comparing the Hydra Unlimited
and Universal baselines, we see that there is some diï¬€erence in the low bandwidth region, which
is due to the multisignatures being sent in Hydra. In the region where CPU time is relevant, the
diï¬€erence is more pronounced, due to the computational cost of multisignatures. Looking at the
Sprites Unlimited baseline, we see the tradeoï¬€ in batching transactions: the computational work is
signiï¬cantly reduced, by signing just a single large batch of transactions 6. This comes at the cost
of increasing the network traï¬ƒc at the leader node, which has to send every transaction to every
6In the limit of inï¬nite transaction concurrency, we take the batch size in Sprites to be unlimited as well.
33

other node. Note that in this picture, we only used a cluster of three nodes; for larger clusters, the
demand on the leader nodeâ€™s network bandwidth would be even higher.
To get a more realistic picture, let us turn to the right panel. Here, we have a ï¬nite transaction
concurrency, and the network roundtrip time is large enough to become the limiting factor (instead
of CPU time) once we have enough bandwidth. Comparing Hydra Unlimited to the Universal line,
we see that both ï¬‚atten at about 580 TPS. The limit from network latency is the same for both
baselines, since the number of roundtrips to conï¬rm a transaction is the same (the messages are
larger for Hydra Unlimited, but this only places a higher demand on the bandwidth). Interestingly,
if we make a snapshot for each single transaction, we are still limited by CPU power, but as soon
as we only make a snapshot every other transaction, the overhead from producing snapshots is
small enough to not matter, compared to the limit from network latency. In this picture, the
Sprites Unlimited baseline is well below the others. The demands on bandwidth â€“ particularly, the
network bandwidth of the leader node â€“ is much larger than for the other protocols, and bundling
transactions centrally before sending them to each node requires an additional roundtrip.
Note that devising an unlimited baseline for a given protocol, and comparing it to a universal
baseline or those of other protocols, is not only valuable for evaluating an implementation, but also
as a tool to predict possible performance during the protocol design phase.
7.2 Implementation
In the following, we will describe how we implemented the simulations for the head protocol. The
implementation is available at https://github.com/input-output-hk/hydra-sim .
We model the head nodes using concurrent threads which exchange the protocol messages from
Fig. 10 via channels. We use the io-sim library [2], which allows us to write concurrent code, and
then either execute it directly as threads in the Haskell runtime system, or run the same code in a
simulation of the runtime system. The latter yields an execution trace of the code very quickly, as
it delays a thread by just increasing a number representing the threadâ€™s clock, instead of actually
pausing the thread. As we describe below, the simulations make heavy use of thread delays, so this
allows us to perform simulations much more quickly. We can also manually insert trace points at
relevant points in the protocol (such as when a transaction is conï¬rmed). Measuring, for instance,
the conï¬rmation time for a message, can then be done by simply subtracting timestamps of the
events â€œtransaction is submittedâ€ ( new) and â€œtransaction is conï¬rmedâ€ ( confTx).
Cryptographic Operations. Instead of using real cryptographic functions for multisignatures,
we use mock functions that do not perform any calculations, but instead allow for a tunable delay
of the thread that is performing the operation.
Message Propagation. Before being sent across the network, each message has to be serialized
and pass the networking interface, which takes time linear in the message size. So the event of
a message being sent by a node does not correspond to a single point in time, but rather to a
time interval. We take that into account by modeling each message by its leading and trailing
edge. The time distance between leading and trailing edgeâ€”the serialization delay â€”of a message
is determined by its size and the bandwidth of the nodeâ€™s networking interface. We capture this with
a parameter S, giving the delay per byte. Furthermore, we take into account that the networking
interface can only start sending the next message after the trailing edge of the previous message
has been sent. When the network is suï¬ƒciently busy, this can be a point of contention.
34

We model the network by a delayGbetween each message edge leaving the sending node and its
arrival at the target node. The parameter G is determined by the distance between the two nodes
and is independent of message size. 7 We use real data measured between Amazon Web Services
data centers.
Once the leading edge of a message reaches the receiving node, we put its incoming networking
interface into a busy state, for a time given by the size of the message and the bandwidth of this
node. Finally, when the trailing edge is received, the message contents is placed into the local
inbox, so that the node can start acting on the message.
If we only consider a single message, this model will just lead to a delay of the whole message
determined by G, the message size, and S of the slower node. But once we have multiple messages
in the system, it also correctly accounts for the contention at the outgoing and incoming connection
points. The contention introduces variance, since messages may or may not have to wait at either
end of the network.
Simulation optimizations. We applied two reï¬nements that optimize the performance without
changing the security of the protocol. First, when submitting a new transaction via new, a node
will validate the transaction, and then send reqTx to every party, including itself. Every party,
upon receiving reqTx, will then validate the transaction again. For the sending node, this is not
necessary (it just validated the same transaction), so we skip the second validation on the same
node. Second, the speciï¬cation of the protocol states that handlers are executed strictly one after
the other. Avoiding concurrency in this way simpliï¬es the analysis of the protocol. But there is one
case where we can safely perform actions in parallel: upon receiving reqTx (and similarly reqSn),
a node will validate the transaction or snapshot against its local state, and, if appropriate, sign it
and reply. The action of signing does not access the state of the node, so we can safely perform it
concurrently with handling subsequent events.
These are fairly trivial changes, that any concrete implementation would apply, so we felt it
was appropriate to reï¬‚ect them in our simulations, as well as in the baselines.
7.3 Experimental Results
We performed experiments for three clusters with diï¬€erent geographic distributions of nodes: alocal
deployment of three nodes within the same AWS region, a continental deployment across multiple
AWS regions on the same continent (Ireland, London, and Frankfurt), and a global deployment
(Oregon, Frankfurt, and Tokyo). For each of those clusters, we measured the dependency of conï¬r-
mation time and transaction throughput on bandwidth and transaction concurrency, and compare
with the baselines described above. The numerical results depend on a number of parameters that
we set, representing the time that elementary operations within the protocol take. We use the
settings described below.
Transaction size. We use two representative transaction types: (1) simple UTxO transactions
with two inputs and two outputs, whose size is 265 bytes, and (2) script transactions containing
larger scripts of 10 kbytes. We use transaction references of 32 bytes. For each message, we allow
for a protocol-level overhead of 2 bytes.
7The messages in the Hydra protocol are small enough to ignore TCP window eï¬€ects that would introduce a
dependency on the message size.
35

â—
â—
â—
â—
â—
â— â— â—
â—
â—
â—
â—
â— â— â— â—
â—
â— â— â— â— â— â— â—
â—
â—
â—
â—
â—
â— â— â—
â—
â—
â—
â—
â—
â— â— â—
â—
â—
â— â— â— â— â— â—
â—
â—
â—
â—
â—
â— â— â—
â—
â—
â—
â—
â—
â— â— â—
â—
â—
â—
â— â— â— â— â—
Concurrency 1 Concurrency 5 Concurrency 10
LocalContinentalGlobal
0.1 1.0 10.00.1 1.0 10.00.1 1.0 10.0
100
1000
100
1000
10
100
bandwidth [Mbit/s]
transaction throughput [tx/s]
Baseline Hydra Unlimited Sprites Unlimited Universal
Snapshot size 1 2 infinite
Figure 15: Transaction rates for the Hydra head protocol, compared with the baseline scenarios.
Simple UTxO transactions with 2 inputs and 2 outputs.
Transaction validation time. This is the CPU time that a single node will expend in order to
check the validity of a transaction. We use conservative values here: 0.4 ms for simple transactions,
and 3 ms for script transactions.
Time for multisignature operations. We performed benchmarks for the multisignature scheme [11]
resulting in the following estimates: 0 .15 ms for MS-Sign, 0 .01 ms for MS-ASig, and 0 .85 ms for
MS-AVerify.
Transaction throughput. Figs. 15 and 16 display results for ordinary UTxO and script trans-
actions, respectively. The diï¬€erent rows correspond to the diï¬€erent geographical setups of the
clusters, while the columns diï¬€er in transaction concurrency.
As expected, the Universal baseline consistently gives the highest transaction rate. For Hydra
Unlimited, we see three baselines, for diï¬€erent snapshot sizes (depicted by dotted, dashed, and
solid lines). In some cases, they coincide. Those are the conï¬gurations where we are limited by
the network latency: performing snapshots increases the demand on CPU time and bandwidth (for
36

â—
â—
â—
â—
â—
â—
â—
â—
â— â—
â—
â— â— â— â—
â—
â—
â—
â— â—
â—
â—
â—
â— â—
â—
â— â— â— â—
â—
â—
â— â— â—
â—
â—
â— â— â—
â—
â—
â— â— â—
Concurrency 1 Concurrency 5 Concurrency 10
LocalContinentalGlobal
10 10 10
100
100
10
100
bandwidth [Mbit/s]
transaction throughput [tx/s]
Baseline Hydra Unlimited Sprites Unlimited Universal
Snapshot size 1 2 infinite
Figure 16: Transaction rates for the Hydra head protocol, compared with the baseline scenarios.
Script transactions.
the additional signatures and messages), but it does not increase the number of sequential network
roundtrips that have to be performed to conï¬rm transactions (the messages for snapshots and for
transactions propagate through the network concurrently).
Comparing the Universal and Hydra Unlimited baselines, we see that they are identical whenever
the transaction rate is limited by the network latency. That can be explained since the diï¬€erence
between the two baselines diï¬€er only in their demand for CPU time (for creating and validating
signatures) and bandwidth (for sending signatures). Note that for script transactions (Fig. 16), the
demands on CPU are higher anyway, so that the additional cost for the multisignatures generally
has a much lower impact on the transaction rate.
Looking at the Sprites Unlimited baseline, we observe the eï¬€ect of batching via a central leader:
the leader needs to send all transactions to every other node, and so its networking interface is
frequently a bottleneck. Also, we see the additional roundtrip between the leader and every other
node reducing the TPS whenever the network latency is the limiting resource. But when we have
enough concurrency to form large batches, and get to the region where we are limited by CPU
time, the savings by signing batches instead of individual transactions become apparent, and the
37

Concurrency 1 Concurrency 5 Concurrency 10
0.1 1.0 10.00.1 1.0 10.00.1 1.0 10.0
0.01
0.10
1.00
bandwidth [Mbits/s]
transaction confirmation time [s]
Node Location
â—
Frankfurt
Figure 17: Conï¬rmation times for simple UTxO transactions, in a cluster located in one AWS
region. From panel to panel, we increase the transaction concurrency. The theoretically minimal
conï¬rmation time is represented by a dashed line.
Sprite baseline nearly reaches the Universal one.
Comparing the experimental results with the Hydra Unlimited baseline, we see that in most
cases, the simulation of the protocol approximates the optimal curve quite well. We only get
sizeable diï¬€erences for low concurrency and insuï¬ƒcient bandwidth.
Regarding snapshots, the ï¬gures reveal that performing snapshots has a negligible impact on
the transaction rate: apart from the regions where bandwidth is the limit, the baselines for diï¬€erent
snapshot sizes only diï¬€er when we are CPU bound, which requires enough transaction concurrency
to amortize the network latency. But for large concurrency, we also get large snapshots, so the
overhead from snapshots per transaction is small.
Transaction conï¬rmation times. One aspect where Hydra really shines is fast settlement:
as soon as all parties have signed a transaction, and the sending node has aggregated a valid
multisignature, this multisignature provides a guarantee that the transaction can be included into
the ledger of the layer-one system. We can derive a minimal conï¬rmation time by adding up the
times for validating a transaction two times (once at the issuing node, once at every other node),
sending the reqTx and ackTx messages across the longest path in the network, and creating and
validating the aggregate signature.
Fig. 17 illustrates the conditions under which we achieve minimal conï¬rmation time. In the
ï¬rst panel, we have a transaction concurrency of one. We see that, with enough bandwidth, we get
very close to the minimal validation time, indicated by the line. In the other panels, we increase
the concurrency. While this increases the total transaction throughput by sending transactions in
parallel, individual transactions are more likely to be slowed down by congestion in the networking
interfaces. Hence, conï¬rmation time and its spread increase.
In clusters across diï¬€erent regions, the conï¬rmation time generally depends on which node
sent the transaction. For example, in Fig. 18, we see that the transactions from Oregon tend to
get conï¬rmed faster than those from Frankfurt or Tokyo. This is because conï¬rmation requires a
roundtrip to the farthest peer, and Frankfurt and Tokyo are farther away from one another than
38

Concurrency 1 Concurrency 5 Concurrency 10
10 10 10
0.1
1.0
bandwidth [Mbits/s]
transaction confirmation time [s]
Node Location
â— â—
Frankfurt/Tokyo Oregon
Figure 18: As Fig. 17, but for script transactions in a cluster spanning the AWS regions Oregon,
Frankfurt, and Tokyo. Here, the minimal conï¬rmation time depends on which node is sending
the transaction, so we have two optimal lines.
either of them is from Oregon.
We see that even for script transactions and a globally distributed network, we consistently
achieve settlement well below half a second if we provide enough bandwidth.
Larger clusters. In addition to three node clusters, we have also evaluated how the results
depend on cluster size by running simulations with clusters of up to 100 nodes (located in the same
AWS region):
â€¢The transaction rates of a larger cluster are close to those for a three-node cluster. This is
due to the fact that the amount of computation per node per transaction does not depend
on the number of participants 8.
â€¢The bandwidth needed at each node to reach the maximal transaction rate does depend on
the cluster size. This is not surprising, since each node needs to communicate with more
peers.
â€¢For the same reason, the conï¬rmation time of transactions increases with the cluster size.
Note that these simulations still use a communication pattern where everyone sends messages to
everyone, which is not optimal for large clusters. Instead, we ought to construct a graph to broadcast
messages, keeping the number of peers for direct communication small for each participant. An
advantage of the Hydra approach is that we can easily have diï¬€erent versions of the head protocol,
or diï¬€erent implementations of the same head protocol, optimized for diï¬€erent cluster sizes.
8Note that aggregating signatures and verifying an aggregate signature do depend on the number of participants.
However, this does not impact the transaction rates in our simulations, for three reasons: i) we assume that we
aggregate the veriï¬cation keys once at the beginning of the head protocol, and only perform veriï¬cation against
the already computed aggregate veriï¬cation key during the protocol, ii) even for 100 participants, combining the
signatures is quicker than producing a single signature, iii) combining signatures is performed concurrently with the
rest of the protocol (see Section 7.2).
39

7.4 Discussion
Due to the way that consensus is achieved by getting conï¬rmations from every participant, we
consistently achieve subsecond settlement, even for globally distributed heads. When we allocate
suï¬ƒcient networking resources, and choose a low concurrency, we do get optimal conï¬rmation
times.
Regarding transaction throughput, more importantly than raw numbers are the comparisons
with the theoretical limits from the baselines scenarios:
â€¢We saw that we do not pay a signiï¬cant cost for creating snapshots, neither in terms of
transaction throughput, nor in terms of conï¬rmation time. This is a crucial point: compared
to other state channel protocols, Hydra utilizes the UTxO parallelism to avoid having to
sequentialize transactions. Snapshots are necessary for that approach, since otherwise, the
decommit transactions would become unwieldy. Seeing that snapshots do not slow down the
protocol in any signiï¬cant way thus validates the design of Hydra.
â€¢Comparing the Universal baseline, Hydra Unlimited, and the experimental results, we see
that we approach the theoretical limits in regions where we can expect to. When the cost
of achieving consensus via multisignatures is dominated by network roundtrip times and
transaction validation, we get close to the Universal scenario. We see sizeable deviations
from Hydra Unlimited only when we have low transaction concurrency and bandwidth.
Besides demonstrating Hydraâ€™s capability to perform eï¬ƒciently, the simulations also allow op-
erators to get a handle on the network bandwidth they should provide in order not to impact the
head performance. They also show that there is a tradeoï¬€ between total transaction throughput
and individual transaction settlement time when increasing concurrency.
7.5 A note on transaction throughput
We can see that the maximal transaction throughput rates achieved in the experiments (for simple
transactions) is at around 800 transactions per second. This limit is a consequence of the assumed
transaction validation time of 0 .4 ms, and the veriï¬cation of a multisignature, for which we allow
0.85 ms. Consequently, each transaction requires 1 .25 ms of CPU time at each node 9, so we are
limited to 800 transactions per second.
There are straightforward ways to increase the throughput in a live system:
â€¢The most eï¬ƒcient way to scale a system with Hydra is to run multiple parallel heads. By
running n heads, we achieve n times the throughput of a single head.
Note that for many use cases, a single head will only be used by participants in a constrained
geographic region, allowing an eï¬ƒcient local or continental setup.
â€¢For increasing the throughput of a single head, one can invest in more capable hardware to
speed up transaction validation and signature veriï¬cation.
â€¢In the experiments, every node processes transactions sequentially. But it is possible to
perform large parts of the transaction validation, and also all of the signature veriï¬cation, in
parallel for multiple transactions, using multiple cores on each node. This optimization can
also improve the throughput of a single head.
9Note that as described in Section 7.2, we create the multisignature in a dedicated thread.
40

8 Acknowledgments
Aggelos Kiayias was supported in part by EU Project No.780477, PRIVILEDGE. We want to thank
Duncan Coutts and Neil Davies for advice on technical aspects of the simulations, and Neil Davies
for providing the measurements of round trip times between diï¬€erent AWS regions.
References
[1] Extended UTXO-2 model. https://github.com/hydra-supplementary-material/eutxo-
spec/blob/master/extended-utxo-specification.pdf.
[2] The io-sym library. https://github.com/input-output-hk/ouroboros-network/tree/
master/io-sim, https://github.com/input-output-hk/ouroboros-network/tree/
master/io-sim-classes.
[3] The Connext Network. https://docs.connext.network/en/latest/background/
architecture.html.
[4] John Adler. The whyâ€™s of optimistic rollup. https://medium.com/@adlerjohn/the-why-s-
of-optimistic-rollup-7c6a22cbb61a , November 2019.
[5] Ian Allison. Ethereumâ€™s Vitalik Buterin explains how state channels address privacy and
scalability. International Business Times , 2017.
[6] Nicola Atzei, Massimo Bartoletti, Stefano Lande, and Roberto Zunino. A formal model of
Bitcoin transactions. In Financial Cryptography and Data Security - 22nd International Con-
ference, FC 2018, Nieuwpoort, CuraÂ¸ cao, February 26 - March 2, 2018, Revised Selected Papers,
pages 541â€“560, 2018.
[7] Adam Back, Matt Corallo, Luke Dashjr, Mark Friedenbach, Gregory Maxwell, Andrew Miller,
Andrew Poelstra, Jorge TimÂ´ on, and Pieter Wuille. Enabling blockchain innovations with
pegged sidechains, 2014.
[8] Mihir Bellare and Gregory Neven. Multi-signatures in the plain public-key model and a general
forking lemma. In Ari Juels, Rebecca N. Wright, and Sabrina De Capitani di Vimercati, editors,
ACM CCS 2006 , pages 390â€“399. ACM Press, October / November 2006.
[9] Bitcoin Wiki. Payment channels. Wiki article, accessed 2019-11-06.
[10] Guy E. Blelloch. Programming parallel algorithms. Communications of the ACM , 39:85â€“97,
1996.
[11] Alexandra Boldyreva. Threshold signatures, multisignatures and blind signatures based on
the gap-Diï¬ƒe-Hellman-group signature scheme. In Yvo Desmedt, editor, PKC 2003, volume
2567 of LNCS, pages 31â€“46. Springer, Heidelberg, January 2003.
[12] Dan Boneh, Manu Drijvers, and Gregory Neven. Compact multi-signatures for smaller
blockchains. In Thomas Peyrin and Steven Galbraith, editors, ASIACRYPT 2018, Part II ,
volume 11273 of LNCS, pages 435â€“464. Springer, Heidelberg, December 2018.
41

[13] Manuel M. T. Chakravarty, James Chapman, Kenneth MacKenzie, Orestis Melkonian,
Michael Peyton Jones, and Philip Wadler. The extended UTxO model. In 4th Workshop
on Trusted Smart Contracts , 2020. http://fc20.ifca.ai/wtsc/WTSC2020/WTSC20_paper_
25.pdf.
[14] Manuel M. T. Chakravarty, Roman Kireev, Kenneth MacKenzie, Vanessa McHale, Jann
MÂ¨ uller, Alexander Nemish, Chad Nester, Michael Peyton Jones, Simon Thompson, Re-
becca Valentine, and Philip Wadler. Functional blockchain contracts. https://iohk.io/
en/research/library/papers/functional-blockchain-contracts/, May 2019.
[15] Jeï¬€ Coleman, Liam Horne, and Li Xuanji. Counterfactual: Generalized state channels, 2018.
[16] Christian Decker and Roger Wattenhofer. A fast and scalable payment network with bit-
coin duplex micropayment channels. In Symposium on Self-Stabilizing Systems , pages 3â€“18.
Springer, 2015.
[17] Ergo Developers. Ergo: A resilient platform for contractual money. https://ergoplatform.
org/docs/whitepaper.pdf, May 2019.
[18] Stefan Dziembowski, Lisa Eckey, Sebastian Faust, Julia Hesse, and Kristina HostÂ´ akovÂ´ a. Multi-
party virtual state channels. In Annual International Conference on the Theory and Applica-
tions of Cryptographic Techniques, pages 625â€“656. Springer, 2019.
[19] Stefan Dziembowski, Lisa Eckey, Sebastian Faust, and Daniel Malinowski. Perun: Virtual
payment hubs over cryptocurrencies. In 2019 IEEE Symposium on Security and Privacy (SP) ,
pages 106â€“123. IEEE, 2019.
[20] Stefan Dziembowski, Grzegorz FabiaÂ´ nski, Sebastian Faust, and Siavash Riahi. Lower bounds
for oï¬€-chain protocols: Exploring the limits of plasma. Cryptology ePrint Archive, Report
2020/175, 2020. https://eprint.iacr.org/2020/175.
[21] Stefan Dziembowski, Sebastian Faust, and Kristina HostÂ´ akovÂ´ a. General state channel net-
works. In Proceedings of the 2018 ACM SIGSAC Conference on Computer and Communica-
tions Security, pages 949â€“966. ACM, 2018.
[22] Ethereum. Patricia tree, 2019. Github Repository.
[23] Matthias Fitzi, Daniel Gottesman, Martin Hirt, Thomas Holenstein, and Adam Smith. De-
tectable byzantine agreement secure against faulty majorities. In Aleta Ricciardi, editor, 21st
ACM PODC, pages 118â€“126. ACM, July 2002.
[24] P. GaË‡ zi, A. Kiayias, and D. Zindros. Proof-of-stake sidechains. In2019 2019 IEEE Symposium
on Security and Privacy (SP) , pages 677â€“694, Los Alamitos, CA, USA, may 2019. IEEE
Computer Society.
[25] Kazuharu Itakura and Katsuhiro Nakamura. A public-key cryptosystem suitable for digital
multisignatures. NEC Research & Development , (71):1â€“8, 1983.
[26] Aggelos Kiayias and Dionysis Zindros. Proof-of-work sidechains. IACR Cryptology ePrint
Archive, 2018:1048, 2018.
42

[27] Georgios Konstantopoulos. Plasma cash: Towards more eï¬ƒcient plasma constructions, 2019.
[28] Jeremy Longley and Oliver Hopton. Funfair technology roadmap and discussion, 2017.
[29] ScaleSphere Foundation Ltd. Celer network: Bring internet scale to every blockchain, 2018.
[30] Silvio Micali, Kazuo Ohta, and Leonid Reyzin. Accountable-subgroup multisignatures: Ex-
tended abstract. In Michael K. Reiter and Pierangela Samarati, editors, ACM CCS 2001 ,
pages 245â€“254. ACM Press, November 2001.
[31] Andrew Miller, Iddo Bentov, Surya Bakshi, Ranjit Kumaresan, and Patrick McCorry. Sprites
and state channels: Payment networks that go faster than lightning. In International Confer-
ence on Financial Cryptography and Data Security , pages 508â€“526. Springer, 2019.
[32] J. Poon and V. Buterin. Plasma: Scalable autonomous smart contracts. http://plasma.io/
plasma.pdf.
[33] Joseph Poon and Thaddeus Dryja. The bitcoin lightning network: Scalable oï¬€-chain instant
payments, 2016.
[34] Joachim Zahnentferner. An abstract model of UTxO-based cryptocurrencies with scripts.
IACR Cryptology ePrint Archive , 2018:469, 2018.
43

A Security of Multisignature Schemes
For convenience, our deï¬nition of a multisignature scheme given in Section 2 diï¬€ers from the stan-
dard one in e.g. [8] by assuming the existence of separate algorithms MS-Sign and MS-ASig and
postulating that the way to produce a multisignature is that each party creates a local signature via
MS-Sign and these are then exchanged and combined using MS-ASig. This is no important devia-
tion, as typical modern multisignature schemes (including the one we use in our simulations [11])
satisfy this pattern. Below we present a standard deï¬nition of multisignature security from [8, 12],
tailored to this special case.
A secure multisignature scheme needs to satisfy two properties: completeness and unforgeability.
Completeness. For any n, Î  â†MS-Setup(1k) and ( vki,ski) â†MS-KG(Î ) for i = 1,...,n , for
any message m if we have Ïƒi â†MS-Sign(Î ,ski,m), ËœÏƒ â†MS-ASig(Î ,m, {vki}n
i=1,{Ïƒi}n
i=1), and
avk â†MS-AVK(Î ,{vki}n
i=1), then MS-Verify(Î ,ËœÏƒ,m, avk) = true.
Unforgeability. This property is deï¬ned by a three-stage game:
1. Setup. The challenger runs Î  â†MS-Setup(1k), generates the challenge key pair ( vkâˆ—,skâˆ—) â†
MS-KG(Î ) and runs the adversary A(Î ,vkâˆ—).
2. Signing queries. Ais allowed to make signing queries on any message m, i.e., Ahas access
to the signing oracle MS-Sign(Î ,skâˆ—,Â·).
3. Output. Finally, Aoutputs a multisignature forgery ËœÏƒâˆ—, a message mâˆ—and a set of veriï¬cation
keys Vâˆ—. Awins if vkâˆ—âˆˆVâˆ—, Amade no signing queries on mâˆ—, and
MS-Verify(Î ,MS-AVK(Î ,Vâˆ—),mâˆ—,ËœÏƒâˆ—) = true .
We say that Ais a ( Ï„,q,Îµ )-forger for a multisignature scheme MS = (MS-Setup,MS-KG,MS-AVK,
MS-Sign,MS-ASig,MS-Verify) if it runs in time Ï„, makes qsigning queries, and wins the above game
with probability at least Îµ. MS is (Ï„,q,Îµ )-unforgeable if no ( Ï„,q,Îµ )-forger exists.
B Simple Head Protocol with Conï¬‚ict Resolution
This section explains the diï¬€erences between the basic head protocol from Section 6 and the head
protocol with conï¬‚ict resolution; it also contains a corresponding security proof.
B.1 Description of the protocol
The head protocol with conï¬‚ict resolution (CR) works much like the basic head protocol, except
that snapshots are also used to resolve conï¬‚icts among transactions. In the basic protocol, since
parties do not sign conï¬‚icting transactions, such conï¬‚icts would have to be settled on the mainchain
even if no head members are corrupted.
In the CR version of the head protocol (cf. Figure 19), each head member pi additionally
maintains a set Ë†Rof known transactions that conï¬‚ict with a set TR âŠ† Ë†T of transactions already
signed by pi. In the (likely) event that transactions in Ë†Rhave also been signed oï¬€ on by at least
one party, no transaction in TR âˆª Ë†Rcan ever become conï¬rmed with the basic conï¬rmation ï¬‚ow
44

Simpliï¬ed Hydra Head Protocol With Conï¬‚ict Resolution
on(init,i,Kver,Ksig,U0)from clientVâ†Kveravkâ†MS-AVK(V)skâ†Ksig
Ë†s,sâ†0Ë†U,Uâ†snObj(0,U0,âˆ…)Ë†L,Lâ†U0Ë†T,T,Ë†Râ†âˆ…
on(new,tx)from clientrequirevalid-tx(tx) andLâ—¦txÌ¸=âŠ¥multicast(reqTx,tx)
on(newSn)forpi
requireleader(s+ 1) =iandË†U=U
Tâ†(maxTxos(T))â†“(h)
TRâ†(conï¬‚ict-tx(Ë†T,Ë†R))â†“(h)
Râ†Ë†Râ†“(h)
multicast(reqSn,s+ 1,T,TR,R)
on(close)from client
return(U.U,U.s,U.ËœÏƒ,Tâ†“(tx,ËœÏƒ))
on(cont,Î·)from client(UÎ·,sÎ·,TÎ·)â†Î·ifsâ‰¤sUâ†UÎ·
sâ†sÎ·
ËœÏƒâ†ÎµelseUâ†Usâ†sËœÏƒâ†U.ËœÏƒ
Tâ€²â†applicable(U,Tâ†“(tx)âˆªTÎ·)\TÎ·
ifU=UÎ·
Uâ†Îµ
return(U,s,ËœÏƒ,{tâˆˆTâ†“(tx,ËœÏƒ)|t.txâˆˆTâ€²})
on(reqTx,tx)frompj
requirevalid-tx(tx)âˆ§tx/âˆˆË†T âˆªË†RifË†Lâ—¦tx =âŠ¥Ë†Râ†Ë†Râˆª{txObj(j,tx)}elsehâ†H(tx)Ë†T[h]â†txObj(j,tx)Ë†Lâ†Ë†Lâ—¦txwaitLâ—¦txÌ¸=âŠ¥output(seen,Ë†T[h])Ïƒiâ†MS-Sign(sk,h)send(ackTx,h,Ïƒi) topj
on(ackTx,h,Ïƒj)frompj
requireË†T[h].i=irequireË†T[h].S[j] =ÎµË†T[h].S[j]â†Ïƒj
ifâˆ€k:Ë†T[h].S[k]Ì¸=ÎµËœÏƒâ†MS-ASig(h,V,Ë†T[h].S)ifËœÏƒÌ¸=âŠ¥multicast(confTx,h,ËœÏƒ)
on(confTx,h,ËœÏƒ)frompj
txâ†Ë†T[h].txifMS-Verify(avk,h,ËœÏƒ)ifLâ—¦txÌ¸=âŠ¥âˆ§Ë†Uâ—¦txÌ¸=âŠ¥Lâ†Lâ—¦txË†T[h].ËœÏƒâ†ËœÏƒT[h]â†Ë†T[h]Ë†T â†Ë†T \Ë†T[h]output(conf,tx)
on(reqSn,s,T,TR,R)frompj
requires=s+ 1 andleader(s) =j
waits= Ë†sandTâŠ†Tâ†“(h)andTRâˆªRâŠ†(Ë†T âˆªË†R)â†“(h)
ËœTRâ†(Ë†T âˆªË†R)[TR]ËœRâ†(Ë†T âˆªË†R)[R]requireâˆ€txâˆˆËœTR:conï¬‚ict(ËœRâˆª{tx})requireâˆ€txâˆˆËœR:conï¬‚ict(ËœTRâˆª{tx})requireÂ¬conï¬‚ict(T âˆªËœTR)Ë†sâ†Ë†s+ 1forallhâˆˆË†Râ†“(h)âˆ©TRdooutput(seen,Ë†R[h])Ë†Râ†Ë†R\{txâˆˆË†T âˆªË†R|conï¬‚ict(tx,ËœTR)}Ë†T â†(Ë†T âˆªËœTR)\ËœRË†Uâ†snObj(Ë†s,U.U,T,TR)Ë†Lâ†Lâ—¦Ë†TÏƒiâ†MS-Sign(sk,Ë†U.hâˆ¥Ë†s)send(ackSn,Ë†s,Ïƒi) topj
on(ackSn,s,Ïƒj)frompj
requires= Ë†sandleader(s) =irequireË†U.S[j] =ÎµË†U.S[j]â†Ïƒj
ifâˆ€k:Ë†U.S[k]Ì¸=ÎµËœÏƒâ†MS-ASig(Ë†U.hâˆ¥s,V,Ë†U.S)ifËœÏƒÌ¸=âŠ¥multicast(confSn,s,ËœÏƒ)
on(confSn,s,ËœÏƒ)frompj
requires= Ë†sÌ¸=sifMS-Verify(avk,Ë†U.hâˆ¥Ë†s,ËœÏƒ)sâ†sË†U.ËœÏƒâ†ËœÏƒUâ†Ë†UforallhâˆˆU.TRdooutput(conf,(Ë†T âˆªË†R)[h])Lâ†Lâ—¦U.(TR)â†“(tx)
T â†T \ReachT(U.T)Ë†T â†Ë†T \U.TR
Figure 19: Head-protocol machine with conï¬‚ict resolution from the perspective of party pi.
based on multisignatures on transactions. To avoid this, whenever pi is snapshot leader, pi also
includes the sets of (hashes of) the transactions in TR and Râ† Ë†Rin a reqSn message (in addition
to the set T of already conï¬rmed transactions not included in any snapshot so far).
45

The remainder of the snapshot process is changed (as compared to the basic protocol) to ensure
that transactions in TR become conï¬rmed and transactions in Rare discarded. Speciï¬cally, a party
pi receiving a snapshot request reqSn ï¬rst waits until he learns all transactions referenced by the
sets TR and R received from the snapshot leader pj. (Observe that parties may have diï¬€erent
local sets Ë†T and Ë†R.) It then ensures that these sets are legitimate in that transactions in TR and
R indeed conï¬‚ict. Furthermore, it checks that transactions in TR do not conï¬‚ict with already
conï¬rmed transactions. If these checks pass, pi updates his sets Ë†T and Ë†Rto match those of the
snapshot leader pj. Function snObjâ€”in addition to the snapshot number, the UTxO set of the
previous snapshot, and the set T of maximal conï¬rmed transactionsâ€”now also takes as input the
set TR, and computes the UTxO set for the new snapshot Ë†Uas10
Ë†U.U â†U.U â—¦(ReachT(T) âˆªTR) .
Party pi ï¬nally signs H( Ë†U.U)âˆ¥Ë†s and sends the signature to the snapshot leader pj.
The rest of the snapshot process is very similar to the one in the basic protocol, except that in
confSn, (conf,tx) is output for transactions referenced by TR; these transactions are also removed
form the set Ë†T and the execution of reqTx is stopped and discarded for all transactions conï¬‚icting
with TR (such executions would be stuck in the wait command forever).
Observe that if at least one party is corrupted, the CR version of the head protocol now allows
the adversary to create multisigned transactions that conï¬‚ict with transactions conï¬rmed via the
snapshot process. This occurs if an honest party pi signs a snapshot that includes in the set TR
(sent by the snapshot leader) a transaction tx â€² in piâ€™s Ë†Rset: tx â€² being in Ë†Rmeans that pi has
already signed oï¬€ on a transaction tx in conï¬‚ict with tx â€². This results in a race condition between
the following two events:
â€¢pi receives a multisignature of tx via confTx;
â€¢pi signs oï¬€ on the snapshot that includes tx â€².
Crucially, only one of these events must occur. To that end, in reqSn a party checks that the set
TR does not conï¬‚ict with already conï¬rmed transactions (in the fourth require statement) and
that (conf,tx) is only output before pi signs the new snapshot (the check Ë†Uâ—¦ tx Ì¸= âŠ¥), i.e., if the
multisignature for tx arrives after the snapshot was signed, pi will simply drop it. Note that, in
case the above require fails for an honest party, snapshot production will stall as this snapshot
will never get conï¬rmed. However, in this case, the head can be safely closed since the snapshot
leader is corrupted.
B.2 Security proof
Consider the random variables deï¬ned at the beginning of Section 6.4. The proof proceeds along
similar lines as that of the basic protocol with the additional consideration of the fact that diï¬€erent
(honest) parties might sign oï¬€ transactions that conï¬‚ict with each other due to race conditions.
Lemma 5 (Consistency). The head protocol with CR satisï¬es the Consistency property.
10Recall that ReachT (T) returns the transactions in T reachable (by following output references) from the trans-
actions (with hashes) in T.
46

Proof. Consider an arbitrary uncorrupted party pi and a transaction tx for which pi outputs
(conf,tx). Assume there exists a party pj such that tx conï¬‚icts with some tx â€²âˆˆCj. Consider the
following cases:
â€¢Both tx and txâ€²were conï¬rmed via confTx. This cannot happen since that would imply that
honest parties signed reqTx messages for conï¬‚icting transactions.
â€¢Transaction tx was conï¬rmed via confTx and txâ€² via confSn. This cannot happen since it
would imply that pi signed a snapshot conï¬‚icting with tx â€²before outputting (conf,tx).
â€¢Both tx and txâ€²were conï¬rmed via confSn. This cannot happen since transactions conï¬rmed
via snapshots are checked for conï¬‚icts by a party before it signs the snapshot.
Invariant 9 (Snapshot-leader fault detection). If for any honest party, during (confTx), it
holds that Lâ—¦tx = âŠ¥or Ë†Uâ—¦ tx = âŠ¥then there is a faulty party.
Proof. If Lâ—¦ tx = âŠ¥then there must have been a snapshot leader who signed tx but resolved
a conï¬‚ict of tx in favor of another transactionâ€”against tx against the rule to prefer the signed
transaction. This behavior is faulty. The case Ë†Uâ—¦ tx = âŠ¥implies faulty behavior of the current
snapshot leader in the same way.
Invariant 10 (Eventual mutual C inclusion). Consider the presence of a network adversary.
Then, given Ci of party pi at any point in time, any party pj will eventually have Cj âŠ‡Ci.
Proof. Any transaction added to Ci during (confSn) will eventually be (or has been) added to Cj
as the only guard in ( confSn) relates to signature veriï¬cation.
Any transaction tx added toCi during (confTx) will eventually trigger (or has already triggered)
a respective ( confTx) for party pj, and by the assumption that all parties are honest and by
Invariant 9, tx âˆˆCj holds eventually.
In the following lemma we establish that, under control of a network adversary, new snapshots
continue being produced and conï¬rmed. This property is not only required for the proof of liveness
but also demonstrates that old transactions can eventually be deleted.
Lemma 6 (Snapshot Liveness). Under presence of a network adversary, for any s >0, a
snapshot with snapshot number s eventually gets conï¬rmed.
Proof. We have to demonstrate that for any snapshot number s and party pi, the following condi-
tions eventually hold when pi enters the respective event-handler instance ( reqSn,s,T,T R,R):
(1) T âŠ†T
â†“(h)
âˆ§ TR âˆªRâŠ†( Ë†T âˆªË†R)â†“(h)
(2) âˆ€tx âˆˆËœTR : conï¬‚ict( ËœRâˆª{tx}) âˆ§ âˆ€tx âˆˆËœR: conï¬‚ict( ËœTR âˆª{tx})
(3) Â¬conï¬‚ict(T âˆªËœTR)
47

On (1), T âŠ†T
â†“(h)
part. As the snapshot leader chooses T âŠ†T
â†“(h)
in (newSn) (and T âŠ†C), by
Invariant 10, every party pi will eventually observe T âŠ†T
â†“(h)
i âŠ†Ci.
On (1), TR âˆªRâŠ†( Ë†Tâˆª Ë†R)â†“(h) part. After entering ( newSn), all transactions in tx âˆˆTR âˆªR will
eventually have triggered (reqTx,tx) implying that TR âˆªRâŠ†( Ë†T âˆªË†R)â†“(h).
On (2). As shown above, we have that TR âˆªRâŠ†( Ë†T âˆªË†R)â†“(h). Once that condition is satisï¬ed
then also âˆ€tx âˆˆËœTR : conï¬‚ict( ËœRâˆª{tx}) âˆ§ âˆ€tx âˆˆ ËœR: conï¬‚ict( ËœTR âˆª{tx}) by honesty of the snapshot
leader and the way he has to pick TR and R during (newSn).
On (3). If conï¬‚ict(Tâˆª ËœTR) then the snapshot leader resolved a conï¬‚ict in favor of a transaction
tx âˆˆËœTR such that conï¬‚ict(Tâˆª{ tx}) implying that he also signed a transaction that conï¬‚icts tx, in
contradiction to the assumption that he is honest.
Invariant 11 (Local transaction liveness). Under presence of a network adversary, con-
sider any transaction tx issued by a party pi via (new). Then, eventually, either tx âˆˆ Ci, or
conï¬‚ict(tx,Ci).
Proof. After (new,tx), pi will eventually process tx by ( reqTx,tx), and tx âˆˆ Ë†T
Â·
âˆª Ë†R(symmetric
diï¬€erence). Assume that never tx âˆˆCi which, by assumption that all parties are honest and by
Invariant 9, implies that tx âˆˆ Ë†Rj of at least one party pj. Consider the next snapshot produced by
pj. Since tx âˆˆ Ë†Rj, there is a transaction tx â€²âˆˆË†Tj with conï¬‚ict({tx,txâ€²}) that he adds to TR, and by
Lemma 6, eventually txâ€²âˆˆCk for every party pk.
Lemma 7 (Liveness). The head protocol satisï¬es Liveness.
Proof. By local transaction liveness and Invariant 10.
Invariant 12. Let ËœT be the set corresponding to SNcur,i. Then, ËœTâˆªTi = Ci, where Ti is the
(random variable corresponding to the) set T of pi.
Proof. Fix some party pi. Observe that the invariant is trivially satisï¬ed at the onset of the
protocolâ€™s execution. Furthermore, each time a new transaction is conï¬rmed via confTx, both Ti
and Ci grow by the newly conï¬rmed transaction, while ËœT remains unchanged.
The only other time one of the sets ËœT, Ti, and Ci change is when a new snapshot is conï¬rmed
via confSn. In such a case, note that
â€¢any transaction removed from Ti is considered by the new snapshot and thus added to ËœT,
and
â€¢any transaction added to Ci is also considered by the new snapshot and thus added to ËœT.
Hence, the invariant is still satisï¬ed.
Invariant 13. ËœT0 âŠ†ËœT1 âŠ†ËœT2 âŠ†... .
Proof. Let pi be an honest party. It is easily seen that the set of transactions considered by a new
snapshot always includes the set considered by the previous snapshot since the set of transactionsT
and TR in a reqSn satisfy that SNcur,iâ—¦(ReachTi(T)âˆªTR) Ì¸= âŠ¥, (this is implied by Invariant 12).
Invariant 14. If tx âˆˆCi âˆ©Cchain, it will remain there.
48

Proof. Consider operation Contest(Kagg,Î·,Î¾ ) and let Î· = (UÎ·,sÎ·,TÎ·) and Î¾ = (U,s, ËœÏƒ,T ). Note
that Cchain = ËœTsÎ· âˆªTÎ· holds before the operation. Consider now the set Tâˆ— in the output ( Â·,Â·,Tâˆ—)
of Contest. Note that after the operation Cchain = ËœTs âˆªTâˆ—. Observe that:
â€¢Since sâ‰¥sÎ·, Invariant 13 implies that a transaction tx âˆˆËœTsÎ· is also in ËœTs.
â€¢If a transaction tx âˆˆTÎ· is not in Tâˆ—but in Ci, then s>s Î· and the transaction is consumed
by the snapshot with number s, i.e., tx âˆˆ ËœTs. This is due to the fact that honest parties do
not sign snapshots contradicting conï¬rmed transactions.
Invariant 15. For all iâˆˆHcont, Ci âŠ†Cchain.
Proof. Take any honest partypi and let Ëœsbe the current snapshot number atpi, i.e., SNcur,i = U0â—¦ËœTËœs.
Recall that, by Invariant 12, Ci = ËœTËœs âˆªTi. Consider a close or contest operation by pi as well as
the output ( U,s,T âˆ—) of Contest, and observe that Cchain = ËœTs âˆªTâˆ— holds after the operation. By
Invariant 13, ËœTËœs âŠ† ËœTs and, by a similar argument as in the proof of Invariant 14, if tx âˆˆTi is not
in Tâˆ—, it must be in ËœTs. Hence, Ci âŠ†Cchain. Furthermore, by Invariant 14, the invariant remains
satisï¬ed.
Invariant 16. Ci âŠ†Ë†Si.
Proof. Honest parties will only output (conf,tx) if there exists a valid multisignature for tx, which
implies that each honest party output ( seen,tx) just before they signed tx.
Invariant 17. ËœTj âŠ†â‹‚
iâˆˆHCi.
Proof. Only transactions that have been seen conï¬rmed by all honest parties can ever be included
in a snapshot.
Invariant 18. Cchain âŠ†â‹‚
iâˆˆHË†Si.
Proof. Let Î·= (U,s,T ). Observe that Cchain = ËœTs âˆªT. Consider a transaction tx âˆˆCchain.
â€¢If tx âˆˆËœTs, then tx âˆˆâ‹‚
iâˆˆHCi âŠ†â‹‚
iâˆˆHË†Si by Invariants 17 and 16.
â€¢If tx âˆˆT, then tx âˆˆâ‹‚
iâˆˆHË†Si since no transaction can be conï¬rmed without being seen by all
honest parties.
Lemma 8. The head protocol with CR satisï¬es the Soundness property.
Proof. Let Î·= (U,s,T ) be the value of Î· just before applying Final(Î·,Uï¬nal). Clearly, the only set
Uï¬nal that will be accepted by Final is U0 â—¦( ËœTsâˆªT). By deï¬nition ËœTsâˆªT = Cchain. Soundness now
follows from Invariant 18.
Lemma 9. The head protocol with CR satisï¬es the Completeness property.
Proof. The lemma follows from Invariant 15 and an argument similar to that in the proof of
Lemma 8.
49

â‹¯
ğ—‚ğ—‡ğ—‚ğ—ğ—‚ğ–ºğ—…
â‹¯
â‹¯
ğ—ˆğ—‰ğ–¾ğ—‡
â‹¯
ğ–¼ğ—…ğ—ˆğ—Œğ–¾ğ–½ ğ—‡ğ–¾ğ—ğ–¾ğ—Œğ—ğ–²ğ–­
ğ–¿ğ—‚ğ—‡ğ–ºğ—…
â‹¯
ğ–ºğ–»ğ—ˆğ—‹ğ—
ğ–¼ğ—ˆğ—…ğ—…ğ–¾ğ–¼ğ—ğ–§ğ–³ğ–¼ğ—ˆğ—…ğ—…ğ–¾ğ–¼ğ—ğ–²ğ–­ğ–¼ğ—…ğ—ˆğ—Œğ–¾
ğ–¼ğ—ˆğ—…ğ—…ğ–¾ğ–¼ğ—ğ–¢ğ—ˆğ—†
â‹¯
â‹¯
â‹¯
â‹¯
â‹¯â‹¯
ğ–¿ğ—‚ğ—‡ğ–ºğ—…ğ—‚ğ—“ğ–¾
â‹¯
â‹¯
ğ—Œğ—‰ğ—…ğ—‚ğ—
Ideas: 
- close: provide hash of SN 
- newerSN: can provide newer SN 
- allocate: take newest SN and provide hanging txs 
- addTxs: provide missing hanging txs 
- fanout: compute hash of ï¬nal UTxO set 
- split: provide particular part of ï¬nal UTxO set
ğ—‚ğ—‡ğ–¼ğ—‹ğ–¾ğ—†ğ–¾ğ—‡ğ—/ğ–½ğ–¾ğ–¼ğ—‹ğ–¾ğ—†ğ–¾ğ—‡ğ—
commit txs
SN txs HT txs
Figure 20: Mainchain state diagram with (a) incremental commits and decommits, (b) opti-
mistic ï¬nalize, and (c) parallel contestation phase.
C Full Mainchain State Machine
This section outlines the following additions to the basic protocol:
â€¢Incremental commits and decommits: These allow head members, while the head is open, to
(1) commit new UTxOs to the head and (2) remove UTxOs from the head.
â€¢An optimistic ï¬nalization procedure: If all head members agree to close a head, this procedure
allows for a single-transaction head ï¬nalization.
â€¢A more eï¬ƒcient way to close a head: For the cases where the head is closed due to a slow
network and/or corrupted head members, this procedure allows to close the head with a short
contestation period. Moreover, the new closure procedure is designed in a way that keeps the
size of the mainchain transactions small.
The state diagram corresponding to the full mainchain state machine (SM) is depicted in Figure 20.
The transactions used to implement the above features are explained in Section C.1 and make
use of additional on-chain veriï¬cation (OCV) algorithms Increment, Decrement, Finalize, Snapshot,
ValidSN, ValidHT, and Fanout as well as modiï¬ed Close and Final. The additional OCV algorithms
as well as changes to the head protocol are explained in Section C.3, after deï¬ning a variant of
so-called Merkle-Patricia trees in Section C.2.
C.1 New mainchain transactions
C.1.1 Incremental (de)commits
In the basic protocol, UTxOs can only be committed to a head before it reaches the open state.
Once the head is running, no additional UTxOs can be added to it. Similarly, the only way of
freeing up UTxOs in the head and make them available for spending on the mainchain is to close
50

Increment
ğ—ˆğ—‰ğ–¾ğ—‡,Kğ–ºğ—€ğ—€,Î·,hğ–¬ğ–³,n,T ğ—ˆğ—‰ğ–¾ğ—‡,Kğ–ºğ—€ğ—€,Î·â€² ,hğ–¬ğ–³,n,Tğ—‚ğ—‡ğ–¼ğ—‹ğ–¾ğ—†ğ–¾ğ—‡ğ—
: check that 1.  is proof that  is contained in  2.  where  are added UTxOs
txâ‰¡Ï€ğ–¬ğ–³ kâ€² 
hğ–¬ğ–³Î·=ğ–¨ğ—‡ğ–¼ğ—‹ğ–¾ğ—†ğ–¾ğ—‡ğ—(Î·,U)U
(rğ—†ğ—‚ğ—‡,rğ—†ğ–ºğ—‘)
Signed: k
(râ€² ğ—†ğ—‚ğ—‡,râ€² ğ—†ğ–ºğ—‘)
Signed: kâ€² 
{p1,â€¦,pn}âˆªğ—ğ–ºğ—… {p1,â€¦,pn}âˆªğ—ğ–ºğ—…â€² 
Ï€ğ–¬ğ–³
Ï
ğ—ğ–ºğ—…â€² â€² ,Î½,Î´
â‹®commited output o
Figure 21: collectCom/increment/decrement transaction (left) with increment transaction
(right).
Decrement
ğ—ˆğ—‰ğ–¾ğ—‡,Kğ–ºğ—€ğ—€,Î·,hğ–¬ğ–³,n,T ğ—ˆğ—‰ğ–¾ğ—‡,Kğ–ºğ—€ğ—€,Î·â€² ,hğ–¬ğ–³,n,Tğ–½ğ–¾ğ–¼ğ—‹ğ–¾ğ—†ğ–¾ğ—‡ğ—
: check that 1.  is proof that  is contained in  2.
txâ‰¡Ï€ğ–¬ğ–³ kâ€² 
hğ–¬ğ–³Î·=ğ–£ğ–¾ğ–¼ğ—‹ğ–¾ğ—†ğ–¾ğ—‡ğ—(Kğ–ºğ—€ğ—€,Î¾,U)
(rğ—†ğ—‚ğ—‡,rğ—†ğ–ºğ—‘)
Signed: k
(râ€² ğ—†ğ—‚ğ—‡,râ€² ğ—†ğ–ºğ—‘)
Signed: kâ€² 
{p1,â€¦,pn}âˆªğ—ğ–ºğ—… {p1,â€¦,pn}âˆªğ—ğ–ºğ—…â€² 
U}
<latexit sha1_base64="WxxOLoH8qvPV+BjLCZ5YgtKmayM=">AAAB/XicdVDLSgNBEOz1GeMr6tHLYBA8hd0o6DHoxWMU84BkCbOT2WTIzO4y0yuEJfgDXvUPvIlXv8Uf8DucJHvQBAsaiqpuqqkgkcKg6345K6tr6xubha3i9s7u3n7p4LBp4lQz3mCxjHU7oIZLEfEGCpS8nWhOVSB5KxjdTP3WI9dGxNEDjhPuKzqIRCgYRSvddye9UtmtuDOQZeLlpAw56r3Sd7cfs1TxCJmkxnQ8N0E/oxoFk3xS7KaGJ5SN6IB3LI2o4sbPZp9OyKlV+iSMtZ0IyUz9fZFRZcxYBXZTURyaRW8q/ufhUC2kY3jlZyJKUuQRm4eHqSQYk2kVpC80ZyjHllCmhf2fsCHVlKEtrGiL8RZrWCbNasU7r1TvLsq167yiAhzDCZyBB5dQg1uoQwMYhPAML/DqPDlvzrvzMV9dcfKbI/gD5/MH32SV5A==</latexit>
Ï€ğ–¬ğ–³,Î¾
â‹® â‹®
(rğ—†ğ—‚ğ—‡,rğ—†ğ–ºğ—‘)
Figure 22: collectCom/increment/decrement transaction (left) with decrement transaction
(right).
the head. Incremental commits and decommits allow arbitrary UTxOs to be added and removed
from the head, respectively, while the head is open.
Incremental commit. In order to add UTxOs to the head, a head member may post an in-
crement transaction (cf. Figure 21), causing a state transition from open to itself. The increment
transaction can have any number of inputs (but at least one) that consume the newly committed
outputs. Let U be the set of such outputs o; OCV function Increment processes this information
and outputs an updated head status Î·â€²â†Increment(Î·,U).
Incremental decommit. A head member wishing to make UTxOs inside the head available
on the mainchain posts a decrement transaction (cf. Figure 22), again causing a transition from
open to itself. The decrement transaction can have any number of outputs (but at least one)
that make the newly decommitted outputs available on the mainchain. Let U be the set of such
outputs; OCV function Decrement processes this information along with a certiï¬cate Î¾ created by
the head members to permit the decommit operation. Decrement outputs an updated head status
Î·â€²â†Decrement(Kagg,Î·,Î¾,U ); it may also output âŠ¥, but in order for a close transaction to be valid
Î·â€²Ì¸= âŠ¥is required.
C.1.2 Optimistic head closure
If all head members agree that a head should be closed, the close/contestation phase can be foregone,
and, by posting a ï¬nalize transaction (cf. Figure 23), the head SM can be made to go from the open
51

â‹®
Finalize
ğ—ˆğ—‰ğ–¾ğ—‡,Kğ–ºğ—€ğ—€,Î·,hğ–¬ğ–³,n,T ğ–¿ğ—‚ğ—‡ğ–ºğ—…ğ—‚ğ—“ğ–¾Ï€ğ–¬ğ–³,Î¾
(rğ—†ğ—‚ğ—‡,rğ—†ğ–ºğ—‘)
Signed: k
{p1,â€¦,pn}âˆªğ—ğ–ºğ—…
: check that 1.  is proof that  is contained in  2.
txâ‰¡Ï€ğ–¬ğ–³ kâ€² 
hğ–¬ğ–³ğ–¥ğ—‚ğ—‡ğ–ºğ—…ğ—‚ğ—“ğ–¾(Î·,Î¾,U)
ğ–¿ğ—‚ğ—‡ğ–ºğ—…
âˆ…
(râ€² ğ—†ğ—‚ğ—‡,râ€² ğ—†ğ–ºğ—‘)
Signed: kâ€² 
U
Burn {p1,â€¦,pn}::ğ–¼ğ—‚ğ–½
}
<latexit sha1_base64="WxxOLoH8qvPV+BjLCZ5YgtKmayM=">AAAB/XicdVDLSgNBEOz1GeMr6tHLYBA8hd0o6DHoxWMU84BkCbOT2WTIzO4y0yuEJfgDXvUPvIlXv8Uf8DucJHvQBAsaiqpuqqkgkcKg6345K6tr6xubha3i9s7u3n7p4LBp4lQz3mCxjHU7oIZLEfEGCpS8nWhOVSB5KxjdTP3WI9dGxNEDjhPuKzqIRCgYRSvddye9UtmtuDOQZeLlpAw56r3Sd7cfs1TxCJmkxnQ8N0E/oxoFk3xS7KaGJ5SN6IB3LI2o4sbPZp9OyKlV+iSMtZ0IyUz9fZFRZcxYBXZTURyaRW8q/ufhUC2kY3jlZyJKUuQRm4eHqSQYk2kVpC80ZyjHllCmhf2fsCHVlKEtrGiL8RZrWCbNasU7r1TvLsq167yiAhzDCZyBB5dQg1uoQwMYhPAML/DqPDlvzrvzMV9dcfKbI/gD5/MH32SV5A==</latexit>
Note: ï¬nalize can also split UTxOs if needed
â‹®
Figure 23: collectCom/increment/decrement transaction (left) with ï¬nalize transaction (right).
state to the ï¬nal state right away. The ï¬nal transaction must have outputs that correspond to the
ï¬nal head state as agreed upon by the parties. To that end, OCV predicate Finalize(Î·,Kagg,U,Î¾ )
checks the transactionâ€™s output set U against a special certiï¬cate Î¾ provided by the redeemer and
the information recorded in Î·. The certiï¬cate Î¾ consists of a multisigned value h||â€œï¬nalâ€, where
h is the hash of the ï¬nal UTxO set. The ï¬nalize transaction is only valid if Final outputs true.
Moreover, all participation tokens must be burned.
C.1.3 Eï¬ƒcient contestation phase
Recall that in the simple protocol, in order to terminate a head, some party p ï¬rst posts a close
transaction, which also contains information about the current head state. In a subsequent se-
quential contestation phase, each party is given the opportunity to supply more recent information
in case pâ€™s information was outdated or p is corrupted. In the worst case, this process requires
a sequence of n mainchain transactions. In order to avoid this issue, a more involved parallel
contestation phase can be used to close out a head.
This parallel contestation phase is tailored to the actual head protocol in use (cf. Section 6) in
that it ï¬rst collectsâ€”in parallelâ€”proposals for the most recent snapshot and thereafterâ€”also in
parallelâ€”so-called hanging transactions, which are the conï¬rmed head transactions that have not
yet been considered by a snapshot. The reason for executing a head closure in two steps is that
collecting snapshots ï¬rst prevents a corrupted head member from posting a very old snapshot along
with a large number of hanging transactions.
Thus, to close a head, a close transaction is posted by some head member. The close transac-
tion has n outputsâ€”one for each head memberâ€”to which SN transactions can be attached. An
SN transaction allows a head member to post (information about) the newest snapshot to the
mainchain. The subsequent transaction, the collectSN transaction, collects all SN transactions
and picks the most recent snapshot. It has n outputs as well, to which each party may attach a
HT transaction. Each HT transaction allows a head member to post (information about) hanging
transactions. Finally, the collectHT transaction collects all HT transactions and determines the
ï¬nal UTxO set. The collectHT transaction also determines how to spilt the ï¬nal UTxO set and
provides suï¬ƒciently many outputs forsplit transactions to be attached, where eachsplit transaction
has as outputs a subset of the ï¬nal UTxO set.
52

Close
ğ—ˆğ—‰ğ–¾ğ—‡,Kğ–ºğ—€ğ—€,Î·,hğ–¬ğ–³,n,T
ğ–¼ğ—…ğ—ˆğ—Œğ–¾ğ–½,Kğ–ºğ—€ğ—€,Î·â€² ,hğ–¬ğ–³,n,T,Tğ—‡ğ–¾ğ—ğ–¾ğ—Œğ—ğ–²ğ–­
ğ–¼ğ—…ğ—ˆğ—Œğ–¾
: check that 1.  is proof that  is contained in  2.  3.  to  are in  4.
txâ‰¡Ï€ğ–¬ğ–³ kâ€² 
hğ–¬ğ–³(Î·â€² ,Î²â€² 1,â€¦,Î²â€² n)=ğ–¢ğ—…ğ—ˆğ—Œğ–¾(Î·,Î¾)k1 kn hğ–¬ğ–³Tğ—Œğ—‡ğ–ºğ—‰ğ—Œğ—ğ—ˆğ—=râ€² ğ—†ğ–ºğ—‘+T
ğ—ğ–ºğ—…
Ï€ğ–¬ğ–³
(rğ—†ğ—‚ğ—‡,rğ—†ğ–ºğ—‘)
Signed: k
â‹®
{p1},Î½ğ–¼ğ—…ğ—ˆğ—Œğ–¾ğ–½,(k1,Î²â€² 1)
{pn},Î½ğ–¼ğ—…ğ—ˆğ—Œğ–¾ğ–½,(kn,Î²â€² n)
(râ€² ğ—†ğ—‚ğ—‡,râ€² ğ—†ğ–ºğ—‘)
Signed: kâ€² 
{p1,â€¦,pn}âˆªğ—ğ–ºğ—…
Information in  allows to check SN proposals immediately (as opposed to only upon allocate)
Î²â€² i
â‹®
Figure 24: collectCom/increment/decrement transaction (left) with close transaction (right).
NewerSN Txs
{p1},Î½ğ–²ğ–­,Î¾1
Signed: k1
: check that 1.  or 1.next transaction is allocate SM 
Î½ğ–¼ğ—…ğ—ˆğ—Œğ–¾ğ–½ğ–µğ–ºğ—…ğ—‚ğ–½ğ–­ğ–²ğ–­(Î²1,Î¾1,Ï1)
Ï1
ğ–¼ğ—…ğ—ˆğ—Œğ–¾ğ–½,Kğ–ºğ—€ğ—€,Î·,hğ–¬ğ–³,n,T,Tğ—‡ğ–¾ğ—ğ–¾ğ—Œğ—ğ–²ğ–­ ğ—ğ–ºğ—…
â‹®
{p1},Î½ğ–¼ğ—…ğ—ˆğ—Œğ–¾ğ–½,(k1,Î²1)
{pn},Î½ğ–¼ğ—…ğ—ˆğ—Œğ–¾ğ–½,(kn,Î²n)
(rğ—†ğ—‚ğ—‡,rğ—†ğ–ºğ—‘)
Signed: k : check that 1.next transaction is allocated SM 
Î½ğ—‡ğ–¾ğ—ğ–¾ğ—‹ğ–²ğ–­
SN transaction
Figure 25: close transaction (left) with SN transaction (right).
Initiating head closure. In order to close a head, a head member may post theclose transaction
(cf. Figure 24), which results in a state transition from the open state to the closed state. Compared
to the basic protocol, the poster is not required to provide any information about the status of the
head at this point. Instead, the close transaction has noutputs locked by validator Î½closed. The ith
output has (ki,Î²â€²
i) in its data ï¬eld, where k1,...,k n are the public keys that are hashed in hMT and
the Î²â€²
i contain information required by OCV algorithmValidSN to verify the SN transactions posted
(see below). Speciï¬cally, they are created by OCV algorithm ( Î·â€²,Î²â€²
1,...,Î² â€²
n) â†Close(Kagg,Î·),
which is also allowed to update the head status. Observe that the close transaction also places the
n participation tokens in the outputs.
Validator Î½closed ensures the following: either the output is consumed by
1. an SM collectSN transaction (see below) or
2. an SN transaction (identiï¬ed by having validator Î½SN in its only output), and
(a) the transaction is signed by ki,
(b) OCV algorithm ValidSN(Î²â€²
i,Î¾i,Ïi) returns true, where Î¾i and Ïiâ€”in the SN transac-
tionâ€™s output data ï¬eld resp. redeemerâ€”contain snapshot information (see below and
Figure 25).
Once a close transaction has been posted, an SN-posting period begins which should last at
least T slots. Hence, the last slot TnewestSN of said period is recorded in the state, and it is ensured
that TnewestSN â‰¥râ€²
max + T.
53

Collect
ğ—‡ğ–¾ğ—ğ–¾ğ—Œğ—ğ–²ğ–­,Kğ–ºğ—€ğ—€,Î·,hğ–¬ğ–³,n,T,Tğ–¿ğ—‚ğ—‡ğ–ºğ—…
ğ–¼ğ—ˆğ—…ğ—…ğ–¾ğ–¼ğ—ğ–²ğ–­
: check that 1.  is proof that  is contained in  2.  3.  4.
txâ‰¡Ï€ğ–¬ğ–³ kâ€² hğ–¬ğ–³(Î·â€² ,Î²â€² 1,â€¦,Î²â€² n)=ğ–²ğ—‡ğ–ºğ—‰ğ—Œğ—ğ—ˆğ—(Î·,Î¾1,â€¦,Î¾n)râ€² ğ—†ğ—‚ğ—‡â‰¥Tğ—Œğ—‡ğ–ºğ—‰ğ—Œğ—ğ—ˆğ—Tğ–¿ğ—‚ğ—‡ğ–ºğ—…=râ€² ğ—†ğ–ºğ—‘+T
Ï€ğ–¬ğ–³
â‹®
{p1},Î½ğ—‡ğ–¾ğ—ğ–¾ğ—Œğ—ğ–²ğ–­,Î²â€² 1
{pn},Î½ğ—‡ğ–¾ğ—ğ–¾ğ—Œğ—ğ–²ğ–­,Î²â€² n
(râ€² ğ—†ğ—‚ğ—‡,râ€² ğ—†ğ–ºğ—‘)
Signed: kâ€² 
ğ–¼ğ—…ğ—ˆğ—Œğ–¾ğ–½,Î·,Kğ–ºğ—€ğ—€,hğ–¬ğ–³,n,T,Tğ—‡ğ–¾ğ—ğ–¾ğ—Œğ—ğ–²ğ–­ ğ—ğ–ºğ—…
â‹®
{p1},Î½ğ–¼ğ—…ğ—ˆğ—Œğ–¾ğ–½,(k1,Î²1)
{pn},Î½ğ–¼ğ—…ğ—ˆğ—Œğ–¾ğ–½,(kn,Î²n)
(rğ—†ğ—‚ğ—‡,rğ—†ğ–ºğ—‘)
Signed: k
â€¦,Î½ğ–²ğ–­,Î¾1â‹®
Information in  allows to check hangingTxs txs immediately (as opposed to only upon collect)
Î²â€² i
ğ—ğ–ºğ—…SN transactions
Figure 26: collectSN transaction (left) with collectHT transaction (right) and HT transactions
(center).
Providing snapshot information. In an SN transaction (cf. Figure 25), a party simply provides
information about their most recent snapshot in the redeemer Ï and the output data ï¬eld Î¾; Ï
contains data only relevant to verify the SN transaction itself, whereas Î¾ contains information
relevant for the SM. Speciï¬cally, Î¾ contains h||s, where h is the hash and s the number of the
newest snapshot, and Ï contains a multisignature on h||s. All SN transactions are collected by an
SM collectSN transaction.
Collecting snapshot information. The collectSN transaction (cf. Figure 26) causes the SM to
transition from closed to newestSN. The OCV function Snapshot is responsible for collecting the
values Î¾i provided in the SN transactions and computing a new head state Î·â€²as (Î·â€²,Î²â€²
1,...,Î² â€²
n) â†
Snapshot(Kagg,Î·,Î¾ 1,...,Î¾ n), where the Î²â€²
i have a purpose similar to that of the Î²â€²
i in the close
transaction.
The collectSN transaction has n outputs, each locked by validator Î½newestSN, which ensures the
following: either the output is consumed by
1. an SM collectHT transaction (see below) or
2. a hangingTx transaction (identiï¬ed by having validator Î½HT in its only output), and
(a) the transaction is signed by ki,
(b) OCV algorithm ValidHT(Î²â€²
i,Î¾i,Ïi) returns true, where Î¾i and Ïi contain information
about hanging transactions (cf. Figure 27).
Once a collectSN transaction has been posted, a hangingTx-posting period begins which should
last at least T slots. Hence, the last slot Tï¬nal of said period is recorded in the state, and it is
ensured that Tï¬nal â‰¥râ€²
max + T.
Providing hanging transactions. In an HT transaction (cf. Figure 27), a party simply provides
information about hanging transactions not included in the most recent snapshot provided during
the snapshot phase. As with SN transactions, this information is split between the redeemer and
the output data ï¬eld. All HT transactions are collected by an SM collectHT transaction.
54

HangingTxs Txs
{pâ€² 1},Î½ğ–§ğ–³,Î¾1Ï1
ğ—‡ğ–¾ğ—ğ–¾ğ—Œğ—ğ–²ğ–­,Kğ–ºğ—€ğ—€,Î·,hğ–¬ğ–³,n,T,Tğ–¿ğ—‚ğ—‡ğ–ºğ—… ğ—ğ–ºğ—…
â‹®
{p1},Î½ğ—‡ğ–¾ğ—ğ–¾ğ—Œğ—ğ–²ğ–­,Î²1
{pn},Î½ğ—‡ğ–¾ğ—ğ–¾ğ—Œğ—ğ–²ğ–­,Î²n
(rğ—†ğ—‚ğ—‡,rğ—†ğ–ºğ—‘)
Signed: k
: check that 1.  or 1.next transaction is ï¬nal SM 
Î½ğ–ºğ—…ğ—…ğ—ˆğ–¼ğ–µğ–ºğ—…ğ—‚ğ–½ğ–§ğ–³ğ—‘ğ—Œ(Î²1,Î¾1,Ï1)
: check that 1.next transaction is ï¬nal SM 
Î½ğ—ğ–ºğ—‡ğ—€ğ—‚ğ—‡ğ—€ğ–³ğ—‘ğ—Œ
HT transaction
Figure 27: collectSN transaction (left) with HT transaction (right).
Collect
ğ—‡ğ–¾ğ—ğ–¾ğ—Œğ—ğ–²ğ–­,Kğ–ºğ—€ğ—€,Î·,hğ–¬ğ–³,n,T,Tğ–¿ğ—‚ğ—‡ğ–ºğ—…
ğ–¼ğ—ˆğ—…ğ—…ğ–¾ğ–¼ğ—ğ–§ğ–³
: check that 1.  is proof that  is contained in  2.  3.
tx â‰¡Ï€ğ–¬ğ–³ kâ€² hğ–¬ğ–³(ğ—ğ–ºğ—…i,Î²i)â„“i= 1â†ğ–¥ğ–ºğ—‡ğ—ˆğ—ğ—(Î·,Î¾1,â€¦,Î¾n)râ€² ğ—†ğ—‚ğ—‡â‰¥Tğ–¿ğ—‚ğ—‡ğ–ºğ—…
ğ—ğ–ºğ—…
Ï€ğ–¬ğ–³,ğ–ºğ—ğ—‘
â€¦,Î½ğ–§ğ–³,Î¾1â‹®
â‹®
{p1},Î½ğ—‡ğ–¾ğ—ğ–¾ğ—Œğ—ğ–²ğ–­,Î²1
{pn},Î½ğ—‡ğ–¾ğ—ğ–¾ğ—Œğ—ğ–²ğ–­,Î²n
(rğ—†ğ—‚ğ—‡,rğ—†ğ–ºğ—‘)
Signed: k
ğ–¿ğ—‚ğ—‡ğ–ºğ—…
âˆ…
â‹®
(râ€² ğ—†ğ—‚ğ—‡,râ€² ğ—†ğ–ºğ—‘)
Signed: kâ€² 
Burn {p1,â€¦,pn}
ğ—ğ–ºğ—…â€² 1,Î½ğ–¿ğ—‚ğ—‡ğ–ºğ—…,Î²â€² 1
ğ—ğ–ºğ—…â€² â„“,Î½ğ–¿ğ—‚ğ—‡ğ–ºğ—…,Î²â€² â„“
HT transactions
Figure 28: close transaction (left) with collectSN transaction (right) and SN transactions
(center).
Collecting hanging transactions. The collectHT transaction (cf. Figure 28) collects all the
information Î¾i provided by the HT transactions in order to compute the ï¬nal UTxO set (i.e., the
UTxO set resulting from applying all hanging transactions to the newest snapshot) and to determine
how to partition the UTxO set intoâ„“components (in order to avoid posting large transactions on the
mainchain). Speciï¬cally, the OCV function Fanout takes as input keyKagg, Î·, auxiliary information
aux in the redeemer, and the values Î¾i and computes ( valâ€²
i,Î²â€²
i) for i = 1,...,â„“ , where valâ€²
i is the
value in the ith partition and Î²â€²
i is used to validate the corresponding split transaction. The ï¬nal
transaction must also burn the participation tokens p1,...,p n and may only be posted after the
HT phase is completed, i.e., only when râ€²
min â‰¥Tï¬nal.
Splitting the ï¬nal UTxO set. The task of split transactions (cf. Figure 29) is to make the
UTxOs in a particular partition (as determined by Fanout) available for consumption on the main-
chain. To verify that this is done correctly, validator Î½ï¬nal runs OCV predicate Final(Î²i,Ui), where
Ui is the set of outputs of the split transaction.
C.2 UTxO sets and Merkle-Patricia Trees
The head protocol and OCV algorithms for the full Hydra protocols make use of a variant of so-
called Merkle-Patricia Trees (MPTs) [22]. Hydraâ€™s MPTs store a set of D outref/output pairs
55

Split Txs
: check that 
1.
Î½ğ–¿ğ—‚ğ—‡ğ–ºğ—…
ğ–¥ğ—‚ğ—‡ğ–ºğ—…(Î·1, U1)
ğ–¿ğ—‚ğ—‡ğ–ºğ—…
âˆ…
â‹®
(rğ—†ğ—‚ğ—‡, rğ—†ğ–ºğ—‘)
Signed: k
Burn {p1, â€¦ , pn}
ğ—ğ–ºğ—…1, Î½ğ–¿ğ—‚ğ—‡ğ–ºğ—…, Î²1
ğ—ğ–ºğ—…â„“, Î½ğ–¿ğ—‚ğ—‡ğ–ºğ—…, Î²â„“ â‹® U1
}
<latexit sha1_base64="WxxOLoH8qvPV+BjLCZ5YgtKmayM=">AAAB/XicdVDLSgNBEOz1GeMr6tHLYBA8hd0o6DHoxWMU84BkCbOT2WTIzO4y0yuEJfgDXvUPvIlXv8Uf8DucJHvQBAsaiqpuqqkgkcKg6345K6tr6xubha3i9s7u3n7p4LBp4lQz3mCxjHU7oIZLEfEGCpS8nWhOVSB5KxjdTP3WI9dGxNEDjhPuKzqIRCgYRSvddye9UtmtuDOQZeLlpAw56r3Sd7cfs1TxCJmkxnQ8N0E/oxoFk3xS7KaGJ5SN6IB3LI2o4sbPZp9OyKlV+iSMtZ0IyUz9fZFRZcxYBXZTURyaRW8q/ufhUC2kY3jlZyJKUuQRm4eHqSQYk2kVpC80ZyjHllCmhf2fsCHVlKEtrGiL8RZrWCbNasU7r1TvLsq167yiAhzDCZyBB5dQg1uoQwMYhPAML/DqPDlvzrvzMV9dcfKbI/gD5/MH32SV5A==</latexit>
split Transaction
Figure 29: collectHT transaction with split transaction.
(out-ref,o) in such a way that
â€¢(determinism) the set D deï¬nes the tree (i.e., the order of insertions and removals have no
eï¬€ect on the treeâ€™s shape),
â€¢(hashing) a tree can be hashedâ€”i.e., a so-called root hash can be computedâ€”in such a way
that it is computationally hard to ï¬nd two trees (or, equivalently, two sets D and Dâ€²) with
the same hash,
â€¢(membership proofs) membership of a pair ( out-ref,o) in the tree can be veriï¬ed using the
root hash and auxiliary information aux of size O(log |D|),
â€¢(removing and adding) given a root hash hroot corresponding to a set D and sets RâŠ†D and
Awith Aâˆ©D= âˆ…, the root hash corresponding to D\RâˆªAcan be computed from hroot and
auxiliary information aux of size O(log |D|), and
â€¢(splitting) given any number B, a tree corresponding to D can be split into subtrees corre-
sponding to disjoint sets D1,...,D â„“ (for some â„“) with D1 âˆª... âˆªDâ„“ = D such that
â€“ the elements of each Di have size at most B bits, and
â€“ the root hashes and total values corresponding to each Di can be computed using the
root hash hroot of D and auxiliary information aux of size B.11
Deï¬ning MPTs. MPTs used by Hydra have alphabet size A = 16. The MPT corresponding
to a set D is deï¬ned via algorithm MPT-Build in Figure 30. Note that outrefs take on the role
of â€œkeysâ€ and outputs o that of â€œvalues.â€ MPTs are deï¬ned recursively, where the root node
node = (pre,H,S,V ) of the tree corresponding to D with D> 1 has the following ï¬elds:
â€¢Preï¬x: The ï¬eld pre stores the common preï¬x of all the keys found in D.
â€¢Children: The array H stores the hashes of all A children nodes, where H[i] = âŠ¥if the
corresponding child is not present. The ith child of node is the root of the MPT containing
all elements corresponding to the set Dâ€²â€²computed as follows:
11Observe that this only works if the trees do not exceed a certain maximum size.
56

1. Let the set Dâ€² be the set obtained by removing the preï¬x pre from every key out-ref in
every pair (out-ref,o) âˆˆD; this is denoted ( pre,Dâ€²) â†CP(D) in Figure 30.
2. Let Dâ€²â€² be the set obtained by additionally removing the character i from each out-ref;
this is denoted by Proj(Dâ€²,i) in Figure 30.
â€¢Size: For each i âˆˆ[A], S[i] records the combined size of the leaves of the subtree at the ith
child. The combined size of all leaves innodeâ€™s subtree isSum(S), where Sum(S) = âˆ‘
iâˆˆ[A] S[i].
â€¢Value: For each i âˆˆ[A], V[i] records the value of the subtree at the ith child. The value of
nodeâ€™s subtree is Sum(V), where Sum(V) = âˆ‘
iâˆˆ[A] V[i].
N[Â·]â†Îµ
MPT-Build(D)
if|D|>1
(pre,Dâ€²)â†CP(D)
H[Â·],S[Â·],V[Â·]â†Îµ
foriâˆˆ[A]
(H[i],S[i],V[i])â†MPT-Build(Proj(Dâ€²,i))
nodeâ†(pre,H,S,V)
hâ†H(node)
N[h]â†node
return(h,Sum(S),Sum(V))
else if|D|= 1
{(pre,o)}â†D
leafâ†(pre,o)
hâ†H(leaf)
N[h]â†leaf
(val,Â·,Â·)â†o
return(h,Size(leaf),val)
else
return(âŠ¥,0,âˆ…)
Figure 30: Recursive procedure to build an
MPT from a set D of outref/output pairs
(out-ref,o). The algorithm stores the nodes
in the array N indexed by their hashes and
returns the hash of the root node as well as
total size and value of the entire tree.
Leaf nodes leaf = ( pre,o) correspond to a single-
element D= {(pre,o)}. Their size is given bySize(leaf),
and their value is val, where o= (val,Î½,Î´ ).
Hashing. The hash of an MPT is simply the hash of
its root node.
Membership proofs. To provide a proof that some
out-ref appears in an MPT with root hash hroot, it suf-
ï¬ces to provide as auxiliary information aux the nodes
on the path from the root to the leaf containing o.
The corresponding veriï¬cation function is denoted by
MPT-VfyMemb(h,out-ref,aux).
Removing and adding. Similarly to membership
proofs,
â€¢for removing a pair (out-ref,o) from an MPT with
root hash hroot, the new root hash can be com-
puted if given as auxiliary information aux the
nodes on the path from the root to the node
deleted, where, in cases where that node only has
one sibling, that sibling has to be provided as
well;
â€¢for adding a pair (out-ref,o) to an MPT with root
hash hroot, the new root hash can be computed if
given as auxiliary information aux the nodes on
the path from the root to the node where out-ref
diverges from the preï¬x traversed.
In order to remove an entire set R âŠ†D of outref/output pairs and subsequently add a set A
with Aâˆ©D = âˆ…(which is what happens when a transaction is applied to a UTxO set), the above
operations can simply be concatenated, producing a combined auxiliary string aux. The function
that computes the new root hash hâ€²
root from the old root hash hroot, the sets R and A, and aux is
denoted by hâ€²
root â†MPT-CompRA(hroot,R,A, aux).
57

Splitting. To split, as described above, a tree with nodesN, ï¬rst, each node node = (pre,H,S,V )
whose subtree has leaves with combined size âˆ‘
iS[i] >B is added to a list split (indexed by node
hashes), which is referred to as the split frontier. Then, every node node /âˆˆsplit with a parent in
the split frontier is the root of a subtree corresponding to one of the subsets Di. This way, the
combined size of all elements in each Di is at most B (as otherwise, node would be in the split set).
Denote these root nodes by node1,..., nodeâ„“ and call them split nodes.
In order to compute the hashes h1,...,h â„“ and values val1,..., valâ„“ of the split nodes from the
hash hroot of the root node of the entire tree, aux consists simply of the the split frontier split (which
includes said hashes and values).
Finally, for each split node nodei, deï¬ne the split preï¬x prei to be the common preï¬x of all
outrefs in Di. The split preï¬x will be needed to compute the hashes hi given the sets Di: hi is
obtained by computing the MPT corresponding to Di, but by removing prei from the preï¬x pre in
the resulting root node before hashing it.
The function computing the above values is denoted by
(h1,...,h â„“,val1,..., valâ„“,pre1,..., preâ„“) â† MPT-CompSpl(hroot,B, aux) .
C.3 Head protocol and on-chain veriï¬cation
In order to be used with the improved SM (cf. Figure 20), some small changes have to be made in
the head protocol. This section summarizes these changes and describes on a high level how the
OCV functions can be implemented to work with the improved SM.
Merkle-Patricia trees, UTxO sets and transactions. The head protocol and the OCV
algorithms can be implemented in such a way thatâ€”apart from split transactionsâ€”only hashed
information about snapshots and hanging transactions needs to be posted. That way, Hydra
mainchain transactions remain small even if the head UTxO set becomes large or there are many
hanging transactions.
Recall that a UTxO is simply a pairu= (out-ref,o) of outref and output. The full head protocol
maintains the current UTxO set by storing all UTxOs in an MPT as shown in Section C.2. When
creating new snapshots, parties sign the root hash of the MPT (instead of a plain hash of the UTxO
set).
Note that applying a transaction to a UTxO set always involves removing some UTxOs and
adding some new ones. Thus, evolving the hash corresponding to a UTxO set to include a new
transaction involves simple remove and add operations on the MPT.
To keep HT transactions small (see below), when conï¬rming a transaction tx = (I,O, valForge,r,
K), tx is hashed by computing
H(ID(tx),out-ref1,..., out-refw,o1,...,o wâ€²,hrest) ,
where
â€¢ID(tx) is the ID of tx as per the ledger rules,
â€¢I = {i1,...,i w}and ij = (out-refj,Ïj),
â€¢O= (o1,...,o wâ€²), and
â€¢hrest = H(Ï1,...,Ï w,valForge,r,K) is the hash of the rest of the transaction.
58

For MPT proofs of membership/insertion/deletion, this way of hashing allows to provide only the
ID ID(tx), the output references in I, the outputs O, and the hash hrest, which are usually much
shorter than the entire transaction.
Onchain veriï¬cation functions. Using these MPTs, the OCV functions for the eï¬ƒcient de-
commit can be implemented as follows:
â€¢Î·â€²â†Initial(U1,...,U n) computes the MPT corresponding to the union of the UTxO sets Ui
and stores the hash in the output Î·â€².
â€¢(Î·â€²,Î²â€²
1,...,Î² â€²
n) â†Close(Î·) leaves Î·â€²= Î· unchanged and puts Kagg into each Î²â€²
i.
â€¢ValidSN(Î²,Ï,Î¾ ) uses Kagg (stored in Î²) to verify the multisignature (stored in Ï) on the MPT
hash and snapshot number (stored in Î¾). The algorithm returns true if and only if the
signature veriï¬es and the snapshot number is greater than 0.
â€¢(Î·â€²,Î²â€²
1,...,Î² â€²
n) â†Snapshot(Î·,Î¾1,...,Î¾ n) simply picks theÎ¾i with the highest snapshot number
and stores the corresponding MPT root hash in Î·â€². Each output Î²â€²
i consists of Kagg as well
as said hash. Note that if all Î¾i are empty (because no party posted a valid SN transaction),
the initial hash (still in Î·) computed in Initial is used.
â€¢ValidHT(Î²,Ï,Î¾ ) is somewhat more involved. Recall that this validator checks an HT trans-
action, via which some party posts hanging transactionsâ€”in Î¾â€”along with corresponding
multisignatures and proofsâ€”in Ïâ€”showing that these transactions were conï¬rmed in the
head and can be applied to the most recent snapshot, whose hash hSN is stored in Î².
Hanging transactions tx = (I,O, valForge,r,K) are provided via the values
Ëœtx = ( ID(tx),out-ref1,..., out-refw,o1,...,o wâ€²,hrest)
as deï¬ned above. For each such transaction, ValidHT computes hâ†H( Ëœtx) and checks, using
Kagg (stored in Î²), that Ï contains a valid multisignature on h.
Once all transactions have been authenticated, ValidHT now processes them in topological
order and checks for each transaction tx that
â€“ either there is an out-refi = ( txID,txIdx) in tx such that txID refers to a previously
processed transaction, or
â€“ there is an MPT membership proofaux in Ïsuch thatMPT-VfyMemb(hSN,out-refi,aux) =
true for some out-refi in tx.
Note that since transactions are multisigned, it suï¬ƒces to check a single outref to ensure that
tx is not old (i.e., not already consumed by the newest snapshot).
â€¢(Î²1,...,Î² â„“,val1,..., valâ„“) â† Fanout(Î·,aux,Î¾1,...,Î¾ n) has two tasks: First, it must collect
hanging transactions (stored in variables Î¾i) and compute, using the hash hSN (stored in Î·) of
the most recent snapshot and auxiliary information aux1 (stored in aux), the hash hï¬nal of the
ï¬nal UTxO set; this can be done by means of the functionMPT-CompRA. Second, it must take
auxiliary information aux2 (stored in aux) and compute the split (h1,...,h â„“,val1,..., valâ„“,pre1,
..., preâ„“) â†MPT-CompSpl(hï¬nal,B, aux2). Each Î²i is set to ( hi,prei).
â€¢Final(Î²j,Uj) simply hashes Uj and checks if it matches Î·j.
59

D Further Protocol Aspects
D.1 Funding state-machine progress
In order for the mainchain state machine (SM) of the Hydra protocol to progress, head members
need to post the corresponding transactions; this is true for both the simpliï¬ed and the full protocol.
However, head members might decide to wait for other head members to post these transactions
in order to save on fees. It may, therefore, be necessary to oï¬€er rewards for posting some SM
transactions or, at the very least, to allocate funds to cover the incurred fees.
The following examples outline how rewards could be awarded for some of the SM transactions.
In general, however, it is up to the head members to decide the exact reward policy when the head
is being established:
â€¢initial: Generally, there is no need to oï¬€er rewards for posting the initial transaction, for the
will of the initiator to open the head should suï¬ƒce.
â€¢commit: A party willing to participate in the head will post its commit transaction. Thus,
there is no need to allocate any rewards for it.
â€¢collectCom: Since only one collectCom transaction is posted, a party may wait to see if other
head members post the transaction ï¬rst, which delays the progress of the head SM. Hence,
one should incentivize the posting of collectCom transactions.
â€¢abort: If a head fails to be established due to missing commit transactions, the remaining
head members have an incentive to abort the head. However, the incentive may be stronger
for parties who require the locked funds immediately. Therefore, it makes sense to reward
the party posting the abort transaction.
Similar arguments can be made forclose, contest, and fanout transactions as well as for transactions
of the full Hydra SM.
All the funds for rewards are pre-allocated in the commit transactions, which can be enforced
by the initial transaction. In order to do so, the required rewards must be estimated in advance.
This requires, in particular, upper bounds on the size of the head UTxO set, the maximum number
of hanging transactions etc. These quantities can be made explicit as head parameters.
Transactions that take the head SM to its ï¬nal state (e.g., abort or fanout) will make sure that
surplus funds will be appropriately redistributed.
D.2 Time handling in the head protocol
Recall that each transaction contains a tupler= (rmin,rmax) that speciï¬es the slot range [rmin,rmax]
wherein the transaction must be included in the ledger to be valid. Time-critical concepts such as
timed commitments are based on this construct.
In the mainchain, it is easy to agree on whether a transaction was included in the ledger within
a given slot range by verifying whether the slot of its containing block lies in that slot range; and
this fact will become irrevocably conï¬rmed once the block lies suï¬ƒciently deep in the blockchain.
In contrast, the conï¬rmation process in the head is asynchronous, and we require a diï¬€erent
mechanism to make this decision. We thus establish the rule that a party may only sign a transaction
60

if it has seen that transaction during its included slot range r; overall, this implies that a conï¬rmed
transaction has been seen by all honest parties â€œon time.â€ 12
Now, a party may not learn about conï¬rmation until after the slot range expired, but this is
not fundamentally diï¬€erent than on the mainchain.
Conï¬‚ict resolution. A problem arises with conï¬‚ict resolution (CR) when multiple transactions
with ï¬nite slot ranges ( rmax <âˆ) compete for redeeming the same UTxO. Such a conï¬‚ict cannot
always be settled by our standard CR mechanism, as a snapshot leader including his favored
transaction tx, in general, cannot know whether tx has been (or will be) accepted on time; and if
not, the snapshot would have to be rejected, and the head would have to be closed.
To avoid head closure due to snapshot rejection in the case of this (typically rare) event we
modify CR in two ways.
Firstly, for CR, the snapshot leader includes only the subset of the transactionsTR (c.f. Sec. B.1)
that have a safe amount of time left before deadline expiry. Then, a head with only honest partic-
ipants only has to be closed under extremely bad network conditions.
Secondly, we need a mechanism to handle expired transactions that have been seen, but possibly
not conï¬rmed. Assume that a party p signed a transaction txA but does not get it conï¬rmed until
after the transactionâ€™s deadline rmax; hence, p does, at this point, not know whether the transaction
txA will eventually be conï¬rmed â€” as some participants may have received txA too late. If at
this point a second, conï¬‚icting transaction txB gets published and p is the snapshot leader, it has
to make a choice for which it has insuï¬ƒcient information: it must reject if txA is conï¬rmed (for
consistency), but sign txB if txA is unconï¬rmed (for liveness).
To avoid such decisions, we extend the snapshot mechanism as follows. The snapshot leader
includes into its snapshot an obituary set of transactions that it sees as expired and only partially
conï¬rmed. If any party is in possession of a multisignature for a transaction in the obituary set,
it resurrects this transaction by including its multisignature into the snapshot it produces during
its next turn as a snapshot leader. After a full cycle of snapshot round robin, we can thus safely
accept such a transaction as conï¬rmed if a multisignature was added during that cycle, or reject it
as expired if no multisignature was delivered.
D.3 Transaction throttling
An adversarial leader could stall the snapshot production while still allowing new transactions to
get conï¬rmed. To prevent that such an attack grows the stored transaction history beyond limits,
the size of all snapshot-unprocessed transactions may only grow to a given limit. As long as this
limit is reached, no new transactions are conï¬rmed (or, alternatively, the head is closed once the
limit is reached).
12Note that, although our head protocol is asynchronous, we can still rely on roughly synchronized clocks among
the head participants (for example, by observing the mainchain)â€”as we already need to make this assumption to
safely handle contestation periods during the closing of a head.
61