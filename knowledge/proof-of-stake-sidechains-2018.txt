Proof-of-Stake Sidechains
Peter Gaˇ zi1, Aggelos Kiayias1,2, and Dionysis Zindros1,3
1 IOHK
2 University of Edinburgh
3 National and Kapodistrian University of Athens
December 18, 2018
Abstract. Sidechains have long been heralded as the key enabler of blockchain scalability and inter-
operability. However, no modeling of the concept or a provably secure construction has so far been
attempted.
We provide the ﬁrst formal deﬁnition of what a sidechain system is and how assets can be moved
between sidechains securely. We put forth a security deﬁnition that augments the known transaction
ledger properties of persistence and liveness to hold across multiple ledgers and enhance them with
a new “ﬁrewall” security property which safeguards each blockchain from its sidechains, limiting the
impact of an otherwise catastrophic sidechain failure.
We then provide a sidechain construction that is suitable for proof-of-stake (PoS) sidechain systems.
As an exemplary concrete instantiation we present our construction for an epoch-based PoS system
consistent with Ouroboros (Crypto 2017), the PoS blockchain protocol used in Cardano which is one
of the largest pure PoS systems by market capitalisation, and we also comment how the construction
can be adapted for other protocols such as Ouroboros Praos (Eurocrypt 2018), Ouroboros Genesis
(CCS 2018), Snow White and Algorand. An important feature of our construction is merged-staking
that prevents “goldﬁnger” attacks against a sidechain that is only carrying a small amount of stake. An
important technique for pegging chains that we use in our construction is cross-chain certiﬁcation which
is facilitated by a novel cryptographic primitive we introduce called ad-hoc threshold multisignatures
(ATMS) which may be of independent interest. We show how ATMS can be securely instantiated by
regular and aggregate digital signatures as well as succinct arguments of knowledge such as STARKs
and bulletproofs with varying degrees of storage eﬃciency.
1 Introduction
Blockchain protocols and their most prominent application so far, cryptocurrencies like Bitcoin [27], have
been gaining increasing popularity and acceptance by a wider community. While enjoying wide adoption,
there are several fundamental open questions remaining to be resolved that include (i) Interoperability: How
can diﬀerent blockchains interoperate and exchange assets or other data? (ii) Scalability: How can blockchain
protocols scale, especially proportionally to the number of participating nodes? (iii) Upgradability: How can
a deployed blockchain protocol codebase evolve to support a new functionality, or correct an implementation
problem?
The main function of a blockchain protocol is to organise application data into blocks so that a set of
nodes that evolves over time can arrive eventually to consensus about the sequence of events that took place.
The consensus component can be achieved in a number of ways, the most popular is using proof-of-work [16]
(cf. [27,17]), while a promising alternative is to use proof-of-stake (cf. [26,20,5,13]). Application data typically
consists of transactions indicating some transfer of value as in the case of Bitcoin [27]. The transfer of value
can be conditioned on arbitrary predicates called smart contracts such as, for example, in Ethereum [11,31].
The conditions used to validate transactions depend on local blockchain events according to the view
of each node and they typically cannot be dependent on other blockchain sessions. Being able to perform
operations across blockchains, for instance from a main blockchain such as Bitcoin to a “sidechain” that
has some enhanced functionality, has been frequently considered a fundamental technology enabler in the
blockchain space.4
4 See e.g., https://blockstream.com/technology/ and [1].

Sidechains, introduced in [1], are a way for multiple blockchains to communicate with each other and
have one react to events in the other. Sidechains can exist in two forms. In the ﬁrst case, they are simply a
mechanism for two existingstand-alone blockchains to communicate, in which case any of the two blockchains
can be the sidechain of the other and they are treated as equals. In the second case, the sidechain can be a
“child” of an existing blockchain, the mainchain, in that its genesis block, the ﬁrst block of the blockchain,
is somehow seeded from the parent blockchain and the child blockchain is meant to depend on the parent
blockchain, at least during an initial bootstrapping stage.
A sidechain system can choose to enable certain types of interactions between the participating block-
chains. The most basic interaction is the transfer of assets from one blockchain to another. In this application,
the nature of the asset transferred is retained in that it is not transformed into a diﬀerent class of asset (this
is in contrast to a related but diﬀerent concept of atomic swaps ). As such, it maintains its value and may
also be transferred back. The ability to move assets back and forth between two chains is sometimes referred
to as a 2-way peg. Provided the two chains are both secure as individual blockchains, a secure sidechain
protocol construction allows this security to be carried on to cross-chain transfers.
A secure sidechain system could be of a great value vis-` a-vis all three of the pressing open questions in
blockchain systems mentioned above. Speciﬁcally:
Interoperability. There are currently hundreds of cryptocurrencies deployed in production. Transferring
assets between diﬀerent chains requires transacting with intermediaries (such as exchanges). Furthermore,
there is no way to securely interface with another blockchain to react to events occurring within it. Enabling
sidechains allows blockchains of diﬀerent nature to communicate, including interfacing with the legacy bank-
ing system which can be made available through the use of a private ledger.
Scalability. While sidechains were not originally proposed for scalability purposes, they can be used to
oﬀ-load the load of a blockchain in terms of transactions processed. As long as 2-way pegs are enabled, a
particular sidechain can oﬀer specialization by, e.g., industry, in order to avoid requiring the mainchain to
handle all the transactions occurring within a particular economic sector. This provides a straightforward
way to “shard” blockchains, cf. [25,21,33].
Upgradability. A child sidechain can be created from a parent mainchain as a means of exploring a new
feature, e.g., in the scripting language, or the consensus mechanism without requiring a soft, hard, or velvet
fork [19,34]. The sidechain does not need to maintain its own separate currency, as value can be moved
between the sidechain and the mainchain at will. If the feature of the sidechain proves to be popular, the
mainchain can eventually be abandoned by moving all assets to the sidechain, which can become the new
mainchain.
Given the beneﬁts listed above for distributed ledgers, there is a pressing need to address the question
of sidechain security and feasibility, which so far, perhaps surprisingly, has not received any proper formal
treatment.
Our contributions. First, we formalize the notion of sidechains by proposing a rigorous cryptographic
deﬁnition, the ﬁrst one to the best of our knowledge. The deﬁnition is abstract enough to be able to capture
the security for blockchains based on proof-of-work, proof-of-stake, and other consensus mechanisms.
A critical security feature of a sidechain system that we formalise is the ﬁrewall property in which a
catastrophic failure in one of the chains, such as a violation of its security assumptions, does not make the
other chains vulnerable providing a sense of limited liability.5 The ﬁrewall property formalises and generalises
the concept of a blockchain ﬁrewall which was described in high level in [1]. Informally the blockchain ﬁrewall
5 To follow the analogy with the term of limited liability in corporate law, a catastrophic sidechain failure is akin
to a corporation going bankrupt and unable to pay its debtors. In a similar fashion, a sidechain in which the
security assumptions are violated may not be able to cover all of its debtors. We give no assurances regarding
assets residing on a sidechain if its security assumptions are broken. However, in the same way that stakeholders of
a corporation are personally protected in case of corporate bankruptcy, the mainchain is also protected in case of
sidechain security failures. Our security will guarantee that each incoming transaction from a sidechain will always
have a valid explanation in the sidechain ledger independently of whether the underlying security assumptions are
violated or not. A simple embodiment of this rule is that a sidechain can return to the mainchain at most as many
coins as they have been sent to the sidechain over all time.
2

suggests that no more money can ever return from the sidechain than the amount that was moved into it.
Our general ﬁrewall property allows relying on an arbitrary deﬁnition of exactly how assets can correctly
be moved back and forth between the two chains, we capture this by a so-called validity language . In case
of failure, the ﬁrewall ensures that transfers from the sidechain into the mainchain are rejected unless there
exists a (not necessarily unique) plausible history of events on the sidechain that could, in case the sidechain
was still secure, cause the particular transfers to take place.
Second, we outline a concrete exemplary construction for sidechains for proof-of-stake blockchains. For
conciseness our construction is described with respect to a generic PoS blockchain consistent with the
Ouroboros protocol [20] that underlies the Cardano blockchain, which is currently one of the largest pure
PoS blockchains by market capitalisation, 6 nevertheless we also discuss how to modify our construction to
operate for Ouroboros Praos [13], Ouroboros Genesis [2], Snow White [6] and Algorand [26].
We prove our construction secure using standard cryptographic assumptions. We show that our construc-
tion (i) supports safe cross-chain value transfers when the security assumptions of both chains are satisﬁed,
namely that a majority of honest stake exists in both chains, and (ii) in case of a one-sided failure, maintains
the ﬁrewall property, thus containing the damage to the chains whose security conditions have been violated.
A critical consideration in a sidechain construction is safeguarding a new sidechain in its initial “boot-
strapping” stage against a “goldﬁnger” type of attack [22]. Our construction features a mechanism we call
merged-staking that allows mainchain stakeholders who have signalled sidechain awareness to create sidechain
blocks even without moving stake to the sidechain. In this way, sidechain security can be maintained assum-
ing honest stake majority among the entities that have signaled sidechain awareness that, especially in the
bootstrapping stage, are expected to be a large superset of the set of stakeholders that maintain assets in
the sidechain.
Our techniques can be used to facilitate various forms of 2-way peggings between two chains. As an
illustrative example we focus on a parent-child mainchain-sidechain conﬁguration where sidechain nodes
follow also the mainchain (what we call direct observation) while mainchain nodes need to be able to receive
cryptographically certiﬁed signals from the sidechain maintainers, taking advantage of the proof-of-stake
nature of the underlying protocol. This is achieved by having mainchain nodes maintain suﬃcient information
about the sidechain that allows them to authenticate a small subset of sidechain stakeholders that is suﬃcient
to reliably represent the view of a stakeholder majority on the sidechain. This piece of information is updated
in regular intervals to account for stake shifting on the sidechain. Exploiting this, each withdrawal transaction
from the sidechain to the mainchain is signed by this small subset of sidechain stakeholders. To minimise
overheads we batch this authentication information and all the withdrawal transactions from the sidechain
in a single message that will be prepared once per “epoch.” We will refer to this signaling as cross-chain
certiﬁcation.
In greater detail, adopting some terminology from [20], the sidechain certiﬁcate is constructed by obtaining
signatures from the set of so-called slot leaders of the last Θ(k) slots of the previous epoch, where k is the
security parameter. Subsequently, these signatures will be combined together with all necessary information
to convince the mainchain nodes (that do not have access to the sidechain) that the sidechain certiﬁcate is
valid.
We abstract the notion of this trust transition into a new cryptographic primitive called ad-hoc threshold
multisignatures (ATMS) that we implement in three distinct ways. The ﬁrst one simply concatenates signa-
tures of elected slot leaders. While secure, the disadvantage of this implementation is that the size of the
sidechain certiﬁcate is Θ(k) signatures. An improvement can be achieved by employing multisignatures and
Merkle-tree hashing for veriﬁcation key aggregation; using this we can drop the sidechain-certiﬁcate size to
Θ(r) signatures where r slot leaders do not participate in its generation; in the optimistic case r ≪k and
thus this scheme can be a signiﬁcant improvement in practice. Finally, we show that STARKs and bullet-
proofs [4,10] can be used to bring down the size of the certiﬁcate to be optimally succinct in the random
oracle model. We observe that in the case of an active sidechain (e.g., one that returns assets at least once
per epoch) our construction with succinct sidechain certiﬁcates has optimal storage requirements in the
mainchain.
6 See https://coinmarketcap.com.
3

Related work. Sidechains were ﬁrst proposed as a high level concept in [1]. Notable proposed implemen-
tations of the concept are given in [29,23]. In these works, no formal proof of security is provided and their
performance is sometimes akin to maintaining the whole blockchain within the sidechain, limiting any po-
tential scalability gains. There have been several attempts to create various cross-chain transfer mechanisms
including Polkadot [32], Cosmos [9], Blockstream’s Liquid [14] and Interledger [30]. These constructions dif-
fer in various aspects from our work including in that they focus on proof-of-work or private (Byzantine)
blockchains, require federations, are not decentralized and — in all cases — lack a formal security model and
analysis. Threshold multi-signatures were considered before, e.g., [24], without the ad-hoc characteristic we
consider here. A related primitive that has been considered as potentially useful for enabling proof-of-work
(PoW) sidechains (rather than PoS ones) is a (non-interactive) proof of proof-of-work [18,19]; nevertheless,
these works do not give a formal security deﬁnition for sidechains, nor provide a complete sidechain con-
struction. We reiterate that while we focus on PoS, our deﬁnitions and model are fully relevant for the PoW
setting as well.
2 Preliminaries
2.1 Our Model
We employ the model from [13], which is in turn based on [20] and [17]. The formalization we use below
captures both synchronous and semi-synchronous communication; as well as both semi-adaptive and fully
adaptive corruptions.
Protocol Execution. We divide time into discrete units called slots. Players are equipped with (roughly)
synchronized clocks that indicate the current slot: we assume that any clock drift is subsumed in the slot
length. Each slot slr is indexed by an integer r ∈ {1,2,... }. We consider a UC-style [12] execution of
a protocol Π, involving an environment Z, a number of parties Pi, functionalities that these parties can
access while running the protocol (such as the DDiﬀuse used for communication, described below), and
an adversary A. All these entities are interactive algorithms. The environment controls the execution by
activating parties via inputs it provides to them. The parties, unless corrupted, respond to such activations
by following the protocol Π and invoking the available functionalities as needed.
(Semi-)Adaptive Corruptions. The adversary inﬂuences the protocol execution by interacting with the
available functionalities, and by corrupting parties. The adversary can only corrupt a party Pi if it is given
permission by the environment Zrunning the protocol execution (captured as a special message from Zto
A). Upon receiving permission from the environment, the adversary corrupts Pi after a certain delay of Λ
slots, where Λis a parameter of our model. In particular, ifΛ= 0 we talk aboutfully adaptive corruptions and
the corruption is immediate. The model with Λ >0 is referred to as allowing Λ-semi-adaptive corruptions
(as opposed to the static corruptions model , where parties can only be corrupted before the start of the
execution). A corrupted party Pi will relinquish its entire state to A; from this point on, the adversary will
be activated in place of the party Pi.
(Semi-)Synchronous Communication. We employ the “Delayed Diﬀuse” functionality DDiﬀuse∆ given
in [13] to model (semi-)synchronous communication among the parties. It allows each party to diﬀuse a
message once per round, with the guarantee that it will be delivered to all other parties in at most ∆
slots (the delay within this interval is under adversarial control). The adversary can also read and reorder
all messages that are in transit, as well as inject new messages. We provide a detailed description of the
functionality DDiﬀuse∆ in Appendix A for completeness.
We refer to the setting where honest parties communicate via DDiﬀuse∆ as the ∆-semi-synchronous
setting and sometimes omit ∆ if it is clear from the context. The special case of ∆= 0 is referred to as the
synchronous setting.
4

Clearly, the above model is by itself too strong to allow us to prove any meaningful security guarantees
for the executed protocol without further restrictions (as it, for example, does not prevent the adversary
from corrupting all the participating parties). Therefore, in what follows, we will consider such additional
assumptions, and will only provide security guarantees as long as such assumptions are satisﬁed. These
assumptions will be speciﬁc to the protocol in consideration, and will be an explicit part of our statements. 7
2.2 Blockchains and Ledgers
A blockchain (or a chain) (denoted e.g. C) is a sequence of blocks where each one is connected to the previous
one by containing its hash.
Blockchains (and in general, any sequences) are indexed using bracket notation. C[i] indicates the ith
block, starting from C[0], the genesis block. C[−i] indicates the ith block from the end, with C[−1] being the
tip of the blockchain. C[i : j] indicates a subsequence, or subchain of the blockchain starting from block i
(inclusive) and ending at block j (exclusive). Any of these two indices can be negative. Omitting one of the
two indexes in the range addressing takes the subsequence to the beginning or the end of the blockchain,
respectively. Given blocks A and Z in C, we let C{A : Z}denotes the subchain obtained by only keeping
the blocks from A (inclusive) to Z (exclusive). Again any of these two blocks can be omitted to indicate
a subchain from the beginning or to the end of the blockchain, respectively. In blockchain protocols, each
honest party P maintains a currently adopted chain. We denoteCP[t] the chain adopted by party P at slot t.
A ledger (denoted in bold-face, e.g. L) is a mechanism for maintaining a sequence of transactions, often
stored in the form of a blockchain. In this paper, we slightly abuse the language by lettingL (without further
qualiﬁers) interchangeably refer to the algorithms used to maintain the sequence, and all the views of the
participants of the state of these algorithms when being executed. For example, the (existing) ledger Bitcoin
consists of the set of all transactions that ever took place in the Bitcoin network, the current UTXO set, as
well as the local views of all the participants.
In contrast, we call a ledger state a concrete sequence of transactions tx1,tx2,... stored in the stable
part of a ledger L, typically as viewed by a particular party. Hence, in every blockchain-based ledger L,
every ﬁxed chain C deﬁnes a concrete ledger state by applying the interpretation rules given as a part of the
description of L (for example, the ledger state is obtained from the blockchain by dropping the last k blocks
and serializing the transactions in the remaining blocks). We maintain the typographic convention that a
ledger state (e.g. L) always belongs to the bold-face ledger of the same name (e.g. L). We denote by LP[t]
the ledger state of a ledger L as viewed by a party P at the beginning of a time slot t, and by ˇLP[t] the
complete state of the ledger (at time t) including all pending transactions that are not stable yet. For two
ledger states (or, more generally, any sequences), we denote by ⪯the preﬁx relation.
Recall the deﬁnitions of persistence and liveness of a robust public transaction ledger given in the most
recent version of [17]:
Persistence. For any two honest parties P1,P2 and two time slots t1 ≤t2, it holds LP1 [t1] ⪯ˇLP2 [t2].
Liveness. If all honest parties in the system attempt to include a transaction then, at any slot t after u
slots (called the liveness parameter), any honest party P, if queried, will report tx ∈LP[t].
For a ledger L that satisﬁes persistence at time t, we denote by L∪[t] (resp. L∩[t]) the sequence of
transactions that are seen as included in the ledger by at least one (resp., all ) of the honest parties. Finally,
length(L) denotes the length of the ledger L, i.e., the number of transactions it contains.
2.3 Underlying Proof-of-Stake Protocols
For conciseness we present our construction on a generic PoS protoocol based on Ouroboros PoS [20]. As
we outline in Appendix B, our construction can be easily adapted to other provably secure proof-of-stake
protocols: Ouroboros Praos [13], Ouroboros Genesis [2], Snow White [6], and Algorand [26]. While a full
7 As an example, we will be assuming that a majority of a certain pool of stake is controlled by uncorrupted parties.
5

understanding of all details of these protocols is not required to follow our work (and cannot be provided in
this limited space), an overview of Ouroboros is helpful to follow the main body of the paper. We provide this
high-level overview here, and point an interested reader to Appendix B (or the original papers) for details
on the other protocols.
Ouroboros. The protocol operates (and was analyzed) in the synchronous model with semi-adaptive cor-
ruptions. In each slot, each of the parties can determine whether she qualiﬁes as a so-called slot leader for
this slot. The event of a particular party becoming a slot leader occurs with a probability proportional to
the stake controlled by that party and is independent for two diﬀerent slots. It is determined by a public, de-
terministic computation from the stake distribution and so-called epoch randomness (we will discuss shortly
where this randomness comes from) in such a way that for each slot, exactly one leader is elected.
If a party is elected to act as a slot leader for the current slot, she is allowed to create, sign, and broadcast
a block (containing transactions that move stake among stakeholders). Parties participating in the protocol
are collecting such valid blocks and always update their current state to reﬂect the longest chain they have
seen so far that did not fork from their previous state by too many blocks into the past.
Multiple slots are collected into epochs, each of which contains R ∈N slots. The security arguments
in [20] require R≥10k for a security parameter k; we will consider R= 12k as additional 2 k slots in each
epoch will be useful for our construction. Each epoch is indexed by an index j ∈N. During an epoch j, the
stake distribution that is used for slot leader election corresponds to the distribution recorded in the ledger
up to a particular slot of epoch j−1, chosen in a way that guarantees that by the end of epoch j−1, there is
consensus on the chain up to this slot. (More concretely, this is the latest slot of epoch j−1 that appears in
the ﬁrst 4k out of its total Rslots.) Additionally, the epoch randomness ηj for epoch j is derived during the
epoch j−1 via a guaranteed-output delivery coin tossing protocol that is executed by the epoch slot leaders,
and is available after 10k slots of epoch j−1 have passed.
In our treatment, we will refer to the relevant parts of the above-described protocol as follows:
GetDistr(j) returns the stake distribution SDj to be used for epoch j, as recorded in the chain up to slot
4k of epoch j−1;
GetRandomness(j) returns the randomness ηj for epoch j as derived during epoch j−1;
ValidateConsensusLevel(C) checks the consensus-level validity of a given chain C: it veriﬁes that all block
hashes are correct, signatures are valid and belong to eligible slot leaders;
PickWinningChain(C,C) applies the chain-selection rule: from a set of chains {C}∪C it chooses the longest
one that does not fork from the current chain C more than k blocks in the past;
SlotLeader(U,j,sl, SDj,ηj) determines whether a party U is elected a slot leader for the slot sl of epoch j,
given stake distribution SDj and randomness ηj.
Moreover, the function EpochIndex (resp. SlotIndex) always returns the index of the current epoch (resp.
slot), and the event NewEpoch (resp. NewSlot) denotes the start of a new epoch (resp. slot). Since we use
these functions in a black-box manner, our construction can be readily adapted to PoS protocols with a
similar structure that diﬀer in the details of these procedures.
Ouroboros was shown in [20] to achieve both persistence and liveness under the following assumptions: (1)
synchronous communication; (2) 2R-semi-adaptive corruptions; (3) majority of stake in the stake distribution
for each epoch is always controlled by honest parties during that epoch.
3 Deﬁning Security of Pegged Ledgers
In this section we give the ﬁrst formal deﬁnition of security desiderata for a system of pegged ledgers
(popularly often called sidechains). We start by conveying its intuition and then proceed to the formal
treatment.
We consider a setting where a set of parties run a protocol maintaining n ledgers L1,L2,..., Ln, each
of the ledgers potentially carrying many diﬀerent assets. (This protocol might of course be a combination
6

of subprotocols for each of the ledgers.) For each i∈[n], we denote by Ai the security assumption required
by Li: For example, Ai may denote that there has never been a majority of hashing power (or stake in a
particular asset, on this ledger or elsewhere) under the control of the adversary; that a particular entity (in
case of a centralized ledger) was not corrupted; and so on. We assume that all Ai are monotone in the sense
that once violated, they cannot become true again. Formally, Ai is a sequence of events Ai[t] for each time
slot t that satisfy ¬Ai[t] ⇒¬Ai[t+ 1] for all t.
There is an a priori unlimited number of (types of) assets, each asset representing e.g. a diﬀerent cryp-
tocurrency. For simplicity we assume that assets of the same type are fungible, but our treatment easily covers
also non-fungible assets. We will allow speciﬁc rules of behavior for each asset (called validity languages ),
and each asset behaves according to these rules on each of the ledgers where it is present.
We will ﬁx an operator merge(·) that merges a set of ledger states L= {L1,L2,..., Ln}into a single ledger
state denoted by merge(L). We will discuss concrete instantiations of merge(·) later, for now simply assume
that some canonical way of merging all ledger states into one is given.
Informally, at any point t during the execution, our security deﬁnition only provides guarantees to the
subset Sof ledgers that have their security assumptions Ai[t] satisﬁed (and hence are all considered uncor-
rupted). We require that:
- each ledger in Sindividually maintains both persistence and liveness;
- for each asset A, when looking at the sequence of all A-transactions σ that occurred on the ledgers in
S(sequentialized via the merge operator), there must exist a hypothetical sequence of A-transactions τ
that could have happened on the compromised ledgers, such that the merge of σ and τ would be valid
according to the validity language of A.
We now proceed to formalize the above intuition.
Deﬁnition 1 (Assets, syntactically valid transactions). For an asset A, we denote by TA the valid
transaction set of A, i.e., the set of all syntactically valid transactions involving A. For a ledger L we denote
by TL the set of transactions that can be included into L. For notational convenience, we deﬁne TA,L ≜ TA∩TL.
Let Assets(L) denote the set of all assets that are supported by L. Formally, Assets(L) ≜ {A : TA,L ̸= ∅}.
We assume that each transaction pertains to a particular asset and belongs to a particular ledger, i.e.,
for distinct A1 ̸= A2 and L1 ̸= L2, we have that TA1 ∩TA2 = ∅and TL1 ∩TL2 = ∅. However, our treatment
can be easily generalized to alleviate this restriction.
We now generically characterize the validity of a sequence of transactions involving a particular asset.
This is captured individually for each asset via a notion of an asset’s validity language , which is simply a
set of words over the alphabet of this asset’s transactions. The asset’s validity language is meant to capture
how the asset is mandated to behave in the system. Let ε denote the empty sequence and ∥ represent
concatenation.
Deﬁnition 2 (Asset validity language). For an asset A, the asset validity language of A is any language
VA ⊆T ∗
A that satisﬁes the following properties:
1. Base. ε∈VA.
2. Monotonicity. For any w,w′∈T ∗
A we have w̸∈VA ⇒w∥w′̸∈VA.
3. Uniqueness of transactions. Words from VA never contain the same transaction twice: for any
tx ∈TA and any w1,w2,w3 ∈T ∗
A we have w1 ∥tx ∥w2 ∥tx ∥w3 ̸∈VA.
The ﬁrst condition in the deﬁnition above is trivial, the second one mandates the natural property that if
a sequence of transactions is invalid, it cannot become valid again by adding further transactions. Finally, the
third condition reﬂects a natural “uniqueness” property of transactions in existing implementations. While
not necessary for our treatment, it allows for some simpliﬁcations.
The following deﬁnition allows us to focus on a particular asset or ledger within a sequence of transactions.
7

Deﬁnition 3 (Ledger state projection). Given a ledger state L, we call a projection of L with respect
to a set X(and denote by πX(L)) the ledger state that is obtained from L by removing all transactions not in
X. To simplify notation, we will use πA and πI as a shorthand for πTA and π⋃
i∈ITLi
, denoting the projection
of the transactions of a ledger state with respect to particular asset A or a particular set of individual ledger
indices. Naturally, for a language V we deﬁne the projected language πX(V) := {πX(w) : w∈V}, which
contains all the sequences of transactions from the original language, each of them projected with respect to
X.
The concept of eﬀect transactions below captures ledger interoperability at the syntactic level.
Deﬁnition 4 (Eﬀect Transactions). For two ledgers L and L′, the eﬀect mapping is a mapping of the
form eﬀectL→L′: TL →(TL′∪{⊥}). A transaction tx′= eﬀectL→L′(tx) ̸= ⊥is called the eﬀect transaction
of the transaction tx.
Intuitively, for any transactiontx ∈TL, the corresponding transaction eﬀectL→L′(tx) ∈TL′∪{⊥}identiﬁes
the necessary eﬀect on ledger L′ of the event of the inclusion of the transaction tx into the ledger L. With
foresight, in an implementation of a system of ledgers where a “pegging” exists, the transactioneﬀectL→L′(tx)
has to be eventually valid and includable inL′in response to the inclusion oftx in L. Additionally, throughout
the paper we assume that an eﬀect transaction is always clearly identiﬁable as such, and its corresponding
“sending” transaction can be derived from it; our instantiation does have this property.
We use a special symbol ⊥to indicate that the transaction tx does not necessitate any action on L′(this
will be the case for most transactions). We will now be interested mostly in transactions that do require an
action on the other ledger.
Deﬁnition 5 (Cross-Ledger Transfers). For two ledgers L and L′ and an eﬀect mapping eﬀectL→L′(·),
we refer to a transaction in TL that requires some eﬀect on L′ as a (L,L′)-cross-ledger transfer transaction
(or cross-ledger transfer for short). The set of all cross-ledger transfers is denoted by Tcl
L,L′ ⊆TL, formally
Tcl
L,L′ ≜ {tx ∈TL : eﬀectL→L′(tx) ̸= ⊥}.
Given ledger states L1,L2,..., Ln, we need to consider a joint ordered view of the transactions in all these
ledgers. This is provided by the merge operator. Intuitively, merge allows us to create a combined view of
multiple ledgers, putting all of the transactions across multiple ledgers into a linear ordering. We expect
that even if certain ledgers are missing from its input, merge is still able to produce a global ordering for
the remaining ledgers. With foresight, this ability of the merge operator will enable us to reason about the
situation when some ledgers fail: In that case, the respective inputs to the merge function will be missing.
The merge function deﬁnition below depends on the eﬀect mappings, we keep this dependence implicit for
simpler notation.
Deﬁnition 6 (Merging ledger states). The merge(·) function is any mapping taking a subset of ledger
states L⊆{ L1,L2,..., Ln}and producing a ledger state merge(L) such that:
1. Partitioning. The ledger states in Lare disjoint subsequences of merge(L) that cover the whole sequence
merge(L).
2. Topological soundness.For any i ̸= j such that Li,Lj ∈L and any two transactions tx ∈Li and
tx′∈Lj, if tx′= eﬀectLi→Lj (tx) then tx precedes tx′ in merge(L).
We will require that our validity languages are correct in the following sense.
Deﬁnition 7 (Correctness of VA). A validity language VA is correct with respect to a mapping merge (·),
if for any ledger states L≜ (L1,..., Ln) such that πA (merge (L)) ∈VA, indices i̸= j, and any cross-ledger
transfer tx ∈Li ∩Tcl
Li,Lj such that eﬀectLi→Lj (tx) = tx′̸= ⊥is not in Lj, we have
πA (merge (L1,..., Li,..., Lj∥tx′,..., Ln)) ∈VA .
8

The above deﬁnition makes sure that if a cross-ledger transfer of an asset A is included into some ledger
Li and mandates an eﬀect transaction on Lj, then the inclusion of this eﬀect transaction will be consistent
with VA. Note that this does not yet guarantee that the eﬀect transaction will indeed be included into Lj,
this will be provided by the liveness of Lj required below.
We are now ready to give our main security deﬁnition. In what follows, we call asystem-of-ledgers protocol
any protocol run by a (possibly dynamically changing) set of parties that maintains an evolving state of n
ledgers {Li}i∈[n].
Deﬁnition 8 (Pegging security). A system-of-ledgers protocol Π for {Li}i∈[n] is pegging-secure with
liveness parameter u∈N with respect to:
- a set of assumptions Ai for ledgers {Li}i∈[n],
- a merge mapping merge (·),
- validity languages VA for each A ∈⋃
i∈[n] Assets(Li),
if for all PPT adversaries, all slots t and for St ≜ {i : Ai[t] holds}we have that except with negligible
probability in the security parameter:
Ledger persistence:For each i∈St, Li satisﬁes the persistence property.
Ledger liveness:For each i∈St, Li satisﬁes the liveness property parametrized by u.
Firewall: For all A ∈⋃
i∈St
Assets(Li),
πA (merge ({L∪
i [t] : i∈St})) ∈πSt (VA) .
Intuitively, the ﬁrewall property above gives the following guarantee: If the security assumption of a
particular sidechain has been violated, we demand that the sequence of transactions σ that appears in
the still uncompromised ledgers is a valid projection of some word from the asset validity language onto
these ledgers. This means that there exists a sequence of transactions τ that could have happened on the
compromised ledgers, such that it would “justify” the current state of the uncompromised ledgers as a valid
state. Of course, we don’t know whether this sequence τ actually occurred on the compromised ledger,
however, given that this ledger itself no longer provides any reliable state, this is the best guarantee we can
still oﬀer to the uncompromised ledgers.
Looking ahead, when we deﬁne a particular validity language for our concrete, fungible, constant-supply
asset, we will see that this property will translate into the mainchain maintaining “limited liability” towards
the sidechain: the amount of money transferred back from the sidechain can never exceed the amount of
money that was previously moved towards the sidechain, because no plausible history of sidechain transac-
tions can exist that would justify such a transfer.
4 Implementing Pegged Ledgers
We present a construction for pegged ledgers that is based on Ouroboros PoS [20], but also applicable
to other PoS systems such as Snow White [6] and Algorand [26] (for a discussion of such adaptations, see
Appendix B). Our protocol will implement a system of ledgers with pegging security according to Deﬁnition 8
under an assumption on the relative stake power of the adversary that will be detailed below.
The main challenge in implementing pegged ledgers is to facilitate secure cross-chain transfers. We con-
sider two approaches to such transfers and refer to them as direct observation or cross-chain certiﬁcation.
Consider two pegged ledgers L1 and L2. Direct observation of L1 means that every node of L2 follows and
validates L1; it is easy to see that this enables transfers from L1 to L2. On the other hand, cross-chain
certiﬁcation of L2 means that L1 contains appropriate cryptographic information suﬃcient to validate data
issued by the nodes following L2. This allows transfers of assets from L2, as long as they are certiﬁed, to be
accepted by L1-nodes without following L2. The choice between direct observation and cross-chain certiﬁca-
tion can be made independently for each direction of transfers between L1 and L2, any of the 4 variants is
possible (cf. Figure 1).
9

Another aspect of implementing pegged ledgers in the PoS context is the choice of stake distribution that
underlies the PoS on each of the chains. We again consider two options, which we call independent staking
and merged staking. In independent staking, blocks on say L1 are “produced by” coins from L1 (in other
words, the block-creating rights on L1 are attributed based on the stake distribution recorded on L1 only).
In contrast, with merged staking, blocks on L1 are produced either by coins on L1, or coins on L2 that have,
via their staking key, declared support of L1 (but otherwise remain on L1); see Figure 1. Also here, all 4
combinations are possible.
Fig. 1: Deployment options for PoS Sidechains.
In our construction we choose an exemplary conﬁguration between two ledgers L1 and L2, so that direct
observation is applied to L1, cross-chain certiﬁcation to L2, independent-staking in L1 and merged staking
in L2. As a result, all stakeholders in L2 also keep track of chain development on L1 (and hence run a full
node for L1) while the opposite is not necessary, i.e., L1 stakeholders can be oblivious of transactions and
blocks being added to L2. This illustrates the two basic possibilities of pegging and can be easily adapted
to any other of the conﬁgurations between two ledgers in Figure 1.
In order to reﬂect the asymmetry between the two chains in our exemplary construction we will refer
to L1 as the “mainchain” MC, and to L2 as the “sidechain” SC. To elaborate further on this concrete
asymmetric use case, we also fully specify how the sidechain can be initialized from scratch, assuming that
the mainchain already exists.
The pegging with the sidechain will be provided with respect to a speciﬁc asset of MC that will be
created on MC. Note that MC as well as SC may carry additional assets but for simplicity we will assume
that staking and pegging is accomplished only via this single primary asset.
The presentation of the construction is organized as follows. First, in Section 4.1 we introduce a novel
cryptographic primitive, ad-hoc threshold multisignature (ATMS) , which is the fundamental building block
for cross-chain certiﬁcation. Afterwards, in Section 4.3 we use it as a black box to build secure pegged
ledgers with respect to concrete instantiations of the functions merge and eﬀect and a validity language VA
for asset A given in Section 4.2. Finally, we discuss speciﬁc instantiations of ATMS in Section 5.
4.1 Ad-Hoc Threshold Multisignatures
We introduce a new primitive, ad-hoc threshold multisignatures (ATMS) , which borrow properties from
multisignatures and threshold signatures and are ad-hoc in the sense that signers need to be selected on the
ﬂy from an existing key set. In Section 4.3 we describe how ATMS are useful for periodically updating the
“anchor of trust” that the mainchain parties have w.r.t. the sidechain they are not following.
ATMS are parametrized by a threshold t. On top of the usual digital signatures functionality, ATMS also
provide a way to: (1) aggregate the public keys of a subset of these parties into a single aggregate public
key avk; (2) check that a given avk was created using the right sequence of individual public keys; and (3)
aggregate t′≥t individual signatures from t′ of the parties into a single aggregate signature that can then
be veriﬁed using avk, which is impossible if less than t individual signatures are used.
The deﬁnition of an ATMS is given below.
Deﬁnition 9. A t-ATMS is a tuple of algorithms Π = (PGen,Gen,Sig,Ver,AKey,ACheck,ASig,AVer) where:
10

PGen(1κ) is the parameter generation algorithm that takes the security parameter 1κ and returns system
parameters P.
Gen(P) is the key-generation algorithm that takes Pand produces a public/private key pair (vki,ski) for
the party invoking it.
Sig(ski,m) is the signature algorithm as in an ordinary signature scheme: it takes a private key and a
message and produces a (so-called local) signature σ.
Ver(m,pki,σ) is the veriﬁcation algorithm that takes a public key, a message and a signature and returns
true or false.
AKey(VK) is the key aggregation algorithm that takes a sequence of public keys VK and aggregates them
into an aggregate public key avk.
ACheck(VK,avk) is the aggregation-checking algorithm that takes a public key sequence VKand an aggregate
public key avk and returns true or false, determining whether VKwere used to produce avk.
ASig (m,VK,⟨(vk1,σ1),··· ,(vkd,σd)⟩) is the signature-aggregation algorithm that takes a message m, a
sequence of public keys VKand a sequence of d pairs ⟨(vk1,σ1),··· ,(vkd,σd)⟩where each σi is a local
signature on m veriﬁable by vki and each vki is in a distinct position within VK, ASig combines these
into a multisignature σ that can later be veriﬁed with respect to the aggregate public key avk produced
from VK(as long as d≥t, see below).
AVer(m,avk,σ ) is the aggregate-signature veriﬁcation algorithm that takes a message m, an aggregate public
key avk, and a multisignature σ, and returns true or false.
Deﬁnition 10 (ATMS correctness). Let Π be a t-ATMS scheme initialized with P ←PGen(1κ), let
(vk1,sk1),··· ,(vkn,skn) be a sequence of keys generated via Gen(P), let VKbe a sequence containing (not
necessarily unique) keys from the above and avk be generated by invoking avk ←AKey(VK). Let m be any
message and let ⟨(vk1,σ1),··· ,(vkd,σd)⟩be any sequence of key/signature pairs provided that d ≥t and
every vki appears in a unique position in the sequence VK, where σi is generated as σi = Sig(ski,m). Let
σ←ASig (m,VK,⟨(vk1,σ1),··· ,(vkd,σd)⟩). The scheme Π is correct if for every such message and sequence
the following hold:
1. Ver(m,vki,σi) is true for all i;
2. ACheck(VK,avk) is true;
3. AVer(m,avk,σ ) is true.
We deﬁne the security of an ATMS in the deﬁnition below, via a cryptographic game given in Algorithm 1.
Deﬁnition 11 (Security). A t-ATMS scheme Π = (PGen,Gen,Sig,Ver,AKey,ACheck,ASig,AVer) is secure
if for any PPT adversary A and any polynomial p there exists some negligible function negl such that
Pr[ATMSΠ,A(κ,p(κ)) = 1] <negl(κ) .
The quantity q in the ATMS game counts how many keys the adversary is in control of among her
chosen keys keys which will be used for aggregate-signature veriﬁcation. The sequence keys can contain
both adversarially-generated keys as well as some of the keys VKhonestly generated by the challenger. The
variable q counts the number of adversarially controlled keys in keys. This includes those keys in keys for
which the adversary has obtained a signature for the message in question (through the use of the oracle
Osig(·)) or which the adversary has corrupted completely (through the use of the oracle Ocor(·)), as well as
those keys which have been generated by the adversary herself and therefore are not in VK.
It is straightforward to see that if Π is a secure ATMS, then the tuple ( PGen,Gen,Sig,Ver) is a EUF-
CMA-secure signature scheme.
Looking ahead, note that since theAKey algorithm is only invoked with the public keys of the participants,
it can be invoked by anyone, not just the parties who hold the respective secret keys, as long as the public
portion of their keys is published. Furthermore, notice that the above games allow the adversary to generate
more public/private key pairs of their own and combine them at will.
Having deﬁned the ATMS primitive, we will now describe a sidechain construction that uses it. Concrete
instantiations of the ATMS primitive are presented in Section 5.
11

Algorithm 1 The game ATMSΠ,A
The game is parameterized by a security parameter κ and an integer p(κ).
1: VK← ϵ; SK← ϵ; Qsig ←∅; Qcor ←∅
2: P← PGen(1κ)
3: ( m,σ,avk, keys) ←AOgen,Osig(·,·),Ocor(·) (P)
4: q←0
5: for vk in keys do
6: if vk /∈VK∨ vk ∈Qsig[m] ∪Qcor then
7: q←q+ 1
8: end if
9: end for
10: return AVer(m,avk,σ ) ∧ACheck(keys,avk) ∧q <t
Algorithm 2 The oracle Ogen
1: function Ogen
2: ( vk,sk) ←Gen(P)
3: VK←VK∥ vk
4: SK←SK∥ sk
5: return vk
6: end function
Algorithm 3 The oracle Osig
1: function Osig(i,m)
2: Qsig[m] ←Qsig[m] ∪{VK[i]}
3: return Sig(SK[i],m)
4: end function
Algorithm 4 The oracle Ocor
1: function Ocor(i)
2: Qcor ←Qcor ∪{VK[i]}
3: return SK[i]
4: end function
Fig. 2: The ATMS security game ATMSΠ,A.
4.2 A Concrete Asset A
We now present an example of a simple fungible asset with ﬁxed supply, which we denote A, and describe
its validity language VA. This will be the asset (and validity language) considered in our construction and
proof. While VA is simple and natural, it allows us to exhibit the main features of our security treatment and
illustrate how it can be applied to more complex languages such as those capable of capturing smart contracts;
we omit such extensions in this version. Note that our language is account-based, but a UTXO-based validity
language can be considered in a similar manner.
Instantiating VA. The validity language VA for the asset A considers two ledgers: the mainchain ledger
L0 ≜ MC and the sidechain ledger L1 ≜ SC. For this asset, every transaction tx ∈ TA has the form
tx = (txid,lid,(send,sAcc),(rec,rAcc),v,σ ), where:
– txid is a transaction identiﬁer that prevents replay attacks. We assume that txid contains suﬃcient
information to identify lid by inspection and that this is part of syntactic transaction validation.
– lid ∈{0,1}is the ledger index where the transaction belongs.
– send ∈{0,1}is the index of the sender ledger Lsend and sAcc is an account on this ledger, this is the
sender account. For simplicity, we assume that sAcc is the public key of the account.
– rec ∈{0,1}is the index of the recipient ledger Lrec and rAcc is an account (again represented by a public
key) on this ledger, this is the recipient account. We allow either Lsend = Lrec, which denotes a local
transaction, or Lsend ̸= Lrec, which denotes a remote transaction (i.e., a cross-ledger transfer).
– v is the amount to be transferred.
– σ is the signature of the sender, i.e. made with the private key corresponding to the public key sAcc on
the plaintext (txid,(send,sAcc),(rec,rAcc),v).
The correctness of lid is enforced by the ledgers, i.e., for bothi∈{0,1}the set TA,Li only contains transactions
with lid = i. Note that although we sometimes notationally distinguish between an account and the public
12

key that is associated with it, for simplicity we will assume that these are either identical or can always be
derived from one another (this assumption is not essential for our construction).
The membership-deciding algorithm for VA is presented in Algorithm 5. It processes the sequence of
transactions (tx1,tx2,..., txm) given to it as input in their order. Assuming transactions are syntactically
valid, the function veriﬁes for each transactiontxi the freshness of txid, validity of the signature, and availabil-
ity of suﬃcient funds on the sending account. For an intra-ledger transaction (i.e., one that has send = rec),
these are all the performed checks.
More interestingly, VA also allows for cross-ledger transfers. Such transfers are expressed by a pair of
transactions in which send ̸= rec. The ﬁrst transaction appears in lid = send, while the second transaction
appears in lid = rec. The two transactions are identical except for this change in lid (this is the only
exception to the txid-freshness requirement). Every receiving transaction has to be preceded by a matching
sending transaction. Cross-chain transactions have to, similarly to intra-ledger transactions, conform to laws
of balance conservation.
Note that VA does not require that every “sending” cross-ledger transaction on the sender ledger is
matched by a “receiving” transaction on the receiving ledger. Hence, if the asset A is sent from ledger Lsend
but has not yet arrived on Lrec then validity for this asset is not violated. All the validity language ensures
is that appending the sidechain receive transaction to the rec will eventually be a valid way to extend the
receiving ledger, as long as the sidechain send transaction has been included in send.
Instantiating eﬀectLi→Lj . For the simple assetA outlined above, every cross-ledger transfer is a “sending”
transaction tx with Llid = Lsend ̸= Lrec appearing in Lsend, and its eﬀect transaction is a “receiving” trans-
action tx′ with Llid = Lrec ̸= Lsend in Lrec that is otherwise identical (except for the diﬀerent lid′= 1 −lid).
Hence, we deﬁne eﬀectLsend→Lrec (tx) = tx′exactly for all these transactions and no other.
Instantiating merge(·). It is easy to construct a canonical function merge(·) once we see its inputs not only
as ledger states (i.e., sequences of transactions) but we also exploit the additional structure of the blockchains
carrying those ledgers. The canonical merge of the set of ledger states Lis the lexicographically minimum
topologically sound merge, in which transactions of ledger Li are compared favourably to transactions in Lj
if i<j . However, note that the construction we provide below will work for any topologically sound merge
function.
One can easily observe the following statement.
Proposition 1. The validity language VA is correct (according to Deﬁnition 7) with respect to the merge
function deﬁned above.
4.3 The Sidechain Construction
We now describe the procedures for running a sidechain in the conﬁguration outlined at the beginning of
this section: with independent staking on MC and merged staking on SC; direct observation of MC and
cross-chain certiﬁcation of SC. We describe the sidechain’s creation, maintenance, and the way assets can
be transferred to it and back. The protocol we describe below is quite complex, we hence choose to describe
diﬀerent parts of the protocol in diﬀering levels of detail. This level is always chosen with the intention to
allow the reader to easily ﬁll in the details. A graphical depiction of our construction that can serve as a
reference is given in Figure 3.
Notation. Where applicable, we denote the analogues of the mainchain objects on the sidechain with
an additional overline. In our pseudocode, we use the statement “ post tx to L” to refer to the action of
broadcasting the transaction tx to the maintainers of the ledger L so that they include it in the ledger
eventually as prescribed by the protocol. Unless indicated otherwise, we also denote by MC (resp. SC) the
13

Algorithm 5 The transaction sequence validator (membership-deciding algorithm for VA).
1: function valid-seq(tx)
2: balance ←Initial stake distribution; seen ←∅
3: ⊿ Traverse transactions in order
4: for tx ∈tx do
5: ⊿ Destructure tx into its constituents
6: ( txid,lid,(send,sAcc),(rec,rAcc),v,σ ) ←tx
7: if ¬valid(σ) then
8: return false
9: end if
10: if lid = send then
11: ⊿ Replay protection
12: if seen[txid] ̸= 0 then
13: return false
14: end if
15: ⊿ Law of conservation
16: if balance[send][sAcc] −v <0 then
17: return false
18: end if
19: else
20: ⊿ The case lid = rec ̸= send
21: if seen[txid] ̸= 1 then
22: return false
23: end if
24: ⊿ Cross-ledger validity
25: tx′←eﬀect−1
L(1−lid)→Llid (tx)
26: if tx′has not appeared before then
27: return false
28: end if
29: end if
30: if seen[txid] = 0 then
31: ⊿ Update sender balance when money departs
32: balance[send][sAcc] −= v
33: end if
34: ⊿ Update receiver balance when money arrives
35: if (seen[txid] = 0 ∧send = rec)∨
(seen[txid] = 1 ∧send ̸= rec) then
36: balance[rec][rAcc] += v
37: end if
38: seen[txid]+ = 1
39: end for
40: return true
41: end function
14

31 6 7
MC
epoch jadopt
activation period
epoch jstart
2 4 5SC
stable blocks R - 4k 4k
Fig. 3: Our sidechain construction. Blocks are shown as rectangles. Adjacent blocks connect with straight
lines. Squiggly lines indicate some blocks are omitted. MC is at the top, SC at the bottom. Epochs are sep-
arated by dashed lines. ejadopt is the epoch of ﬁrst signalling; ejstart is the activation epoch. Blocks of interest:
1. The ﬁrst block signalling SC awareness; 2. The SC genesis block; 3. A txsend transaction for a deposit; 4. A
txrec transaction for a deposit; 5. A txsend transaction for withdrawal; 6. A sc cert transaction signalling trust
transition within SC and certifying pending withdrawals; 7. A txrec transaction for withdrawal, certiﬁed in
a sc cert transaction e.g. in block 6.
current ledger state of the ledger MC (resp. SC) as viewed by the party executing the protocol. Similarly,
we denote by CMC (resp. CSC) the currently held chain corresponding to the ledger MC (resp. SC). Hence,
for example MC always represents the state stored in the stable part of the chain CMC.
Helper Transactions and Data. The construction uses a set of helper transactions which can be included
in both blockchains, but do not get reported in the respective ledgers. These helper transactions store the
appropriate metadata which is implementation-speciﬁc and allow the pegging functionality to be maintained.
The transaction types sidechain support, sidechain certiﬁcate, sidechain success and sidechain failure, whose
nature will be detailed later, are of this kind. Moreover, our concrete implementation of pegged ledgers
extends certain transactions with additional information (such as Merkle-tree inclusion proofs) that are, for
convenience, understood to be stripped oﬀ these transactions when the blockchain is interpreted as a ledger.
Initialisation. The creation of a new sidechain SC starts by any of the stakeholders of the mainchain
adopting the code that implements the sidechain. This action does not require the stakeholders to put stake
on the sidechain but merely to run the code to support it (e.g. by installing a pluggable module into their
client software). In the following this is referred to as “adopting the sidechain” and captured by the predicate
SidechainAdoption. The adoption is announced at the mainchain by a special transaction detailed below. Each
sidechain is identiﬁed by a unique identiﬁer idSC.
Let jadopt denote the epoch on MC when the ﬁrst adoption transaction has appeared; the sidechain SC –
if its activation succeeds as discussed below – will start at the beginning of some later epochjstart and will have
its slots and epochs synchronized with MC. The software module implementing the sidechain comes with a
set of deterministic rules describing the requirements for the successful activation of the sidechain, as well
as for determining jstart. These rules are sidechain-speciﬁc and are captured in a predicate ActivationSuccess
and a function ActivationEpoch, respectively. One typical such example is the following: the sidechain starts
at the beginning of MC-epoch jstart for the smallest jstart that satisﬁes: (i) jstart −jadopt > c1; (ii) at least
c2-fraction of stake on MC is controlled by stakeholders that have adopted SC; for some constants c1,c2.
Additionally, if such a successful activation does not occur until a failure condition captured by a predicate
ActivationFailure is met (e.g. until a predetermined period of c3 > c1 epochs has passed), the sidechain
initialization is aborted.
15

The activation process then follows the steps outlined below, the detailed description is given in Algo-
rithm 6).
Algorithm 6 Sidechain initialisation procedures.
The algorithm is run by every stakeholder U that adopted the sidechain. We denote by (vk,sk) its public and private
keys.
1: upon SidechainAdoption(idSC) do
2: sidechain state[idSC] ←initializing
3: ( vk′,sk′) ←Gen(P)
4: σ←Sigsk(sidechain support,idSC,vk,vk ′)
5: post (sidechain support,idSC,vk,vk ′,σ) to MC
6: end upon
7: upon MC.NewEpoch() do
8: j ←MC.EpochIndex()
9: if sidechain state[idSC] = initializing then
10: if ActivationFailure() then
11: sidechain state[idSC] ←failed
12: post sidechain failure(idSC) to MC
13: else ifActivationSuccess() then
14: sidechain state[idSC] ←initialized
15: jstart ←ActivationEpoch()
16: Post sidechain success(idSC) to MC
17: end if
18: end if
19: if sidechain state[idSC] = initialized ∧j = jstart then
20: ¯ ηjstart ←H(idSC,ηjstart )
21: VKjstart ←2k last slot leaders of ejstart in SC
22: avkjstart ←AKey(VKjstart )
23: G ←
(
idSC,SDjstart ,¯ηjstart ,P,avkjstart
)
24: CSC ←(G)
25: end if
26: end upon
First, every stakeholder Ui of MC (holding a key pair (vk,sk)) that supports the sidechain posts a special
transaction (sidechain support,idSC,vk,vk ′), signed by sk into the mainchain. Here vk′is a public key from
an ATMS key pair freshly generated by Ui; its role is explained in Section 4.3 below.
If the sidechain activation succeeds, then during the ﬁrst slot of epoch jstart the stakeholders of MC that
support SC construct the genesis block G = (idSC,SDjstart ,¯ηjstart ≜ H(idSC,ηjstart ),P,avkjstart ) for SC. ηjstart is
the randomness for leader election on MC in epoch jstart (derived on MC in epoch jstart −1). It is reused to
compute the initial sidechain randomness ¯ηjstart as well, further ¯ηj′ for j′>jstart are determined independently
on SC using the Ouroboros coin-tossing protocol. 8 Furthermore, Pand avkjstart are public parameters and
an aggregated public key of an ATMS scheme; their creation and role is discussed in Section 4.3 below. Note
that G is deﬁned mostly for notational compatibility, as SDjstart is empty at this point anyway. G can be
constructed as soon as ηjstart is known and stable.
The stakeholders that adopted SC post into MC a transaction sidechain success(idSC) to signify that
SC has been initialized. If the sidechain creation expires, then, after the ﬁrst block of the next epoch after
expiration occurs, the stakeholders of MC that supported SC post the transaction sidechain failure(idSC) to
MC. We assume that both predicates ActivationSuccess and ActivationFailure can be evaluated based on the
state of MC only, and hence spurious success/failure transactions will be considered invalid.
8 This can be interpreted as using MC to implement the setup functionality needed to bootstrap SC.
16

Maintenance. Once the sidechain is created, both the mainchain and the sidechain need to be maintained
by their respective set of stakeholders (detailed below) running their respective instance of the Ouroboros
protocol.
In the case of the mainchain, the maintenance procedure is given in Algorithm 7. This algorithm is run
by all stakeholders controlling stake that is recorded on the mainchain. Each stakeholder, on every new slot,
collects all the candidate MC-chains from the network (modelled via the Diﬀuse functionality) and ﬁlters
them for both consensus-level validity (usingMC.ValidateConsensusLevel) and transaction validity (using the
verifierMC predicate given in Algorithm 8). Out of the remaining valid chains, he chooses his new state
CMC via PickWinningChain. Then the stakeholder evaluates whether he is an eligible leader for this slot,
basing its selection on the stake distribution SDj and randomness ηj, which are determined once per epoch
in accordance with the Ouroboros protocol. If the stakeholder ﬁnds out he is a slot leader, he creates a new
block Bby including all transactions currently valid with respect toCMC (as per the predicate verifytxMC
given also in Algorithm 8), appends it to the chain CMC and diﬀuses the result 9 for other parties to adopt.
Algorithm 7 Mainchain maintenance procedures.
The algorithm is run by every stakeholder U with stake on MC in every epoch j ≥jstart, sk denotes the secret key
of U. An analogous mainchain-maintaining procedure was running also before jstart and is omitted.
1: upon MC.NewSlot() do
2: sl←MC.SlotIndex()
3: ⊿ First slot of a new epoch
4: if sl mod R= 1 then
5: j ←MC.EpochIndex()
6: SDj ←MC.GetDistr(j)
7: ηj ←MC.GetRandomness(j)
8: end if
9: C← chains received via Diﬀuse
10: ⊿ Consensus-level validation
11: Cvalid ←Filter(C,MC.ValidateConsensusLevel)
12: ⊿ Transaction-level validation
13: Cvalidtx ←Filter(Cvalid,verifierMC(·))
14: ⊿ Apply chain selection rule
15: CMC ←MC.PickWinningChain(CMC,Cvalidtx)
16: ⊿ Decide slot leadership based on SDj and ηj
17: if MC.SlotLeader(U,j,sl, SDj,ηj) then
18: prev ←H(CMC[−1])
19: txstate ←transaction sequence in CMC
20: tx ←current transactions in mempool
21: txvalid ←verifytxMC(txstate ∥tx)[|txstate|:]
22: σ←Sigsk(prev,txvalid)
23: B←(prev,txvalid,σ)
24: CMC ←CMC ∥B
25: Diﬀuse(CMC)
26: end if
27: end upon
The maintenance procedure for SC is similar, hence we only describe here how it diﬀers from Algorithm 7.
Most importantly, it is executed by all stakeholders who have adopted SC, irrespectively of whether they
own any stake on SC. Recall that the slots and epochs of the SC-instance of Ouroboros are aligned with
the slots and epochs of MC.
9 As in [20,13], we simplify our presentation by diﬀusing the complete chains, although a practical implementation
would only diﬀuse the block B.
17

Algorithm 8 The MC veriﬁer.
1: function verifytxMC(tx)
2: bal ←initial stake; avk ←initial aggregate key
3: seen ←∅; pool ←0; pfs mtrs ←∅; pfs used ←∅
4: for tx ∈tx do
5: if type(tx) = sc cert then
6: ( m,σ) ←tx
7: if ¬AVer(m,avk,σ ) then
8: continue
9: end if
10: ( txs root,avk′) ←m
11: avk ←avk′
12: pfs mtrs[txs root] ←true
13: else
14: ( txid,lid,(send,sAcc),(rec,rAcc),v,σ ) ←tx
15: m←(txid,lid,(send,sAcc),(rec,rAcc),v)
16: if ¬Ver(m,sAcc,σ) ∨seen[txid] ̸= 0 then
17: continue
18: end if
19: if lid = send then
20: if bal[sAcc] −v <0 then
21: continue
22: end if
23: bal[sAcc] −= v
24: else ifsend ̸= rec then
25: π←tx.π
26: ( mtr,inclusion pf) ←π
27: if π∈pfs used ∨mtr̸∈pfs mtrs∨¬mtr-ver(mtr,inclusion pf) then
28: continue
29: end if
30: end if
31: if lid = rec then
32: bal[rAcc] += v
33: end if
34: if send ̸= rec then
35: if lid = send then
36: pool −= v
37: else
38: pool += v
39: end if
40: end if
41: end if
42: seen ←seen ∥tx
43: end for
44: return seen
45: end function
46: function verifierMC(Cmc)
47: tx ←∅
48: for B ∈Cmc do
49: for tx ∈B do
50: tx ←tx ∥tx
51: end for
52: end for
53: return tx ̸= verifytxMC(tx)
54: end function
18

Algorithm 9 The SC transaction veriﬁer.
1: function verifytxSC(tx)
2: bal[MC] ←Initial MC stake
3: bal[SC] ←Initial SC stake
4: mc outgoing tx ←∅; seen ←∅
5: for tx ∈tx do
6: ( txid,lid,(send,sAcc),(rec,rAcc),v,σ,t ) ←tx
7: m←(txid,lid,(send,sAcc),(rec,rAcc),v)
8: if ¬Ver(sAcc,m,σ ) ∨seen[txid] ̸= 0 then
9: continue
10: end if
11: if lid = send then
12: if bal[send][sAcc] −v <0 then
13: continue
14: end if
15: if lid = MC ∧send ̸= rec then
16: mc outgoing tx[txid] ←t+ 2k
17: end if
18: end if
19: if lid = rec then
20: if send ̸= rec then
21: ⊿ Eﬀect pre-image tx immature
22: if t< mc outgoing tx[txid] then
23: continue
24: end if
25: end if
26: bal[rec][rAcc] += v
27: end if
28: if lid = send then
29: bal[send][sAcc] −= v
30: end if
31: seen ←seen ∥tx
32: end for
33: return seen
34: end function
Algorithm 10 The SC veriﬁer.
1: function verifierSC(Csc,Cmc)
2: tx ←annotatetxSC(Csc,Cmc)
3: return tx ̸= verifytxSC(tx)
4: end function
Algorithm 11 The SC transaction annotation.
1: function annotatetxSC(Csc,Cmc)
2: tx ←∅
3: for each time slot t do
4: tx′←ϵ
5: if Csc has a block generated at slot t then
6: B ←the block in Csc generated at t
7: for tx ∈B do
8: tx′←tx′∥tx
9: end for
10: end if
11: if Cmc has a block generated at slot t then
12: B ←the block in Cmc generated at t
13: for tx ∈B do
14: tx′←tx′∥tx
15: end for
16: end if
17: for tx ∈tx′do
18: ⊿ Mark the time of each tx in tx′
19: tx.t←t
20: end for
21: tx ←tx ∥tx′
22: end for
23: return tx
24: end function
The ﬁrst diﬀerence is that all ocurrences of MC and CMC are naturally replaced by SC and CSC,
respectively. This also means that the validity of received chains (resp. transactions), determined on line 13
(resp. 21), is decided based on predicate verifierSC(·,CMC) (resp. verifytxSC(·)) instead of the predicate
verifierMC(·) (resp. verifytxMC(·)). Additionally, note that verifytxSC must be called with a sequence
of transactions containing both the transactions in SC as well as the transactions in MC interspersed and
timestamped, similarly to the way done in Line 2 of Algorithm 10. This is straightforward to implement, as
the sidechain maintainers also directly observe the mainchain. The predicates verifytxSC and verifierSC
are given in Algorithms 9 and 10, respectively.
Second, instead of the stake distribution SDj determined on line 6, a diﬀerent distribution SD
∗
j is deter-
mined to be used for slot leader selection in the j-th epoch of the sidechain. The distribution SD
∗
contains all
stake belonging to stakeholders that have adopted SC, irrespectively of whether this stake is located on MC
or SC (we call such stake SC-aware). It can be obtained by combining the distribution SD as recorded in SC
with the distribution of SC-aware stake on MC (which is known to SC-maintainers via direct observation
of MC). Note that the distribution used for epoch j reﬂects the stake distribution of SC-aware stake in the
19

past, namely by slot 4k of epoch j−1, just as in MC. Naturally, this also implies that the fourth parameter
for the SlotLeader predicate on line 17 is SD
∗
j instead of SDj.
Finally, the block construction procedure on line 23 is adjusted so that in the last 2 k slots of each epoch,
the created blocks on the sidechain also contain an additional ATMS signature of a so-called sidechain certiﬁ-
cate (how this certiﬁcate is constructed and used will be described below). Hence, wheneversl mod R> 10k,
line 23 is replaced by B ←(prev,txvalid,σ,σsc certj+1 ) where σsc certj+1 = Sigsk(sc certj+1) and j is the current
epoch index.
Depositing to SC. Once SC is initialized, cross-chain transfers to it can be made from MC. A cross-
chain transfer operation in this case consists of two transactions txsend and txrec that both have send = MC,
rec = SC, and all other ﬁelds are also identical, except that each txi for i∈{send,rec}contains lid = i. The
sending transaction txsend is meant to be included in MC, while the receiving transaction txrec is meant to
be included in SC.
Whenever a stakeholder on MC that has adopted SC wants to transfer funds to SC, she diﬀuses txsend
with the correct receiving account on SC and the desired amount. Honest slot leaders in MC include these
transactions into their blocks just like any intra-chain transfer transactions. Maintainers ofMC keep account
of a variable poolSC, initially set to zero. Whenever a txsend is included into MC, they increase poolSC by
the amount of this transaction.
When txsend becomes stable in MC (i.e., appears in MC, this happens at most 2kslots after its inclusion),
the stakeholder creates and diﬀuses the corresponding txrec which credits the respective amount of coins to
rAcc in SC, to be included into SC. In practice, this is akin to a coinbase transaction, as the money was not
transferred from an existing SC account.
Note that depositing from MC to SC is relatively fast; it merely requires a reliable inclusion of txsend into
MC and consequently of txrec into SC, as guaranteed by the liveness of the underlying Ouroboros instances.
The depositing algorithm code is shown in Algorithm 12.
Algorithm 12 Depositing from MC to SC.
The algorithm is run by a stakeholder U in control of the secret key sk corresponding to the account sAcc on MC.
1: function Send(sAcc,rAcc,v) ⊿ Send v from sAcc on MC to rAcc on SC
2: txid
$
←{0,1}k
3: σ←Sigsk(txid,MC,(MC,sAcc),(SC,rAcc),v)
4: txsend ←(txid,MC,(MC,sAcc),(SC,rAcc),v,σ )
5: post txsend to MC
6: end function
7: function Receive(txid,sAcc,rAcc,v)
8: wait untiltxsend ∈MC ⊿ MC is the stable part of MC
9: σ←Sigsk(txid,SC,(MC,sAcc),(SC,rAcc),v)
10: txrec ←(txid,SC,(MC,sAcc),(SC,rAcc),v,σ )
11: post txrec to SC
12: end function
Withdrawing to MC. The withdrawal operation is more cumbersome than the depositing operation since
not all nodes of MC have adopted (i.e., are aware of and follow) the sidechain SC. As transactions, the
withdrawals have the same structure as deposits, consisting of txsend and txrec, with the only diﬀerence that
now they both have send = SC and rec = MC. The sending transaction will be handled in the same way
as in the case of deposits, but the receiving transaction requires a diﬀerent certiﬁcate-based treatment, as
detailed below.
20

Whenever a stakeholder in SC wishes to withdraw coins from SC to MC, she creates and diﬀuses the
respective transaction txsend with the correct transfer details as before. If txsend is included in a block that
belongs in one of the ﬁrst R−4k slots of some epoch then let jsend denote the index of this epoch, otherwise
let jsend denote the index of the following epoch. The stakeholder then waits for the end of the epoch ejsend
to pass and ejsend+1 to begin.
At the beginning of ejsend+1, a special transaction called sidechain certiﬁcate sc certjsend+1 is generated by
the maintainers of SC. It contains: (i) a Merkle-tree commitment to all withdrawal transactions txsend that
were included into SC during last 4kslots of epoch jsend −1 and the ﬁrst R−4kslots of epoch jsend (as these
all are already stable by slot R−2k of epoch jsend); (ii) other information allowing the maintainers of MC
to inductively validate the certiﬁcate in every epoch. The construction of sc cert is detailed below, for now
assume that the transaction provides a proof that the included information about withdrawal transactions is
correct. The transaction sc cert is broadcast into the MC network to be included into MC at the beginning
of ejsend+1 by the ﬁrst honest slot leader.
The stakeholder who wishes to withdraw their money into MC now creates and diﬀuses the transaction
txrec to be included in MC. This transaction is only included into MC if it is considered valid, which means:
(1) it is properly signed; (2) it contains a Merkle inclusion proof conﬁrming its presence in some already
included sidechain certiﬁcate; (3) its amount is less or equal to the current value of poolSC. If included,
MC-maintainers decrease the value of poolSC by the amount of this transaction. The code of the withdrawal
algorithm is illustrated in Algorithm 13.
Algorithm 13 Withdrawing from SC to MC.
The algorithm is run by a stakeholder U in control of the secret key sk corresponding to the account sAcc on SC.
1: function Send(sAcc,rAcc,v) ⊿ Send v from sAcc on SC to rAcc on MC
2: txid
$
←{0,1}k
3: σ←Sigsk(txid,SC,(SC,sAcc),(MC,rAcc),v)
4: txsend ←(txid,SC,(SC,sAcc),(MC,rAcc),v,σ )
5: post txsend to SC
6: end function
7: function Receive(txid,sAcc,rAcc,v)
8: wait untiltxsend ∈CSC
9: j′←epoch where CSC contains txsend
10: if (txsend included in slot sl≤R−4 of ej′) then
11: jsend ←j′
12: else
13: jsend ←j′+ 1
14: end if
15: wait untilsc certjsend+1 ∈CMC
16: π←Merkle-tree proof of txsend in sc certjsend+1
17: σ←Sigsk(txid,MC,(SC,sAcc),(MC,rAcc),v,π )
18: txrec ←(txid,MC,(SC,sAcc),(MC,rAcc),v,π,σ )
19: post txrec to MC
20: end function
The certiﬁcate transaction. We now describe the construction of the sc cert transaction, also called the
sidechain certiﬁcate, formally described in Algorithm 14). The role of the certiﬁcate produced by the end
of epoch j −1 to be included in MC at the beginning of epoch j (denoted sc certj) is to attest all the
withdrawals that had their sending transactions included into SC in either the last 4 k slots of ej−2 or the
ﬁrst R−4k slots of ej−1. To maintain a chain of trust for the MC maintainers that cannot verify these
transactions by observing SC, we make use of ad-hoc threshold multisignatures introduced in Section 4.1.
21

Algorithm 14 Constructing sidechain certiﬁcate sc cert.
The algorithm is run by every SC-maintainer at the end of each epoch, j denotes the index of the ending epoch.
1: function ConstructSCCert(j)
2: T ←last 4k slots of ej−1 and ﬁrst R−4k slots of ej
3: tx ←transactions included in SC during T
4: pendingj+1 ←{tx ∈tx : tx.send ̸= tx.rec}
5: VKj+1 ←keys of last 2k SC slot leaders in ej+1
6: avkj+1 ←AKey(VKj+1)
7: m←
(⟨
pendingj+1
⟩
,avkj+1)
8: VKj ←keys of last 2k SC slot leaders for ej
9: σj+1 ←ASig
(
m,{(vki,σi)}d
i=1 ,VKj
)
10: sc certj+1 ←(
⟨
pendingj+1
⟩
,avkj+1,σj+1)
11: return sc certj+1
12: end function
Namely, the sc certj transaction also contains an aggregate key avkj of an ATMS, and is signed by the
previous aggregate key avkj−1 included in sc certj−1.
sc certj is generated by SC-maintainers and contains:
– The epoch index j.
– The pending transactions from SC to MC. Let tx be the sequence of all transactions which are
included in SC during either the last 4kslots of ej−2 or the ﬁrst R−4kslots of ej. All transactions in tx
that have SC = send ̸= rec = MC are picked up and combined into a list pendingj (sorted in the same
order as in SC). Let
⟨
pendingj
⟩
denote a Merkle-tree commitment to this list.
– The new ATMS key avkj. The key is created from the public keys of the slot leaders of the last 2 k
slots of the epoch j, using threshold k+1. Hence, it allows to verify whether a particular signature comes
from k+ 1 out of these 2 k keys.
– Signature valid with respect to avkj−1.
The full sc certj is therefore a tuple
(
j,⟨pendingj⟩,avkj,σj
)
, where σj is an ATMS signature on the preceding
elements that veriﬁes using avkj−1.
The certiﬁcate sc certj+1 is constructed as follows: Both the stake distribution SD
∗
j+1 and the SC-
randomness ¯ηj+1 (and hence also the slot leader schedule for SC in epoch j+1) are determined by the states
of the blockchains MC and SC by the end of slot 10 k of epoch j. Therefore, during the last 2 k slots of
epoch j, the 2k elected slot leaders for these slots can already include a (local) signature on (their proposal
of) sc certj+1 into the blocks they create. Given the deterministic construction of sc certj+1, all valid blocks
ending up in the part of SC-chain belonging to the last 2 k slots of epoch j will contain a local signature on
the same sc certj+1, and by the chain growth property of the underlying blockchain, there will be at least
k+ 1 of them. Therefore, any party observing SC can now combine these signatures into an ATMS that can
be later veriﬁed using the ATMS key avkj, it can hence create the complete certiﬁcate sc certj+1 and serve
it to the maintainers of MC for inclusion.
Transitioning trust. As already outlined above, our construction uses ATMS to maintain the authenticity
of the sidechain certiﬁcates from epoch to epoch. We now describe this inductive process in greater detail.
Initially, during the setup of the sidechain, P ←PGen(1κ) is ran. Stakeholders generate their keys by
invoking (ski,vki) ←Gen(P). In case Gen(·) is a probabilistic algorithm, it is run in a derandomized fashion
with its coins ﬁxed to the output of a PRNG that is seeded byH(ats init,ηjstart ) where “ats init” is a ﬁxed label
and H is a hash function. This ensures that Pwill be uniquely determined and will still be unpredictable. We
note that this process is only suitable for ATMS that employ public-coin parameters; our ATMS constructions
in Section 5 are only of this type.
22

For the induction base, Pis published as part of the Genesis block G. Each time an MC stakeholder
Ui posts the sidechain support message to MC, he also includes an ATMS key vki. Subsequently, when the
SC is initialised, the stake distribution SD
∗
jstart is known to the MC participants. Hence, based on SD
∗
jstart
and ¯ηjstart , these can determine the last 2 k slot leaders of epoch jstart in SC, we will refer to them as the
jstart-th trust committee. (In general, the j-th trust committee for j ≥jstart will be the set of last 2 k slot
leaders in epoch j.) SC-maintainers (that also follow MC) can also determine the jstart-th trust committee
and therefore create avkjstart from their public keys and insert it into the genesis block G of SC. They can
also serve it as a special transaction to the MC-maintainers to include into the mainchain. The correctness
of avkjstart can be readily veriﬁed by anyone following the mainchain using the procedure ACheck of the used
ATMS.
For the induction step, consider an epoch j > jstart and assume that there exists an ATMS key of the
previous epoch avkj−1, known to the mainchain maintainers. Every honest SC slot leader among the last
2k slot leaders of SC epoch j−1 will produce a local signature sj
i on the message m= (j,⟨pendingj⟩,avkj)
using their private key skj−1
i by running Sig(skj−1
i ,m), and include this signature into the block they create.
The rest of the SC maintainers will verify that the epoch index, avkj and ⟨pendingj⟩are correct (by ensuring
ACheck(VKj,avkj) is true for VKdenoting the public keys of the last 2kslot leaders on SC for epoch j, and
by recomputing the Merkle tree commitment ⟨pendingj⟩) and that sj
i is valid by running Ver(m,vkj−1
i ,sj
i),
otherwise the block is considered invalid. Thanks to the chain growth property of the underlying Ouroboros
protocol, after the last 2 k slots of epoch j−1 the honest sidechain maintainers will all observe at least k+ 1
signatures among the {sj
i : i ∈[2k]}desired ones. They then combine all of these local signatures into an
aggregated ATMS signature σj ←ASig(m,{(sj
i,vkj−1
i )},keysj). This combined signature is then diﬀused as
part of sc certj on the mainchain network. The mainchain maintainers verify that it has been signed by the
sidechain maintainers by checking that AVer(m,avkj−1,σj) evaluates to true and include it in a mainchain
block. This eﬀectively hands over control to the new committee.
5 Constructing Ad-Hoc Threshold Multisignatures
In this section we give several ways to instantiate the ATMS primitive. We order them by increasing succinct-
ness but also increasing complexity. We defer full proofs that our constructions satisfy ATMS correctness
and security (as per Deﬁnitions 10 and 11) to later versions of this paper.
5.1 Plain ATMS
Given a EUF-CMA-secure signature scheme, combining signatures and keys can be implemented by plain
concatenation. Subsequently, combined veriﬁcation requires all signatures to be veriﬁed individually. This
illustrates that the ATMS primitive is easy to realize if no concern is given to succinctness. The size of these
aggregate signatures and aggregate keys is quadratic in the security parameter κ: for the aggregate key 2 k
individual keys of size κ bits each are concatenated (with k= Θ(κ)), while the aggregate signature consists
of at least k+ 1 individual signatures of size κ bits.
5.2 Multisignature-based ATMS
The previous construction can be improved by employing an appropriate multisignature scheme. In the
construction below, we consider the multisignature scheme ΠMGS from [8]. We make use of a homomorphic
property of this scheme: any d individual signatures σ1,...,σ d created using secret keys belonging to (not
necessarily unique) public keys vk1,...,vk d can be combined into a multisignature σ = ∏d
i=1 σi that can
then be veriﬁed using an aggregated public key avk = ∏d
i=1 vki.
Our multisignature-based t-ATMS construction works as follows: the procedures PGen, Gen, Sig and Ver
work exactly as in ΠMGS. Given a set S, denote by ⟨S⟩a Merkle-tree commitment to the set S created in
some arbitrary, ﬁxed, deterministic way. Procedure AKey, given a sequence of public keys VK= {vki}n
i=1
23

returns avk = (∏n
i=1 vki,⟨VK⟩). Since AKey is deterministic, ACheck(VK,avk) simply recomputes it to verify
avk. ASig takes the message m, dpairs of signatures with their respective public keys {σi,vki}d
i=1 and n−d
additional public keys {ˆvki}n−d
i=1 and produces an aggregate signature
σ=
( d∏
i=1
σi,{ˆvki}n−d
i=1 ,{πˆvki
}n−d
i=1
)
(1)
where πˆvki
denotes the (unique) inclusion proof of ˆvki in the Merkle commitment
⣨
{vki}d
i=1 ∪{ˆvki}n−d
i=1
⟩
.
Finally, the procedure AVer takes a message m, an aggregate key avk, and an aggregate signature σ parsed
as in (1), and does the following: (a) veriﬁes that each of the public keys ˆvki indeed belongs to a diﬀerent leaf
in the commitment ⟨VK⟩in avk using membership proofs πˆvki
; (b) computes avk′by dividing the ﬁrst part
of avk by ∏n−d
i=1
ˆvki; (c) returns true if and only if d≥t and the ﬁrst part of σ veriﬁes as a ΠMGS-signature
under avk′.
Note that the scheme ΠMGS requires vki to be accompanied by a (non-interactive) proof-of-possession
(POP) [28] of the respective secret key. This POP can be appended to the public key and veriﬁed when the
key is communicated in the protocol. For conciseness, we omit these proofs-of-knowledge from the description
(but we include them in the size calculation below).
Asymptotic Complexity. This provides an improvement in our use case over the plain scheme: In the optimistic
case where each of the 2 k committee members create their local signatures, both the aggregate key avk and
the aggregate signature σ are linear in the security parameter, which is optimal. If r<k of the keys do not
provide their local signatures, the construction falls back to being quadratic in the worst case if r = k−1.
However, for the practically relevant case where r≪k and almost all slot leaders produced a signature, this
construction is clearly preferable.
Concrete space requirements. Concrete signature sizes in this scheme for practical parameters could be as
follows. We set k = 2160 (as is done in the Cardano implementations of [20]) and for the signature of [8]
we have in bits: |vki|= 272, |σi|= 528 (N. Di Prima, V. Hanquez, personal communication, 16 Mar 2018),
with |vki + POP|= |vki|+ |σi|= 800 bits. Assuming 256-bit hash function is used for the Merkle tree
construction, the size of the data which needs to be included in MC in the optimistic case during an epoch
transition is |avk|+ |σ|+ |⟨pending⟩|= |vki+ POP|+ 2|H(·)|+ |σi|= 800 + 512 + 528 = 1840 bits per epoch.
In a case where 10% of participants fail to sign, the size will be |avk|+ |σ|= |vki+ POP|+ 2|H(·)|+ |σi|+
0.1 ·2 ·k(|vki+ POP|+ log(k)|H(·)) = 800 + 512 + 528 + 432·(500 + 12·256) = 1544944, or about 190 KB
per epoch (which is approximately 5 days).
5.3 ATMS From Proofs of Knowledge
While the aggregate signatures construction seems suﬃcient for practice, it still requires a sc cert transaction
that is in the worst case quadratic in the security parameter. The approach below, based on proofs of
knowledge, improves on that.
We deﬁne avk ←AKey(VK) to be the root of a Merkle tree that has VKat its leaves. Let Sig,Ver come
from any secure signature scheme. In our ATMS, the local signature is equal to si = Sig(ski,m), where ski
is the secret key that corresponds to the vki veriﬁcation key. Letting S′= {si}be the signatures generated
by a sequence VK′containing keys in VK, the ASig(VK,S′,m) algorithm reconstructs the Merkle tree from
VKand determines the membership proof πi for each vki ∈VK′. Regarding the non-interactive argument
of knowledge, the statement of interest is ( avk,m) with witness {πi,(si,vki)}i∈S′ such that for all i we
have that Ver(vki,m,s i) = 1 and πi is a valid Merkle tree proof pointing to a unique leaf for every i. πi
demonstrates that vki is in avk. We also require |S′|≥ t. It is possible to construct succinct proofs for this
statement using SNARKs [7] or even without any trusted setup using e.g., STARKs [4] or Bulletproofs [10]
in the Random Oracle model [3]. In both cases the actual size of the resulting signature will be at most
logarithmic in k, while in the case of STARKs the veriﬁer will also have time complexity logarithmic in k.
24

6 Security
In this section we give a formal argument establishing that the construction from Section 4 achieves pegging
security of Deﬁnition 8.
6.1 Assumptions
Let Ahm(L)[t] denote the honest-majority assumption for an Ouroboros ledger L. Namely, Ahm(L)[t] postu-
lates that in all slots t′≤t, the majority of stake in the stake distribution used to sample the slot leader for
slot t′in L is controlled by honest parties (note that the distribution in question is SD and SD
∗
for MC and
SC, respectively). Speciﬁcally, the adversary is restricted to (1 −ϵ)/2 relative stake for some ﬁxed ϵ> 0.
The assumption AMC we consider for MC is precisely AMC[t] ≜ Ahm(MC)[t], while the assumption
ASC for SC is ASC[t] ≜ AMC[t] ∧Ahm(SC)[t]. The reason that ASC[t] ⇒AMC[t] is that SC uses merged
staking and hence cannot provide any security guarantees if the stake records on MC get corrupted. It is
worth noting that it is possible to program SC to wean oﬀ MC and switch to independent staking; in such
case the assumption for SC will transition to Ahm(SC) (now with respect to SD) after the weaning slot and
the two chains will become sidechains of each other.
Remark 1. We note that the assumption of honest majority in the distribution out of which leaders are
sampled is one of two related ways of stating this requirement. The distribution from which sampling is
performed corresponds to the actual stake distribution near the end of the previous epoch. Hence, the actual
stake may have since shifted and may no longer be honest. Had we wanted to formulate this assumption
in terms of the actual (current) stake distribution, we would have to state two diﬀerent assumptions: (1)
that the current actual stake has honest majority with some gap σ; and (2) that the rate of stake shifting is
bounded by σfor the duration of (roughly) 2 epochs. From these two assumptions, one can conclude that the
distribution from which leaders are elected is currently controlled by an honest majority. The latter approach
was taken for example in [20].
6.2 Proof Overview
Proving our construction secure requires some case analysis. We summarize the intuition behind this en-
deavour before we proceed with the formal treatment.
The proof of Theorem 1 that shows that our construction from Section 4 has pegging security with
overwhelming probability will be established as follows. We will borrow the fact that our construction achieves
persistence and liveness from the original analysis [20] and state them as Lemma 1. The main challenge will
be to establish the ﬁrewall property, which is done in Lemma 7. These properties together establish pegging
security as required by Deﬁnition 8.
To show that the ﬁrewall property holds, we perform a case analysis, looking at the two cases of interest:
when both MC and SC are secure (i.e., when AMC ∧ASC holds), and when only MC is secure while the
security assumption of SC has been violated. As discussed above, the case where SC is secure and the
security of MC has been violated cannot occur per deﬁnition of AMC and ASC, and so examining this case
is not necessary.
First, we examine the case where both MC and SC are secure, but only concern ourselves with direct
observation transactions, or transactions that can be veriﬁed without relying on sidechain certiﬁcates. We
show that such transactions will always be correctly veriﬁed in this case.
Next, we establish that, when only MC is secure, it is impossible for the MC maintainers to accept a
view inconsistent with the validity language, and hence the ﬁrewall property is maintained in the case of a
sidechain failure.
Finally, the heart of the proof is a computational reduction (using the above partial results) showing how,
given an adversary that breaks the ﬁrewall property, there must exist a receiving transaction on MC which
breaks the validity of the scheme. Given such a transaction, we can construct an adversary against either
the security of the underlying ATMS scheme or the collision resistance of the underlying hash function.
25

6.3 Liveness and Persistence
We begin by stating the persistence and liveness guarantees of our construction, they both follow directly
from the guarantees shown for the standalone Ouroboros blockchain in [20].
Lemma 1 (Persistence and Liveness). Consider the construction of Section 4 with the assumptions
ASC,AMC. For all slots t, if ASC[t] (resp. AMC[t]) holds, then SC (resp. MC) satisﬁes persistence and
liveness up to slot t with overwhelming probability in k.
We now restate the Common Preﬁx property of blockchains for future reference. If the Common Preﬁx
property holds, then Persistence can be derived along the lines of [20].
Deﬁnition 12 (Common Preﬁx). For every honest party P1 and P2 both maintaining the same ledger
(i.e., either both maintaining MC, or both maintaining SC) and for every slot r1 and r2 such that r1 ≤r2 ≤t,
let C1 be the adopted chain of P1 at slot r1 and C2 be the adopted chain of P2 at slot r2. The k-common
preﬁx property for slot t states that C2[: |C1[: −k]|] = C1[: −k].
6.4 The Firewall Property and MC-Receiving Transactions
Recall that the transactions in TA can be partitioned into several classes with diﬀerent validity-checking
procedures. First, there are local transactions (where send = rec = lid) and sending transactions (with
lid = send ̸= rec). Then we have receiving transactions (with send ̸= rec = lid), which can be split into SC-
receiving transactions (send ̸= rec = lid = SC) and MC-receiving transactions (send ̸= rec = lid = MC).
As the lemma below observes, if a transaction violates the ﬁrewall property in a certain situation, it must
be a MC-receiving transaction.
Lemma 2. Consider an execution of the protocol of Section 4 at slot t in which MC and SC satisfy per-
sistence. Suppose
L = merge ({L∪
MC[t],L∪
SC[t]}) ̸∈VA
and suppose that St = {SC,MC}. Let L′ be the minimum preﬁx of L such that L′̸∈VA. Then L′̸= ε and
tx ≜ L′[−1] is an MC-receiving transaction.
Proof. The base property of the validity language implies L′ ̸= ε, hence tx exists. Due to the minimality
of L′, Algorithm 5 returns false for L′ but true for L′[: −1]. Since it processes transactions sequentially, it
must return false during the processing of tx. Suppose for contradiction that tx is not an MC-receiving
transaction; let us call such a transaction direct in this proof.
Algorithm 5 can output false while processing a direct transaction in the following cases: (a) in Line 17
when there is a Conservation Law violation; (b) in Line 8 when there is a signature validation failure; (c) in
Line 13 when tx is a replay of a previous transaction; (d) in Line 22 when tx is a replay, or (e) in Line 27
when the pre-image transaction has not yet been processed. Hence, tx falls under one of these violations.
Due to persistence and the deﬁnition of L∪
MC[t] and L∪
SC[t], there exists an MC maintainer PMC and an
SC maintainer PSC, such that LPMC
MC [t] = L∪
MC[t] and LPSC
SC [t] = L∪
SC[t], respectively. Due to the partitioning
property of merge, tx will be in L
Plid(tx)
lid(tx) [t]. We separately consider the two possibilities for lid(tx).
Case 1: lid(tx) = MC. In this case, the only violations that a direct tx can attain are (a), (b) and (c),
as the cases (d) and (e) for lid(tx) = MC do not pertain to a direct transaction. PMC has reported LPMC
MC [t]
as its adopted state, hence LPMC
MC [t] is a ﬁxpoint of verifytxMC (as verifytxMC checks for a ﬁxpoint).
The execution of verifytxMC included every transaction in LPMC
MC [t]. Therefore, verifytxMC has accepted
every transaction in every iteration until the last iteration, which processestx. Consider, now, what happened
in the last iteration of the execution of verifytxMC. In that iteration, verifytxMC checks the validity
of σ, the Conservation Law, and transaction replay. In all cases (a), (b) and (c), verifytxMC will reject tx.
But this could not have happened, as LPMC
MC [t] is a ﬁxpoint, and we have a contradiction.
Case 2: lid(tx) = SC. Let Cmc and Csc be the MC and respectively SC chain adopted by PSC at slot t
(and recall that PSC maintains both chains). Let Cmc
′ be the chain adopted by PMC at slot t. As before,
26

annotatetxSC(Cmc,Csc) must be a ﬁxpoint of verifytxSC (as verifytxSC checks for a ﬁxpoint). As in
the previous case, tx cannot violate (a), (b), (c) and in this case nor (d), as this would constitute a ﬁxpoint
violation. Hence tx is an eﬀect transaction and we will examine whether tx constitutes a violation of (e).
Let tx−1 ≜ eﬀect−1
MC→SC(tx). Since tx is accepted by verifytxSC on input annotatetxSC(Cmc,Csc),
we deduce that there exists some block B ∈ Cmc[: −k] with tx−1 ∈ B. But Cmc
′[: −k] is the longest
stable chain among MC maintainers (due to L∪
MC[t] = LPMC
MC [t]), hence Cmc[: −k] is its preﬁx. Therefore
B ∈Cmc
′[: −k]. Hence, tx−1 ∈LPMC
MC [t]. Due to the partioning property of merge, tx−1 must appear in the
output of merge
(
{LPMC
MC [t],LPSC
SC [t]}
)
. Due to the topological soundness of merge, tx−1 must appear before tx
in merge
(
{LPMC
MC [t],LPSC
SC [t]}
)
. Hence, it cannot be the case that (e) is violated, as the pre-image transaction
exists. ⊓ ⊔
6.5 Firewall Property During Sidechain Failure
We now turn our attention to the case where the sidechain has suﬀered a “catastrophic failure” and so
St = {MC}. We describe why a catastrophic failure in the sidechain does not violate the ﬁrewall property.
To do this, we need to illustrate that, given a transaction sequence L which is accepted by the MC veriﬁer,
we can “ﬁll in the gaps” with transactions from SC in order to produce a new transaction sequence tx which
is valid with respect to VA.
We prove this constructively in Lemma 4. The construction of such a sequence is described in Algo-
rithm 15. The algorithm accepts a transaction sequence L ⊆ TMC valid according to verifierMC and
produces a transaction sequence tx ∈VA satisfying πMC(tx) = L, as desired.
The algorithm works by mapping each tx ∈L to one or more transactions in tx. The mapping is done
by calling plausibility-map(tx) for each transaction individually. Hence each transaction in tx has a speciﬁc
preimage transaction in L, which can be shared by other transactions in tx. The mapping is performed as
follows. If tx is a local transaction, then it is simply copied over, otherwise some extra transactions are
included. Speciﬁcally, if it’s an sending transaction tx, then ﬁrst tx is included, and subsequently the funds
are recovered by a corresponding transactiontx1 on SC, the eﬀect transaction of tx. The funds are afterwards
moved to a pool address poolpk by a transaction tx2. (Note that for this, we assume that the receiving account
public key has a correspnding private key, as this key is needed to signtx2. As we are only demonstrating the
existence of tx, Algorithm 15 does not need to be eﬃcient and so assuming the existence of the private key
is suﬃcient.) On the other hand, if it is an ( MC-)receiving transaction tx, the reverse procedure is followed.
First, the funds are collected by tx2 from the pool address poolpk and moved into the SC address which
will be used for the upcoming remote transaction. Then tx1 moves the funds out of SC so that they can
be collected by the corresponding tx on MC. In the ﬁrst case, the transaction sequence is ( tx,tx1,tx2) and
in the second case the sequence is ( tx2,tx1,tx). Note that, in both cases, tx and tx1 are identical, except
for the fact that tx is recorded on MC while tx1 is recorded on SC; the latter is the eﬀect (or pre-image,
respectively) of the former.
The simple intuition behind this construction is that, in the plausible historytx produced by Algorithm 15,
the account poolpk is holding all the money of the sidechain. More speciﬁcally, the balance that is maintained
in the variable balances[SC][poolpk] is identical to the pool variable maintained by the MC veriﬁer. This
invariant is made formal in Lemma 3.
Lemma 3 (Plausible balances). Let L ∈T ∗
A,MC and tx ←plausible(L). Consider an execution of Algo-
rithm 5 on tx and an execution of verifierMC on L. Let tx ∈L. Call pooltx the value of the pool variable
maintained by verifierMC prior to processing tx in its main for loop; call balances[SC][poolpk]tx the value
of the balances[SC][poolpk] variable prior to the iteration of its main for loop which processes the ﬁrst item
of plausibility-map(tx). For all tx ∈L, the following invariant will hold: pooltx = balances[SC][poolpk]tx.
Proof. By direct inspection of the two algorithms, observe that the balances[SC][poolpk] are updated by
Algorithm 5 only when send(txa) ̸= rec(txa). The balances are increased when send(txa) = MC (due to
tx2 ∈plausibility-map(tx) at Line 19 of Algorithm 15) and decreased when send(txa) = SC (due to tx2 ∈
27

plausibility-map(tx) at Line 25 of Algorithm 15). Exactly the same accounting is performed by verifierMC
when the respective tx is processed. ⊓ ⊔
Algorithm 15 The plausible transaction sequence generator.
1: ( poolsk,poolpk) ←Gen(1λ)
2: function plausible(L)
3: tx ←ε
4: for tx ∈L do
5: tx ←tx ∥plausibility-map(tx)
6: end for
7: return tx
8: end function
9: function plausibility-map(tx)
10: ⊿ Destructure tx into its constituents
11: ( txid,lid,(send,sAcc),(rec,rAcc),v,σ ) ←tx
12: if send = rec then
13: return (tx)
14: end if
15: if send = MC then
16: tx1 ←eﬀectMC→SC(tx)
17: Construct a valid σ2 using the private key corresponding to rAcc
18: Generate a fresh txid2
19: tx2 ←
(
txid2,SC,(SC,rAcc),(SC,poolpk),v,σ 2
)
20: return (tx,tx1,tx2)
21: end if
22: if send = SC then
23: Construct a valid σ2 using poolsk
24: Generate a fresh txid2
25: tx2 ←
(
txid2,SC,(SC,poolpk),(SC,sAcc),v,σ 2
)
26: tx1 ←eﬀect−1
SC→MC(tx)
27: return (tx2,tx1,tx)
28: end if
29: end function
We now prove the correctness of Algorithm 15 in Lemma 4.
Lemma 4 (Plausibility). For all L ∈T ∗
A,MC, if verifytxMC(L) = L then tx ←plausible(L) will satisfy
tx ∈VA.
Proof. Suppose for contradiction that tx ̸∈VA and let tx′be the minimum preﬁx of tx such that tx′̸∈VA.
From the validity language base property we have that tx′ ̸= ε and so it must have at least one element.
Let tx ≜ tx′[−1] and let txL ∈L be the input to plausibility-map which caused tx to be included in tx in the
execution of plausible in Algorithm 15. Since Algorithm 5 processes transactions sequentially, and by the
minimality of tx′, it must return false when tx is processed.
We distinguish the following cases for txL:
Case 1: Local transaction: send(txL) = rec(txL). Then tx = txL and send(tx) = lid(tx). Since L is a
ﬁxpoint of verifytxMC, tx must (a) have a valid signatureσ, (b) not be a replay transaction, and (c) respect
the Conservation Law. As txL is a local transaction satisfying all of (a), (b) and (c), therefore tx′∈VA, which
is a contradiction.
Case 2: Sending transaction: send(txL) = MC and rec(txL) = SC. In this case, let ( txL,tx1,tx2) =
plausibility-map(txL). If tx = txL, then tx is a sending transaction and we can apply the same reasoning to
28

argue that it will respect properties (a), (b) and (c). But those are the only violations for which Algorithm 5
can reject an sending transaction, and hence tx′∈VA, which is a contradiction.
If tx = tx1, then Algorithm 5 must return true. To see this, consider the cases when Algorithm 5 returns
false: (d) a replay failure in Line 22, which cannot occur as txL has been accepted by verifytxMC and so
verifytxMC must have seen txL only once while Algorithm 5 must be seeing it for exactly the second time;
or (e) a mismatch failure in Line 22 which cannot occur as tx1 is constructed identical to txL.
If tx = tx2 then send(tx) = rec(tx). This transaction cannot cause Algorithm 5 to return false. To see this,
consider the cases when Algorithm 5 returns false: (a) a signature failure in Line 8 cannot occur because σ2
was constructed correctly and the signature scheme is correct; (b) a replay failure in Line 13 cannot occur
because txid2 is fresh; (c) a conservation failure in Line 17 cannot occur because the immediately preceding
transaction tx′[−2] supplies suﬃcient balance.
Case 3: Receiving transaction: send(txL) = SC and rec(txL) = MC. In this case, let ( tx2,tx1,txL) =
plausibility-map(txL). The argument for tx = txL and tx = tx1 is as in Case 2 . For the case of tx = tx2,
the same argument as before holds for a signature validity and for replay protection. It suﬃces to show
that the conservation law is not violated. This is established in Lemma 3 by the invariant that pooltxL =
balances[SC][poolpk]txL that holds prior to processing tx2, as it is the ﬁrst transaction of a triplet produced
by plausibility-map. As verifytxMC(L) = L then therefore pooltxL −v ≥0 and so balances[SC][poolpk]txL −
amount≥0 and Algorithm 5 returns true.
All three cases result in a contradiction, concluding the proof. ⊓ ⊔
Lemma 5 (SC failure ﬁrewall). Consider any execution of the construction of Section 4 in which persis-
tence holds for MC. For all slots t such that St = {MC}we have that
merge({L∪
MC[t]}) ∈π{MC}(VA) .
Proof. From the assumption that persistence holds, there exists some MC party P for which LP
MC[t] =
L∪
MC[t]. Additionally, merge({L∪
MC[t]}) = L∪
MC[t] due to the partitioning property. It suﬃces to show
that there exists some tx ∈ VA such that π{MC}(tx) = LP
MC[t]. Let tx ← plausible(LP
MC[t]). We have
verifierMC(LP
MC[t]) = true, so apply Lemma 4 to obtain that tx ∈VA.
To see that π{MC}(tx) = LP
MC[t], note that Algorithm 15 for input L includes all tx ∈L in the same
order as in its input. Furthermore, all tx ∈tx such that tx ̸∈L have lid(tx) = SC and so are excluded from
the projection. ⊓ ⊔
6.6 General Firewall Property
In preparation for establishing the full ﬁrewall property, we state the following simple technical lemma.
Lemma 6 (Honest subsequence). Consider any set S of 2k consecutive slots prior to slot t in an ex-
ecution of an Ouroboros ledger L such that Ahm(L)[t] holds. Then k+ 1 slots of S are honest, except with
negligible probability.
Proof (sketch). If the adversary controlled at least k out of any 2 k consecutive slots, he could use them
to produce an alternative k-blocks long chain for this interval without any help from the honest parties,
resulting in a violation of common preﬁx and hence persistence (cf. Lemma 1). ⊓ ⊔
We are now ready to prove our key lemma, showing that our construction satisﬁes the ﬁrewall property.
Lemma 7 (Firewall). For all PPT adversaries A, the construction of Section 4 with a secure ATMS and
a collision-resistant hash function satisﬁes the ﬁrewall property with respect to assumptions AMC,ASC with
overwhelming probability in k.
Proof. Let Abe an arbitrary PPT adversary against the ﬁrewall property, andZbe an arbitrary environment
for the execution of A. We will construct the following PPT adversaries:
29

1. A1 is an adversary against ATMS.
2. A2 is a collision adversary against the hash function.
We ﬁrst describe the construction of these adversaries.
The adversary A1. A1 simulates the execution of Aand Z and of two populations of maintainers
for two blockchains, MC and SC, which run the protocol Π (either the MC or the SC-maintainer part
respectively) and spawns parties according to the mandates of the environment Zas follows. For all parties
that are spawned as MC maintainers, A1 generates keys internally by invoking the Gen algorithm of the
ATMS scheme. For all parties that are spawned as SC maintainers, A1 uses the oracle Ogen to produce the
public keys vki.
Whenever Arequests that a (block or transaction) signature in SC is created, A1 invokes its oracle Osig
to obtain the respective signature to provide to A. When Arequests that a MC signature is created, A1
uses its own generated private key to sign by invoking the Sig algorithm of the ATMS scheme. If Arequests
the corruption of a certain party P∗, then A1 reveals P∗’s private key to Aas follows: If P∗ is a MC
maintainer, then the secret key is directly available to A1, so it is immediately returned. Otherwise, if P∗is
a SC maintainer, then A1 obtains the secret key of P∗by invoking the oracle Ocor.
For every time slot tof the execution, A1 inspects all pairs (PMC,PSC) of honest parties such that PMC
is a MC maintainer and PSC is a SC maintainer such that LPMC
MC [t] = L∪
MC[t] and LPSC
SC [t] = L∪
SC[t] (if such
parties exist). Let L1 = LPMC
MC [t] and L2 = LPSC
SC [t]. The adversary obtains the stable portion of the honestly
adopted chain, namely C1 = CPMC[t][: −k] and the transactions included in C1, namely L′
1 (note that L′
1 ̸= L1
if L′
1 contains certiﬁcate transactions). A1 examines whether L = merge(L1,L2) ̸∈VA, to deduce whether A
has succeeded. Note that both the evaluation of merge on arbitrary states and the veriﬁcation of inclusion
in VA are eﬃciently computable and hence A1 can execute them. If A1 is not able to ﬁnd such a time slot t
and parties PMC,PSC, it returns failure (in the latter part of this proof, we will argue that all A1 failures
occur with negligible probability conditioned on the event that Ais successful, unless A2 is successful).
Otherwise it obtains the minimum tfor which this holds and the L for this t. Because of the base property
of the validity language, we have that ϵ∈VA and therefore L ̸= ϵ. Let L∗be the minimum preﬁx of L such
that L∗ ̸∈VA and let tx = L∗[−1]. If tx has send(tx) ̸= SC or lid(tx) ̸= MC, then A1 returns failure.
Now therefore send(tx) = SC and lid(tx) = MC (and so tx ∈L1). Hence, tx references a certain certiﬁcate
transaction, say tx′. Due to the algorithm executed by MC maintainers for validation, we will have that
tx′∈L′
1{: tx}.
Let tx∗ be the subsequence of L′
1 containing all certiﬁcate transactions up to and including tx′. We will
argue that there must exist some ATMS forgery among one of the certiﬁcate transactions in tx∗. A1 looks
at every transaction sc certj ∈tx∗(and note that it will correspond to a unique epoch ej). sc certj contains
a message m = ( j,⟨pendingj⟩,avkj) and a signature σj. A1 extracts the epoch ej in which sc certj was
conﬁrmed in C1 (and note that we must have j >0). A1 collects the public keys elected for the last 2 k slots
of epoch ej−1 according to the view of PSC into a set keysj−1 and similarly for keysj. A1 collects the pending
cross-chain transactions of ej−1 according to the view of PSC into pending′
j, and creates the respective
Merkle-tree commitment
⟨
pending′
j
⟩
. A1 checks whether the following certiﬁcate violation condition holds:
AVer(m,avkj−1,σj) ∧ACheck(keysj−1,avkj−1) ∧
(
¬ACheck(keysj,avkj) ∨⟨pendingj⟩̸= ⟨pending′
j⟩
)
(2)
where avkj−1 is extracted from sc certj−1 according to the view of PSC, unless j = 1 in which case avk0 is
known. If the condition (2) holds for no j then A1 returns failure, otherwise it denotes by j∗the minimum
j for which (2) holds and outputs the tuple ( m,σj∗,avkj∗−1,keysj∗−1).
The adversary A2. Like A1, A2 simulates the execution of Aincluding two populations of maintainers
and spawns parties according to the mandates of the environment Z. For all these parties, A2 generates
keys internally. When Arequests that a transaction is created, A2 provides the signature with its respective
private key. If Arequests the corruption of a certain party, say P∗, then A2 provides the respective private
key to A.
30

For every time slot t of the execution, A2 inspects all pairs of honest parties such that PMC is a MC
maintainer and PSC is a SC maintainer such that LPMC
MC [t] = L∪
MC[t] and LPSC
SC [t] = L∪
SC[t] and obtains the
variables L1,L2,C1,L′
1 as before. A2 examines whether L = merge(L1,L2) ̸∈VA, to deduce whether Ahas
succeeded. If A2 is not able to ﬁnd such a time slot tand parties PMC,PSC, it returns failure. Let tx be as
in A1. If send(tx) ̸= SC or lid(tx) ̸= MC, then A2 returns failure. Then tx references a certain certiﬁcate
transaction sc certj = (j,⟨pendingj⟩,avkj,σj) and uses a Merkle tree proof π which proves the inclusion of
tx in pendingj. If sc certj ̸∈L′
1, then A2 returns failure. When sc certj was accepted by PSC, pendingj
included a set of transactions tx in the view of PSC. If tx ∈tx, then A2 returns failure. Otherwise, the
Merkle tree ⟨pendingj⟩was constructed from tx, but a proof-of-inclusion π for tx ̸∈tx was created. From this
proof, A2 extracts a hash collision and returns it.
Probability analysis. Deﬁne the following events:
– sc-forge[t]: Ais successful at slot t, i.e., πA (merge({L∪
i [t] : i∈St})) ̸∈πSt (VA).
– atms-forge: A1 ﬁnds an index j∗for which the condition (2) occurs.
– hash-collision: A2 ﬁnds a hash function collision.
Note that ledger states in the protocol only contain A-transactions, hence πA is the identity function and
sc-forge[t] is equivalent to merge ({L∪
i [t] : i∈St}) ̸∈πSt (VA). We will now show that for every t, the
probability Pr[sc-forge[t]] is negligible. We distinguish two cases:
Case 1: St = {MC,SC}. In this case Persistence holds for both MC and SC, and πSt is the identity
function. We deal with this case in two successive claims (both implicitly conditioning on being in Case 1).
First we show that, if sc-forge[t] occurs, then one of atms-forge, hash-collision occurs. Therefore
applying a union bound, we will have that:
Pr[sc-forge[t]] ≤Pr[atms-forge] + Pr[hash-collision] .
Second, we show that Pr[ atms-forge] is negligible (and the negligibility of Pr[ hash-collision] follows
from our assumption that the hash function is collision resistant).
Claim 1a: sc-forge[t] ⇒atms-forge∨hash-collision.
Because persistence holds in both MC and SC, we know that there exist two parties PMC,PSC such that
at slot t we have that LPMC
MC [t] = L∪
MC[t] and LPSC
SC [t] = L∪
SC[t], respectively. Therefore sc-forge[t] implies
merge({LPMC
MC [t],LPSC
SC [t]}) ̸∈VA .
Let tx,tx′ be as in the deﬁnition of A1. By Lemma 2 and using MC and SC persistence, tx will exist
and be an MC-receiving transaction. Hence, send(tx) = SC and rec(tx) = lid(tx) = MC. Therefore, tx′
will also exist. If A1 ﬁnds the index j∗ for which (2) is satisﬁed, then atms-forge has occured and the
claim is established, so let us assume otherwise. Hence, for each certiﬁcate sc certj containing a message
m= (j,⟨pendingj⟩,avkj), it holds that
(
AVer(m,avkj−1,σj) ∧ACheck(keysj−1,avkj−1)
)
⇒
(
ACheck(keysj,avkj) ∧⟨pendingj⟩= ⟨pending′
j⟩
)
. (3)
Therefore, we have a chain of certiﬁcates, each of which is signed with a valid key avkj−1 and attests to the
validity of the next key avkj. For all of these certiﬁcates, AVer(m,avkj−1,σj) holds, as it has been veriﬁed
by PMC. Furthermore, by an induction argument (where the base case comes from the construction of avk0
and the induction step follows from (3)) we have ACheck(keysj−1,avkj−1) as well.
As tx′ is a certiﬁcate transaction which appears last in the above chain (with some index sc certk), the
above implication also holds for tx′, and so does its premise AVer(m,avkk−1,σk) ∧ACheck(keysk−1,avkk−1).
Therefore, the conclusion of the implication ⟨pendingk⟩= ⟨pending′
k⟩holds. However, the sending transaction
corresponding to tx has been proven to belong to the Merkle Tree ⟨pendingk⟩(as veriﬁed by PMC), but does
not belong to pending′
k (by the selection of tx). This constitutes a Merkle Tree collision, which translates to
a hash collision. The construction of A2 outputs exactly this collision, and in this case we deduce that A2 is
successful and hash-collision follows.
31

Claim 1b: Pr[atms-forge] is negligible.
Suppose that atms-forge occurs. We will argue that, in this case, A1 will have computed an ATMS forgery,
which is a negligible event by the assumption that the used ATMS is secure.
From the assumption that atms-forge has occurred, at epoch ej we have that AVer(m,avkj−1,σj) and
ACheck(keysj−1,avkj−1), but ¬ACheck(keysj,avkj) or ⟨pendingj⟩̸= ⟨pending′
j⟩. From Lemma 6 and using
Ahm(SC)[t], we deduce that in the last 2 k slots of epoch ej−1, at least k+ 1 must be honest. Since ej is the
earliest epoch in which this occurs, this means that keysj−1 corresponds to the last 2 k slot leaders of epoch
ej−1, and all honest parties agree on the same 2kslot leaders. Hence, in the ATMS game, the number of keys
in keys corrupted by the adversary through the use of the oracle Ocor(·) is less than k. Furthermore, since
¬ACheck(keysj,avkj) or ⟨pendingj⟩̸= ⟨pending′
j⟩, the message m contains either an invalid future aggregate
key, an invalid Merkle Tree root of outgoing cross-chain transactions, or both. Hence, no honest party will
sign the message mfor this epoch and therefore |Qsig[m]|= 0. Hence q <k, and A1 wins the ATMS security
game.
Case 2: St ̸= {MC,SC}. If MC ̸∈St then, since AMC[t] ⇒ASC[t], we have St = ∅and ¬sc-forge[t],
as ϵ ∈VA by the base property. It remains to consider the case St = {MC}. Using MC persistence, by
Lemma 5 we obtain merge({L∪
MC[t]}) ∈π{MC}(VA), and hence sc-forge[t] did not occur.
From the two above cases, we conclude that for every t, Pr[sc-forge[t]] ≤negl. As the total number of
slots is polynomial, we have shown that with overwhelming probability, we have that for all slots t and for
all A ∈⋃
i∈St Assets(Li), πA (merge ({L∪
i [t] : i∈St})) ∈πSt (VA), concluding the proof. ⊓ ⊔
Lemmas 1 and 7 together directly imply the following theorem.
Theorem 1 (Pegging Security). Consider the synchronous setting as deﬁned in Section 2.1 with 2R-
semiadaptive corruptions as deﬁned in Section 2.1. The construction of Section 4 using a secure ATMS
and a collision resistant hash function is pegging secure with liveness parameter u = 2 k with respect to
assumptions AMC and ASC deﬁned above, and merge, eﬀect and VA deﬁned in Section 4.2.
Acknowledgements. This research was partially supported by H2020 project PRIVILEDGE #780477.
References
1. A. Back, M. Corallo, L. Dashjr, M. Friedenbach, G. Maxwell, A. Miller, A. Poelstra, J. Tim´ on, and P. Wuille.
Enabling blockchain innovations with pegged sidechains. 2014. http://www.opensciencereview.com/papers/
123/enablingblockchain-innovations-with-pegged-sidechains .
2. C. Badertscher, P. Gaˇ zi, A. Kiayias, A. Russell, and V. Zikas. Ouroboros genesis: Composable proof-of-stake
blockchains with dynamic availability. Cryptology ePrint Archive, Report 2018/378, 2018. https://eprint.
iacr.org/2018/378. To appear at ACM CCS 2018.
3. M. Bellare and P. Rogaway. Random oracles are practical: A paradigm for designing eﬃcient protocols. In
V. Ashby, editor, ACM CCS 93 , pages 62–73. ACM Press, Nov. 1993.
4. E. Ben-Sasson, I. Bentov, Y. Horesh, and M. Riabzev. Scalable, transparent, and post-quantum secure computa-
tional integrity. Manuscript.(2017). Slides at https://people. eecs. berkeley. edu/˜ alexch/docs/pcpip bensasson.
pdf, 2017.
5. I. Bentov, R. Pass, and E. Shi. Snow white: Provably secure proofs of stake. Cryptology ePrint Archive, Report
2016/919, 2016. http://eprint.iacr.org/2016/919.
6. I. Bentov, R. Pass, and E. Shi. Snow white: Provably secure proofs of stake. IACR Cryptology ePrint Archive ,
2016:919, 2016.
7. N. Bitansky, R. Canetti, A. Chiesa, and E. Tromer. From extractable collision resistance to succinct non-
interactive arguments of knowledge, and back again. In S. Goldwasser, editor, ITCS 2012, pages 326–349. ACM,
Jan. 2012.
8. A. Boldyreva. Threshold signatures, multisignatures and blind signatures based on the gap-Diﬃe-Hellman-group
signature scheme. In Y. Desmedt, editor, PKC 2003, volume 2567 of LNCS, pages 31–46. Springer, Heidelberg,
Jan. 2003.
9. E. Buchman. Tendermint: Byzantine fault tolerance in the age of blockchains . PhD thesis, 2016.
32

10. B. B¨ unz, J. Bootle, D. Boneh, A. Poelstra, P. Wuille, and G. Maxwell. Bulletproofs: Short proofs for conﬁdential
transactions and more.
11. V. Buterin et al. A next-generation smart contract and decentralized application platform. white paper, 2014.
12. R. Canetti. Universally composable security: A new paradigm for cryptographic protocols. In 42nd FOCS, pages
136–145. IEEE Computer Society Press, Oct. 2001.
13. B. David, P. Gazi, A. Kiayias, and A. Russell. Ouroboros praos: An adaptively-secure, semi-synchronous proof-
of-stake blockchain. In J. B. Nielsen and V. Rijmen, editors, EUROCRYPT 2018, Part II , volume 10821 of
LNCS, pages 66–98. Springer, Heidelberg, Apr. / May 2018.
14. J. Dilley, A. Poelstra, J. Wilkins, M. Piekarska, B. Gorlick, and M. Friedenbach. Strong federations: An interop-
erable blockchain solution to centralized third party risks. CoRR, abs/1612.05491, 2016.
15. Y. Dodis and A. Yampolskiy. A veriﬁable random function with short proofs and keys. In S. Vaudenay, editor,
PKC 2005, volume 3386 of LNCS, pages 416–431. Springer, Heidelberg, Jan. 2005.
16. C. Dwork and M. Naor. Pricing via processing or combatting junk mail. In E. F. Brickell, editor, CRYPTO’92,
volume 740 of LNCS, pages 139–147. Springer, Heidelberg, Aug. 1993.
17. J. A. Garay, A. Kiayias, and N. Leonardos. The bitcoin backbone protocol: Analysis and applications. In
E. Oswald and M. Fischlin, editors, EUROCRYPT 2015, Part II, volume 9057 of LNCS, pages 281–310. Springer,
Heidelberg, Apr. 2015.
18. A. Kiayias, N. Lamprou, and A.-P. Stouka. Proofs of proofs of work with sublinear complexity. In J. Clark,
S. Meiklejohn, P. Y. A. Ryan, D. S. Wallach, M. Brenner, and K. Rohloﬀ, editors, FC 2016 Workshops , volume
9604 of LNCS, pages 61–78. Springer, Heidelberg, Feb. 2016.
19. A. Kiayias, A. Miller, and D. Zindros. Non-interactive proofs of proof-of-work, 2017.
20. A. Kiayias, A. Russell, B. David, and R. Oliynykov. Ouroboros: A provably secure proof-of-stake blockchain
protocol. In J. Katz and H. Shacham, editors, CRYPTO 2017, Part I , volume 10401 of LNCS, pages 357–388.
Springer, Heidelberg, Aug. 2017.
21. E. Kokoris-Kogias, P. Jovanovic, L. Gasser, N. Gailly, E. Syta, and B. Ford. OmniLedger: A secure, scale-out,
decentralized ledger via sharding. In 2018 IEEE Symposium on Security and Privacy , pages 583–598. IEEE
Computer Society Press, May 2018.
22. J. A. Kroll, I. C. Davey, and E. W. Felten. The economics of bitcoin mining, or bitcoin in the presence of
adversaries. In The Twelfth Workshop on the Economics of Information Security (WEIS 2013), Washington DC ,
June 10-11 2013.
23. S. D. Lerner. Drivechains, sidechains and hybrid 2-way peg designs, 2016.
24. C. Li, T. Hwang, and N. Lee. Threshold-multisignature schemes where suspected forgery implies traceability of
adversarial shareholders. In A. D. Santis, editor, Advances in Cryptology - EUROCRYPT ’94, Workshop on the
Theory and Application of Cryptographic Techniques, Perugia, Italy, May 9-12, 1994, Proceedings , volume 950
of Lecture Notes in Computer Science , pages 194–204. Springer, 1994.
25. L. Luu, V. Narayanan, C. Zheng, K. Baweja, S. Gilbert, and P. Saxena. A secure sharding protocol for open
blockchains. In E. R. Weippl, S. Katzenbeisser, C. Kruegel, A. C. Myers, and S. Halevi, editors, Proceedings
of the 2016 ACM SIGSAC Conference on Computer and Communications Security, Vienna, Austria, October
24-28, 2016, pages 17–30. ACM, 2016.
26. S. Micali. ALGORAND: the eﬃcient and democratic ledger. CoRR, abs/1607.01341, 2016.
27. S. Nakamoto. Bitcoin: A peer-to-peer electronic cash system. 2008.
28. T. Ristenpart and S. Yilek. The power of proofs-of-possession: Securing multiparty signatures against rogue-key
attacks. Cryptology ePrint Archive, Report 2007/264, 2007. https://eprint.iacr.org/2007/264.
29. P. Sztorc. Drivechain - the simple two way peg, November 2015. http://www.truthcoin.info/blog/
drivechain/.
30. S. Thomas and E. Schwartz. A protocol for interledger payments. https://interledger.org/interledger.pdf.
31. G. Wood. Ethereum: A secure decentralised generalised transaction ledger. Ethereum Project Yellow Paper ,
151:1–32, 2014.
32. G. Wood. Polkadot: Vision for a heterogeneous multi-chain framework, 2016.
33. M. Zamani, M. Movahedi, and M. Raykova. RapidChain: A fast blockchain protocol via full sharding. Cryptology
ePrint Archive, Report 2018/460, 2018. https://eprint.iacr.org/2018/460.
34. A. Zamyatin, N. Stifter, A. Judmayer, P. Schindler, E. Weippl, W. Knottenbelt, and A. Zamyatin. A wild
velvet fork appears! inclusive blockchain protocol changes in practice. In International Conference on Financial
Cryptography and Data Security . Springer, 2018.
33

Appendix
A The Diﬀuse Functionality
In the model described in Section 2.1 we employ the “Delayed Diﬀuse” functionality of [13], which we now
describe in detail for completeness. The functionality is parameterized by ∆ ∈N and denoted DDiﬀuse∆.
It keeps rounds, executing one round per slot. DDiﬀuse∆ interacts with the environment Z, stakeholders
U1,...,U n and adversary A, working as follows for each round: DDiﬀuse∆ maintains an incoming string for
each party Pi that participates. A party, if activated, can fetch the contents of its incoming string, hence it
behaves as a mailbox. Furthermore, parties can give an instruction to the functionality to diﬀuse a message.
Activated parties can diﬀuse once per round.
When the adversary Ais activated, it can: (a) read all inboxes and all diﬀuse requests and deliver
messages to the inboxes in any order; (b) for any message m obtained via a diﬀuse request and any party
Pi, Amay move m into a special string delayedi instead of the inbox of Pi. Acan decide this individually
for each message and each party; (c) for any party Pi, Acan move any message from the string delayedi to
the inbox of Pi.
At the end of each round, the functionality ensures that every message that was either (a) diﬀused in this
round and not put to the string delayedi or (b) removed from the string delayedi in this round is delivered
to the inbox of party Pi. If a message currently present in delayedi was originally diﬀused ∆ slots ago, the
functionality removes it from delayedi and appends it to the inbox of party Pi.
Upon receiving ( Create,U, C) from the environment, the functionality spawns a new stakeholder with
chain Cas its initial local chain (as in [20,13]).
B Adaptation to Other Proof-of-Stake Blockchains
Our construction can be adapted to work with other provably secure proof-of-stake blockchains discussed
in Section 2.3: Ouroboros Praos [13], Ouroboros Genesis [2], Snow White [6], and Algorand [26]. Here we
assume some familiarity with the considered protocols and refer the interested reader to the original papers
for details.
B.1 Ouroboros Praos and Ouroboros Genesis
These protocols [13,2] are strongly related and diﬀer from each other only in the chain-selection rule they use,
which is irrelevant for our discussion here, hence we consider both of the protocols simultaneously. Ouroboros
Praos was shown secure in the semi-synchronous model with fully adaptive corruptions (cf. Section 2.1) and
this result extends to Ouroboros Genesis. Despite sharing the basic structure with Ouroboros, they diﬀer in
several signiﬁcant points which we now outline.
The slot leaders are elected diﬀerently: Namely, each party for each slot evaluates a veriﬁable random
function (VRF, [15]) using the secret key associated with their stake, and providing as inputs to the VRF
both the slot index and the epoch randomness. If the VRF output is below a certain threshold that depends
on the party’s stake, then the party is an eligible slot leader for that slot, with the same consequences as in
Ouroboros. Each leader then includes into the block it creates the VRF output and a proof of its validity to
certify her eligibility to act as slot leader. The probability of becoming a slot leader is roughly proportional
to the amount of stake the party controls, however now it is independent for each slot and each party, as it
is evaluated locally by each stakeholder for herself. This local nature of the leader election implies that there
will inevitably be some slots with no, or several, slot leaders. In each epoch j, the stake distribution used in
Praos and Genesis for slot leader election corresponds to the distribution recorded in the ledger up to the
last block of epoch j−2. Additionally, the epoch randomness ηj for epoch j is derived as a hash of additional
VRF-values included into blocks from the ﬁrst two thirds of epoch j−1 for this purpose by the respective
slot leaders. Finally, the protocols use key-evolving signatures for block signing, and in each slot the honest
parties are mandated to update their private key, contributing to their resilience to adaptive corruptions.
34

Ouroboros Praos was shown [13] to achieve persistence and liveness under weaker assumptions than
Ouroboros, namely: (1) ∆-semi-synchronous communication (where ∆ aﬀects the security bounds but is
unknown to the protocol); (2) majority of the stake is always controlled by honest parties. In particular,
Ouroboros Praos is secure in face of fully adaptive corruptions without any corruption delay. Ouroboros
Genesis provides the same guarantees as Praos, as well as several other features that will not be relevant for
our present discusion.
Construction of Pegged Ledgers. The main diﬀerence compared to our treatment of Ouroboros would
be in the construction of the sidechain certiﬁcate (cf. Section 4.3). The need for a modiﬁcation is caused by
the private, local leader selection using VRFs in these protocols, which makes it impossible to identify the
set of slot leaders for the suﬃx of an epoch at the beginning of this epoch, as done for Ouroboros.
The sidechain certiﬁcate included in MC at the beginning of epoch j would hence contain the following,
for parameters Q and T speciﬁed below:
1. the epoch index;
2. a Merkle commitment to the list of withdrawals as in the case of Ouroboros;
3. a Merkle commitment to the SC stake distribution SDj;
4. a list of Q public keys;
5. Q inclusion proofs (with respect to SDj−1 contained in the previous certiﬁcate) and Q VRF-proofs
certifying that these Q keys belong to slot leaders of Q out of the last T slots in epoch j−1;
6. Q signatures from the above Q public keys on the above; these can be replaced by a single aggregate
signature to save space on MC.
The parameters Qand T have to be chosen in such a way that with overwhelming probability, there will
be a chain growth of at least Q blocks during the last T slots of epoch j−1, but the adversary controls Q
slots in this period only with negligible probability (and hence at least one of the signatures will have to
come from an honest slot leader). The existence of such constants for T = Θ(k) was shown in [2].
While the above sidechain certiﬁcate is larger (and hence takes more space on MC) than the one we
propose for Ouroboros, a switch to Ouroboros Praos or Genesis would also bring several advantages. First
oﬀ, both constructions would give us security in the semi-synchronous model with fully adaptive corruptions
(as shown in [13,2]), and the use of Ouroboros Genesis would allow newly joining players to bootstrap from
the mainchain genesis block only—without the need for a trusted checkpoint—as discussed extensively in [2].
B.2 Snow White
The high-level structure of Snow White execution is similar to the protocols we have already discussed: it
contains epochs, committees that are sampled for each epoch based on the stake distribution recorded in the
blockchain prior to that epoch, and randomness used for this sampling produced by hashing special nonce
values included in previous blocks. Hence, our construction can be adapted to work with Snow White-based
blockchains in a straightforward manner.
B.3 Algorand
Algorand does not aim for the so-called eventual consensus. Instead it runs a full Byzantine Agreement
protocol for each block before moving to the next block, hence blocks are immediately ﬁnalized. Consider a
setting with MC and SC both running Algorand. The main diﬃculty to address when constructing pegged
ledgers is the continuous authentication of the sidechain certiﬁcate constructed by SC-maintainers for MC
(other aspects, such as deposits from MC to SC work analogously to what we described above). As Algorand
does not have epochs, and creating and processing a sidechain certiﬁcate for each block is overly demanding,
a natural choice is to introduce a parameter R and execute this process only once every R blocks. Namely,
every Rblocks, the SC-maintainers produce a certiﬁcate that theMC-maintainers insert into the mainchain.
This certiﬁcate most importantly contains:
1. a Merkle commitment to the list of withdrawals in the most recent R-block period;
35

2. a Merkle commitment to the full, most recent stake distribution SDj on SC;
3. a suﬃcient number of signatures from a separate committee certifying the above information, together
with proofs justifying the membership of the signature’s creators in the committee.
This additional committee is sampled from SDj−1 (the stake distribution committed to in the previous
sidechain certiﬁcate) via Algorand’s private sortition mechanism such that the expected size of the committee
is large enough to ensure honest supermajority (required for Algorand’s security) translates into a strong
honest majority within the committee. Note that the sortition mechanism also allows for a succinct proof
of membership in the committee. The members of the committee then insert their individual signatures
(signing the ﬁrst two items in the certiﬁcate above) into the SC blockchain during the period of R blocks
preceding the construction of the certiﬁcate. All the remaining mechanics of the pegged ledgers are a direct
analogy of our construction above.
36