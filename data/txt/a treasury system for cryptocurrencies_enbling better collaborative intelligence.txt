A Treasury System for Cryptocurrencies:
Enabling Better Collaborative Intelligence⋆
Bingsheng Zhang1, Roman Oliynykov2, and Hamed Balogun 3
1 Lancaster University, UK
b.zhang2@lancaster.ac.uk
2 Input Output Hong Kong Ltd.
roman.oliynykov@iohk.io
3 Lancaster University, UK
h.balogun@lancaster.ac.uk
Abstract. A treasury system is a community controlled and decentral-
ized collaborative decision-making mechanism for sustainable funding
of the blockchain development and maintenance. During each treasury
period, project proposals are submitted, discussed, and voted for; top-
ranked projects are funded from the treasury. The Dash governance sys-
tem is a real-world example of such kind of systems. In this work, we,
for the ﬁrst time, provide a rigorous study of the treasury system. We
modelled, designed, and implemented a provably secure treasury sys-
tem that is compatible with most existing blockchain infrastructures,
such as Bitcoin, Ethereum, etc. More speciﬁcally, the proposed treasury
system supports liquid democracy/delegative voting for better collabo-
rative intelligence. Namely, the stake holders can either vote directly on
the proposed projects or delegate their votes to experts. Its core compo-
nent is a distributed universally composable secure end-to-end veriﬁable
voting protocol. The integrity of the treasury voting decisions is guar-
anteed even when all the voting committee members are corrupted. To
further improve eﬃciency, we proposed the world’s ﬁrst honest veriﬁer
zero-knowledge proof for unit vector encryption with logarithmic size
communication. This partial result may be of independent interest to
other cryptographic protocols. A pilot system is implemented in Scala
over the Scorex 2.0 framework, and its benchmark results indicate that
the proposed system can support tens of thousands of treasury partici-
pants with high eﬃciency.
⋆ This article is the full version of a paper that has been accepted to appear at NDSS
2019.

Table of Contents
1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1
1.1 Collaborative decision-making . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2
1.2 Our contributions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3
2 Preliminaries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4
2.1 Notations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4
2.2 The blockchain abstraction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4
2.3 Additively homomorphic encryption . . . . . . . . . . . . . . . . . . . . . . . . . 5
2.4 Pedersen commitment. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
2.5 Universal composability . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6
2.6 UC ideal functionalities . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7
3 The Treasury System . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
3.1 Entities . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
3.2 Enabling stake delegation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9
3.3 System overview . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
3.4 Treasury funding sources . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12
3.5 Project proposal . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12
3.6 Voter/Expert registration . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
3.7 Voting committee selection . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
3.8 Supplying the treasury . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14
3.9 Handling the treasury speciﬁc data in the payload . . . . . . . . . . . . . 15
3.10 Decision making. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15
3.11 Post-voting execution . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16
3.12 Partitionary budgeting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16
4 The proposed voting scheme . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
4.1 Security modeling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17
4.2 The voting scheme . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19
4.3 Security . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23
5 A new unit vector ZK proof . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
5.1 Zero-knowledge proofs/arguments . . . . . . . . . . . . . . . . . . . . . . . . . . . 26
5.2 Schwartz-Zippel lemma . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27
5.3 The proposed unit vector ZK proof/argument . . . . . . . . . . . . . . . . . 27
6 Implementation and performance . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31
6.1 Prototyping . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31
6.2 Test network . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31
6.3 Evaluations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32
7 Analysing consensus . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34
7.1 Example treasury consensus evaluation . . . . . . . . . . . . . . . . . . . . . . . 36
8 Related work . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41
9 Conclusion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43
A Our Treasury System DKG Protocol . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 46

A Treasury System for Cryptocurrencies 1
1 Introduction
Following the success of Bitcoin, a great number of new cryptocurrencies and
blockchain platforms are emerging on almost daily basis. Blockchains have
become largely ubiquitous across various sectors, e.g., technology, academia,
medicine, economics and ﬁnance, etc. A key feature expected from cryptocur-
rencies and blockchain systems is the absence of a centralized control over the
operation process. That is, blockchain solutions should neither rely on “trusted
parties or powerful minority” for their operations, nor introduce such (centrali-
sation) tendencies into blockchain systems. Decentralization not only oﬀers bet-
ter security guarantees by avoiding single point of failure , but may also enable
enhanced user privacy techniques. On the other hand, real-world blockchain sys-
tems require steady funding for continuous development and maintenance of the
systems. Given that blockchain systems are decentralized systems, their main-
tenance and developmental funding should also be void of centralization risks.
Therefore, secure and “community-inclusive” long-term sustainability of funding
is critical for the health of blockchain platforms.
In the early years, the development of cryptocurrencies, such as Bitcoin,
mainly rely on patron organizations and donations. Recently, an increasing num-
ber of cryptocurrencies are funded throughinitial coin oﬀering (ICO) – a popular
crowd-funding mechanism to raise money for the corresponding startups or com-
panies. A major drawback of donations and ICOs is that they lack sustainable
funding supply. Consequently, they are not suitable as long-term funding sources
for cryptocurrency development due to the diﬃculty of predicting the amount
of funds needed (or that will be available) for future development and main-
tenance. Alternatively, some cryptocurrency companies, such as Zcash Electric
Coin Company, take certain percentage of hair-cut/tax (a.k.a. founders reward)
from the miners’ reward. This approach would provide the companies a more
sustainable funding source for long-term planning of the cryptocurrency devel-
opment.
Nevertheless, the aforementioned development funding approaches have risks
of centralization in terms of decision-making on the development steering. Only
a few people (in the organisation or company) participate in the decision-making
process on how the available funds will be used. However, the decentralized ar-
chitecture of blockchain technologies makes it inappropriate to have a centralized
control of the funding for secure development processes. Sometimes disagreement
among the organisation members may lead to catastrophic consequences. Exam-
ples include the splitting of Ethereum and Ethereum Classic as well as Bitcoin
and Bitcoin Cash.
Ideally, all cryptocurrency stake holders are entitled to participate in
the decision-making process on funding allocation. This democratic type of
community-inclusive decentralized decision-making enables a better collabora-
tive intelligence. The concept of treasury system has been raised to address the
highlighted issue. A treasury system is a community controlled and decentralized
collaborative decision-making mechanism for sustainable funding of the underly-
ing blockchain development and maintenance. The Dash governance system [1]

2 B. Zhang, R. Oliynykov and H. Balogun
is a real-world example of such systems. A treasury system consists of iterative
treasury periods. During each treasury period, project proposals are submitted,
discussed, and voted for; top-ranked projects are then funded. However, the Dash
governance system has a few potential theoretical drawbacks. i) It does not oﬀer
ballot privacy to the voters (a.k.a. masternodes) [2]. Therefore, the soundness
of any funding decision might be ill-aﬀected. For instance, the masternodes may
be subject to coercion. ii) It fails to eﬀectively utilize the knowledge of commu-
nity experts in the decision-making process. This is because the system can only
support very basic type of voting schemes, and the voting power of experts are
limited.
In this work, we propose to use a diﬀerent approach – liquid democracy –
to achieve better collaborative intelligence. Liquid democracy (also known as
delegative democracy [3]) is an hybrid of direct democracy and representative
democracy. It provides the beneﬁts of both systems (whilst doing away with their
drawbacks) by enabling organisations to take advantage of experts in a treasury
voting process, as well as giving the stakeholders the opportunity to vote. For
each project, a voter can either vote directly or delegate his/her voting power
to an expert who is knowledgeable and renowned in the corresponding area.
1.1 Collaborative decision-making
The core component of a treasury system is a decision-making system that al-
lows members of the community collectively reach some conclusions/decisions.
During each treasury period, anyone can submit a proposal for projects to be
funded. Due to shortage of available funds, only a few of them can be supported.
Therefore, a collaborative decision-making mechanism is required. Note that in
the literature, a few blockchain based e-voting schemes have been proposed.
However, our treasury decision-making have a number of diﬀerences: (i) con-
ventional e-voting scheme requires real-world identity authentication, while our
treasury decision-making do not need to link voters to their real identities; (ii) in
a conventional e-voting scheme, typically, each voter has one vote, while in our
treasury decision-making, the voting power is proportional to the corresponding
stake; (iii) our treasury decision-making supports liquid democracy with privacy
assurance, while no other known e-voting scheme can support liquid democracy
with provable security.
Proper selection of the voting scheme allows maximizing the number of voters
satisﬁed by the voting results as well as minimizing voters’ eﬀort. In practice,
there are two commonly used voting schemes: i) preferential or ranked voting
and ii) approval voting. An extension of approval voting is the “Yes-No-Abstain”
voting, where the voters express “Yes/No/Abstain” opinion for each proposal.
Recent theoretical analysis of this election rule with variable number of winners,
called Fuzzy threshold voting [4], shows advantages of this voting scheme for
treasury application. Therefore, we will adopt this voting scheme in our trea-
sury system. Nevertheless, we emphasize that a diﬀerent voting scheme can be
deployed to our treasury system without signiﬁcantly changing the underlying
cryptographic protocols.

A Treasury System for Cryptocurrencies 3
1.2 Our contributions
In this work, we aim to resolve the funding sustainability issue for long-term
cryptocurrency development and maintenance by proposing a novel treasury
system. The proposed treasury system is compatible with most existing oﬀ-the-
shelf cryptocurrencies/blockchain platforms, such as Bitcoin and Ethereum. We
highlight the major contributions of this work as follows.
– For the ﬁrst time, we provide a rigorous security modeling for a blockchain-
based treasury voting system that supports liquid democracy/delegative vot-
ing. More speciﬁcally, we model the voting system in the well-known Uni-
versally Composable (UC) framework [5] via an ideal functionality Ft,k,n,m
Vote .
The functionality interacts with a set voters and experts as well as k vot-
ing committee members. It allows the voters to either delegate their voting
power to some experts or vote directly on the project. If at least t out of k
voting committee members are honest, the functionality guarantees termi-
nation. Even in the extreme case, when all the voting committee members
are corrupted, the integrity of the voting result is still ensured; however, in
that case we don’t guarantee protocol termination.
– We propose an eﬃcient design of the treasury system. The system collects
funding via three potential sources: (i) Minting new coins; (ii) Taxation
from miners’ reward; (iii) Donations or charity. In an iterative process, the
treasury funds accumulate over time, and the projects are funded periodi-
cally. Each treasury period consists of pre-voting epoch, voting epoch, and
post-voting epoch, which can be deﬁned in terms of number of blockchain
blocks. In the pre-voting epoch, project proposals are submitted, and the
voters/experts are registered. In the voting epoch, the voting committee is
selected; after that, they jointly generate the voting key for the treasury
period. The voters and experts then cast their ballots. In the post-voting
epoch, the voting committee computes and signs the treasury decision. Win-
ning proposals will then be funded. Any stakeholder in the community can
participate in the treasury voting, and their voting power is proportional
to their possessed stake. In our system, we distinguish coin ownership from
stake ownership. That is, the owner of a coin can be diﬀerent from the owner
of the coin’s stake. This allows blockchain-level stake delegation without
transferring the ownership of the coin. It means that the user can delegate
his/her stake to someone else without risk of losing the ultimate control of
the coin(s). To achieve this, we introduced stake ownership veriﬁcation mech-
anism using the payload of a coin. (Without loss of generality, we assume a
coin has certain storage ﬁeld for non-transactional data.)
– We proposed the world’s ﬁrst honest veriﬁer zero-knowledge proof/argument
for unit vector encryption with logarithmic size communication. Convention-
ally, to show a vector of ElGamal ciphertexts element-wise encrypt a unit
vector, Chaum-Pedersen proofs [6] are used to show each of the ciphertexts
encrypts either 0 or 1 (via Sigma OR composition) and the product of all
the ciphertexts encrypts 1. Such kind of proof is used in many well-known

4 B. Zhang, R. Oliynykov and H. Balogun
voting schemes, e.g., Helios. However, the proof size is linear in the length
of the unit vector, and thus the communication overhead is quite signiﬁ-
cant when the unit vector length becomes larger. In this work, we propose
a novel special honest veriﬁer ZK (SHVZK) proof/argument for unit vector
that allows the prover to convince the veriﬁer that a vector of ciphertexts
(C0,...,C n−1) encrypts a unit vector e(n)
i , i∈[0,n −1] with O(log n) proof
size. The proposed SHVZK protocol can also be Fiat-Shamir transformed to
a non-interactive ZK (NIZK) proof in the random oracle model.
– We provide prototype implementation [7] of the proposed treasury system
for running and benchmarking in the real world environment. Our implemen-
tation is written in Scala programming language over Scorex 2.0 framework
and uses TwinsChain consensus for keeping the underlying blockchain. Main
functionality includes proposal submission, registration of voters, experts,
voting committee members and their corresponding deposit lock, random-
ized selection of the voting committee members among voters, distributed
key generation (6-round protocol), ballots casting, joint decryption with re-
covery in case of faulty committee members (4-round protocol), randomness
generation for the next treasury period (3-round protocol), reward payments,
deposit paybacks, and penalties for faulty actors. All implemented protocols
are fully decentralized and resilient up to 50% of malicious participants.
During veriﬁcation we launched a testnet that consisted of 12 full nodes
successfully operating tens of treasury periods with diﬀerent parameters.
2 Preliminaries
2.1 Notations
Throughout this paper, we will use the following notations. Let λ ∈N be the
security parameter. Denote the set {a,a + 1,...,b }by [a,b], and let [ b] denote
[1,b]. We abbreviate probabilistic polynomial time as PPT. By a(ℓ), we denote
a length- ℓ vector (a1,...,a ℓ). When S is a set, s ←S stands for sampling s
uniformly at random from S. When A is a randomised algorithm, y ←A(x)
stands for running A on input x with a fresh random coin r. When needed, we
denote y:= A(x; r) as running Aon input xwith the explicit random coin r. Let
poly(·) and negl(·) be a polynomially-bounded function and negligible function,
respectively.
2.2 The blockchain abstraction
Without loss of generality, we abstract the underlying blockchain platform en-
compasses the following concepts.
◦Coin. We assume the underlying blockchain platform has the notion of
Coins or its equivalent. Each coin can be spent only once, and all the value of
coin must be consumed. As depicted in Fig. 1, each coin consists of the following
4 attributes:

A Treasury System for Cryptocurrencies 5
Value
Coin
Cond
Payload
Tx
Tx 
In1
Inn …
Veriﬁcation
DataOut1
Outm
…
Coin ID
Payload
Fig. 1: Coin and transaction structure.
– Coin ID : It is an implicit attribute, and every coin has a unique ID that
can be used to identify the coin.
– Value: It contains the value of the coin.
– Cond : It contains the conditions under which the coin can be spent.
– Payload: It is used to store any non-transactional data.
◦Address. We also generalize the concept of the address. Conventionally, an
address is merely a public key, pk, or hash of a public key, h(pk). To create
coins associated with the address, the spending condition of the coin should be
deﬁned as a valid signature under the corresponding public keypk of the address.
In this work, we deﬁne an address as a generic representation of some spending
condition. Using the recipient’s address, a sender is able to create a new coin
whose spending condition is the one that the recipient intended; therefore, the
recipient may spend the coin later.
◦Transaction. Each transaction takes one or more (unspent) coins, denoted
as {Ini}i∈[n], as input, and it outputs one or more (new) coins, denoted as
{Outj}j∈[m]. Except special transactions, the following condition holds:
n∑
i=1
Ini.Value ≥
m∑
j=1
Outj.Value
and the diﬀerence is interpreted as transaction fee. As shown in Fig. 1, the trans-
action has a Veriﬁcation data ﬁeld that contains the necessary veriﬁcation data
to satisfy all the spending conditions of the input coins {Ini}i∈[n]. In addition,
each transaction also has a Payload ﬁeld that can be used to store any non-
transactional data. We denote a transaction as Tx(A; B; C), where A is the set
of input coins, B is the set of output coins, and C is the Payload ﬁeld. Note that
the veriﬁcation data is not explicitly described for simplicity.
2.3 Additively homomorphic encryption
In this work, we adopt the well known threshold lifted ElGamal encryption
scheme as the candidate of the threshold additively homomorphic public key
cryptosystem. Let Gengp(1λ) be the group generator that takes input as the
security parameter λ∈N, and output the group parameters param, which deﬁne
a multiplicative cyclic group G with prime order p, where |p|= λ. We assume

6 B. Zhang, R. Oliynykov and H. Balogun
the DDH assumption holds with respect to the group generator Gengp. More
speciﬁcally, the additively homomorphic cryptosystem HE consists of algorithms
(KeyGenE,Enc,Add,Dec) as follows:
– KeyGenE(param): pick sk ←Z∗
q and set pk := h= gsk, and output ( pk,sk).
– Encpk(m; r): output e:= (e1,e2) = (gr,gmhr).
– Add(c1,...,c ℓ): output c:= (∏ℓ
i=1 ci,1,∏ℓ
i=1 ci,2).
– Decsk(e): output Dlog(e2 ·e−sk
1 ), where Dlog(x) is the discrete logarithm of x.
(Note that since Dlog(·) is not eﬃcient, the message space should be a small
set in practice.)
Lifted ElGamal encryption is additively homomorphic, i.e.
Encpk(m1; r1) ·Encpk(m2; r2) = Encpk(m1 + m2; r1 + r2) .
2.4 Pedersen commitment
In the unit vector zero-knowledge proof, we use Pedersen commitment as a
building block. It is perfectly hiding and computationally binding under the
discrete logarithm assumption. More speciﬁcally, it consists of the following 4
PPT algorithms. Note that those algorithms (implicitly) take as input the same
group parameters, param ←Gengp(1λ).
– KeyGenC(param): pick s←Z∗
q and set ck := h= gs, and output ck.
– Comck(m; r): output c:= gmhr and d:= (m,r).
– Open(c,d): output d:= (m,r).
– Verifyck(c,d): return valid if and only if c= gmhr.
Pedersen commitment is also additively homomorphic, i.e.
Comck(m1; r1) ·Comck(m2; r2) = Comck(m1 + m2; r1 + r2) .
2.5 Universal composability
We model our system security under the standardUniversal Composability (UC)
framework. The protocol is represented as interactive Turing machines (ITMs),
each of which represents the program to be run by a participant. Adversarial
entities are also modeled as ITMs.
We distinguish between ITMs (which represent static objects, or programs)
and instances of ITMs (ITIs), that represent interacting processes in a running
system. Speciﬁcally, an ITI is an ITM along with an identiﬁer that distinguishes
it from other ITIs in the same system. The identiﬁer consists of two parts: A
session-identiﬁer (SID) which identiﬁes which protocol instance the ITI belongs
to, and a party identiﬁer (PID) that distinguishes among the parties in a protocol
instance. Typically the PID is also used to associate ITIs with “parties” that
represent some administrative domains or physical computers.

A Treasury System for Cryptocurrencies 7
The model of computation consists of a number of ITIs that can write on
each other’s tapes in certain ways (speciﬁed in the model). The pair (SID,PID)
is a unique identiﬁer of the ITI in the system. With one exception (discussed
within) we assume that all ITMs are PPT.
We consider the security of the voting system in the UC framework with
static corruption in the random oracle (RO) model. The security is based on
the indistinguishability between real/hybrid world executions and ideal world
executions, i.e., for any possible PPT real/hybrid world adversary Awe will
construct an ideal world PPT simulator Sthat can present an indistinguishable
view to the environment Zoperating the protocol.
2.6 UC ideal functionalities
In this work, we adopt the following UC ideal functionalities as building blocks.
The distributed key generation functionality. We use the key generation
functionality Ft,k
DKG [8] for threshold key generation of the underlying public key
crypto system. The functionality depicted in Fig. 2, interacts with a set of com-
mittees C:= {C1,..., Ck}to generate a public key pk and deal the corresponding
secret key sk among the committees. In Appendix A, we give a detailed descrip-
tion of our threshold distributed key generation protocol adopted from Gennaro
et al. [9].
The functionality Ft,k
DKG interacts with a set of voting committees C :=
{C1,..., Ck}, any party P, and the adversary A. It is parameterised with
variable J and algorithms KeyGen() and Deal().
Initially, set J:= ∅.
– Upon receiving (KeyGen,sid) from Cj ∈C, set J:= J∪{ Cj}.
– If |J|= k, generate a public key pair ( pk,sk) ←KeyGen(1λ) and
compute (sk1,..., skk) ←Deal(t,k, sk). For j ∈[k], send message
(PrivKey,sid,skj) to Cj.
– Upon receiving (ReadPK,sid) from any party p∈P, if pk is not deﬁned
yet, ignore the request. Otherwise, it sends ( PublicKey,sid,pk) to the
requestor.
Functionality Ft,k
DKG
Fig. 2: Functionality Ft,k
DKG

8 B. Zhang, R. Oliynykov and H. Balogun
The global clock functionality. The global clock functionality GClock inter-
acts with all the parties. To handle oﬄine parties, the parties can register and
deregister themselves to the functionality GClock, and the clock will advance if
and only if all the registered honest parties have sent Tick command to it.
The functionality interacts with a set of parties P, a set of functionalities F,
and the adversary A. It is parametrized with variable τ, P, and F.
Initially, set τ := 0, P := ∅, and F := ∅.
Registration:
– Upon receiving (Register,sid) from party p, set P := P ∪{p}and create
variable Tp := 0.
– Upon receiving (Register,sid) from functionality F, set F := F ∪{F}
and create variable TF := 0.
– Upon receiving (De-Register,sid) from party p, set P := P \{p}and
remove variable Tp.
– Upon receiving (De-Register,sid) from functionality F, set
F := F \{F} and remove variable TF.
– Upon receiving (Get-Reg,sid) from A, return (Get-Reg,sid,P,F) to
A.
Synchronization:
– Upon receiving (Tick,sid) from party p∈P, set Tp := 1; Invoke
procedure Clock-Update and send (Tick,sid,p) to A.
– Upon receiving (Tick,sid) from functionality F∈ F, set TF := 1; Invoke
procedure Clock-Update and send (Tick,sid,F) to F.
– Upon receiving (GetTime,sid) from any participant, return
(GetTime,sid,τ) to the requester.
Procedure Clock-Update:
– If TF = 1 for all F∈ F and Tp = 1 for all the honest p∈P, then set
τ := τ + 1, and reset TF := 0 for all F∈ F and Tp := 0 for all p∈P.
Functionality GClock
Fig. 3: Functionality GClock
The ledger ideal functionality. Our protocol is built on top of the state-
of-the-art ledger ideal functionality proposed by Badertscher et al., [10]. For
completeness, we recap the functionality here. As shown, in Fig. 4, the function-
ality maintains the set of registered parties P, the (sub-)set of honest parties

A Treasury System for Cryptocurrencies 9
H⊆ P, and the (sub-set) of de-synchronized honest parties PDS ⊂H. The set
P,PDS,Hare all initially set to ∅. When a new honest party is registered, it is
added to all PDS (hence also to Hand P and the current time of registration is
also recorded; similarly, when a party is deregistered, it is removed from both P
and PDS. For each party p ∈P, the functionality maintains a pointer pti (ini-
tially set to 1) and a current state view statei:= ϵ (initially set to empty). The
functionality also keeps track of the timed honest-input sequence in a vector IT
H
(initially IT
H := ϵ)
3 The Treasury System
3.1 Entities
As mentioned before, the core of a treasury system is a collaborative decision-
making process, and all the stake holders are eligible to participate. Letk,ℓ,n,m
be integers in poly( λ). The stake holders may have one or more of the following
roles.
– The project owners O:= {O1,..., Ok}are a set of stake holders that have
proposed project for support.
– The voting committees C:= {C1,..., Cℓ}are a set of stake holders that are
responsible for generating the voting public key and announcing the voting
result.
– The voters V := {V1,..., Vn}are a set of stake holders that lock certain
amount of stake to participate.
– The experts E:= {E1,..., Em}are a special type of voters that have spe-
cialist knowledge and expertise in some ﬁeld.
3.2 Enabling stake delegation
In our treasury system, the voting power of a voter is proportional to the cor-
responding locked stake value. We distinguish between the ownership of a stake
and the ownership of the actual coin; namely, the stake of a coin can be “owned”
by a user other than the coin owner. This feature allows us to delegate the stake
of a coin to someone else without transferring the ownership of the coin. To
achieve this, we introduce a stake attribute, denoted as S-Attr, that can be at-
tached to the Payload of a coin. The user who can provide the required data that
satisﬁes the condition(s) in the S-Attr is able to claim the stake of the coin. Of
course, the stake of an unspent coin can only be claimed at most once at any
moment. In practice, to ensure this, additional checks should be executed. If the
user A wants to delegate the stake of a coin to the user B, he simply needs to
put the user B’s desired S-Attr in the Payload of the coin. Note that this type of
delegation is persistent in the sense that if the coin is not consumed, the S-Attr
of the coin remains the same. This feature allows users to stay oﬄine while the
stake of their coins can still be used in the treasury process by the delegatees.

10 B. Zhang, R. Oliynykov and H. Balogun
It is parametrized by four algorithmsValidate,ExtendPolicy,Blockify, and predict-time,
along with two parameters:windowSize,Delay ∈N. The functionality manages variables
state,NxtBC,buﬀer,τL and τstate.
Initially, state := τstate := NxtBC :=ϵ,buﬀer := ∅,τL =1.
The functionality maintains the set of registered partiesP, the (sub-)set of honest par-
ties H ⊆P, and the (sub-set) of de-synchronized honest partiesPDS ⊂ H. The set
P,PDS,Hare all initially set to∅. When a new honest party is registered, it is added
to all PDS (hence also toHand P and the current time of registration is also recorded;
similarly, when a party is deregistered, it is removed from bothP and PDS. For each
party p ∈P, the functionality maintains a pointerpti (initially set to 1) and a current
state view statei:= ϵ (initially set to empty). The functionality also keeps track of the
timed honest-input sequence in a vectorIT
H (initially IT
H := ϵ)
Upon receiving any inputI from any party or from the adversary, send (GetTime,sid)
to GClock and upon receiving response (GetTime,sid,τ) set τL := τ and do the follow-
ing:
– Let ˆP ⊆PDS denote the set of desynchronized honest parties that were registered
at time τ′ ≤τL −Delay. Set PDS := PDS \P.
– If I was received from an honest partyp∈P :
• Set IT
H := IT
H||(I,p,τ L);
• Compute N = (N1,..., Nl) :=ExtendPolicy(IT
H,state,NxtBC,buﬀer,τstate) and
if N ̸= ϵ set state := state||Blockify((Nl1)||..., Blockify((Nl)) and
τstate := τstate||τl
L, where τl
L = τL||,...τ L
• For eachBTX ∈buﬀer: if (Validate,BTX,state,buﬀer,) = 0 then deleteBTX from
buﬀer. Also resetNxtBC := ϵ
• If there existspj ∈H such that |state|−ptj >windowSize or ptj <|state|, then
set ptk := |state|for all pk ∈H\ PDS
– Depending on the above inputI and its sender’s ID,FLedger executes the
corresponding code from the following list:
• Submitting a transaction:If I = (Submit,sid,tx ) and is received from a party
p∈P or from A(on behalf of a corrupted partyp) do the following
∗ Choose a unique transaction ID txid and setBTX := (tx,txid,τ L,pi)
∗ if Validate(BTX),state,buﬀer = 1, then buﬀer := buﬀer ∪{BTX}.
∗ Send (Submit,BTX) to A
• Reading the state:If I = (Read,sid) is received from a partyp∈P then set
state|min{pti,|state|} and return (Read,sid, statei) to the requester. If the
requester is Athen send (state,buﬀer,IT
H) to A
• Maintaining the ledger state:If I = (Maintain-Ledger,sid,minerID ) is
received by an honest partyp in P and (after updatingIT
H as above)
predcit-time(IT
H) = ˆτ >τL then send (Tick,sid) to GClock. Else, send I to A.
• The adversary proposing the next block:If
I = (Next-Block,hFlag,(txid1,...,txid l)) is sent from the adversary, update
NxtBC as follows:
∗ Set listOfTxid ←ϵ
∗ For i= 1,...,l do: if there exists
BTX := (x,txid,minerID,τ L,pi) ∈buﬀer with ID txid= txidi then set
lisOfTxid := listOfTxid||txidi
∗ Finally, set NxtBC := NxtBC||(hFlag,listOfTxid ) and output
(Next-Block,ok) to A
• The adversary setting state-slackness:If
I = (Set-Slack,(pi1, ˆpti1),(pil, ˆptil),) with {pi1,...,p il}⊆H\ PDS is
received from the adversaryAdo the following:
∗ If for allj ∈[l] :|state|− ˆptij ≥stateij|,setpti := ˆpti for every j ∈[l] and
return (Set-Slack,ok) to A.
∗ Otherwise set ptj := state for all j ∈[l]
• The adversary setting the state for desynchronised parties:If
I = (DEesync-State,(pi1,state′
il)) with {pi1,...,p il}⊆ PDS is received from
the adversary A, set stateij := state′
ij for each j ∈[l] and return
(Desync-State,ok) to A.
Functionality FLedger
Fig. 4: Functionality FLedger

A Treasury System for Cryptocurrencies 11
Project proposing stage
Voter/Expert registration stage
Pre-voting epoch 
Committee 
selection stage
Key setup 
stage
Voting epoch 
Ballot 
casting stage
Tally 
stage
Post-voting epoch 
Execution 
stage
Fig. 5: Treasury system epochs.
However, this type of delegation only guarantees pseudonymity-based privacy
level, as anyone can learn “who owns” the stake of the coin by checking the
S-Attr of the coin.
3.3 System overview
A treasury system consists of iterative treasury periods. A treasury period
can be divided into three epochs: pre-voting epoch, voting epoch, and post-
voting epoch. As shown in Figure 5, the pre-voting epoch includes two con-
current stages: project proposing stage and voter/expert registration stage. In
the project proposing stage, the users can submit project proposals, asking for
treasury funds. Meanwhile, the interested stake holders can register themselves
as either voters and/or experts to participate in the decision making process
by locking certain amount of their stake in the underlying cryptocurrency. The
voter’s voting power is proportional to his locked stake; while, the expert’s vot-
ing power is proportional to the amount of voting power delegated to him. (We
will explain delegation in details later.) Analogously, the voter’s (resp. expert’s)
treasury reward is proportional to his locked stake (resp. his received delega-
tions).
At the beginning of the voting epoch, there is a voting committee selection
stage, during which, a set of voting committee members will be randomly selected
from the registered voters who are willing to be considered for selection to the
committee. The probability of being selected is proportional to locked stake.
After the voting committee members are selected, they jointly run a distributed
key generation protocol to setup the election public key. The voters and experts
can then submit their ballots in the ballot casting stage. Note that the voters
can either delegate their voting powers to some expert or vote directly on the
projects. For each project, voters can delegate to diﬀerent experts. At the post-
voting epoch, the voting committee members jointly calculate and announce
the tally result on the blockchain. Finally, in the execution stage, the winning
projects are funded, and the voters, experts and voting committee members are
rewarded (or punished) accordingly. These transactions will be jointly signed
and executed by the voting committee. Meanwhile, the committee members also
jointly commit to a random seed, which will be used to select a new voting
committee in the next treasury period.

12 B. Zhang, R. Oliynykov and H. Balogun
3.4 Treasury funding sources
As earlier motivated, treasury funding, perhaps is the most crucial ingredient in
a decentralised community-controlled decision-making system. It must not only
be regular, but also sourced from decentralised means. That is, source of funding
for treasury system should not introduce centralisation into the system. To this
end, desirable properties from the funding sources are secure, sustainable and
decentralized.
We note that although not all potential funding sources possess these proper-
ties, a clever combination of some of these sources satisfy the set out requirement.
Therefore, we propose 3 major sources of funding for the treasury system.
– Taxation/Haircut from block reward: Most blockchain platforms oﬀer block
rewards (including transaction fees) to proposers of new blocks, incentiviz-
ing honest behaviour. A fraction of such block rewards can be taken and
contributed to the decentralised treasury. This type of funding source is sus-
tainable as long as the block rewards of the underlying blockchain platform
remain. However, block rewards may ﬂuctuate over time, and it could cause
unpredictability of the available funds.
– Minting new coins: Coin minting represents, perhaps, the most sustainable
funding source of the potential sources. At the beginning of each treasury
period, certain amount of new coins are created to fund projects. However,
minting may cause inﬂation in terms of the ﬁat market value of the under-
lying cryptocurrency.
– Donations or charity: Donation is an opportunistic ad-hoc but unsustainable
funding source. Therefore, meticulous blockchain development planning is
diﬃcult if donations is the only means of treasury funding.
3.5 Project proposal
To ensure input independency and eliminate unfair advantage caused by late
submission, we adopt a two-stage project proposal scheme. In the ﬁrst stage,
the project owners O1,..., Ok post an encryption of their project proposals
(encrypted under the election public key of the previous treasury period) to
the blockchain. At the end of pre-voting epoch and the beginning of the vot-
ing epoch, the voting committee of previous treasury period will jointly decrypt
those project proposals (together with revealing the seed, which will be explained
later).
To commit a project, the project owner needs to submit a special transaction
in form of
Tx
(
{Ini}n
i=1; TCoin; {Project,TID,P-Enc,Addr}
)
,
where {Ini}n
i=1 are the input coins, and TCoin is a special output coin whose
spending condition is deﬁned as, the coin can only be spent according to the
corresponding treasury decision (cf. Subsection “supplying the treasury”, be-
low). Moreover, the coin value TCoin.Value ≥αmin, where αmin is the minimum
required fee for a project proposal to prevent denial-of-service attacks. In the

A Treasury System for Cryptocurrencies 13
Payload ﬁeld, Project is a tag that indicates it is a special project proposal
transaction; TID is the treasury ID that is used to uniquely identify a treasury
period; P-Enc is the encrypted project proposal, and Addr is the return address
for the project owner to receive money if the project succeeds in getting funded.
3.6 Voter/Expert registration
In order to register to be a voter, a stake holder (or a set of stake holders) need(s)
to submit a special voter registration transaction in form of
Tx
(
{Ini}n
i=1; TCoin;
{
Voter-Reg,TID,{Si}ℓ
i=1,S-Cond,vk,Addr
})
,
where {Ini}n
i=1 are the input coins, and TCoin is a special output coin whose
spending condition is deﬁned in Subsection “supplying the treasury”, below.
In the Payload ﬁeld, Voter-Reg is a tag that indicates it is a special voter
registration transaction; TID is the treasury ID that is used to uniquely identify
a treasury period; {Si}ℓ
i=1 are the freezed unspent coins that will be used to claim
stake value, S-Cond is the required data that satisﬁes all the stake attributes of
{Si}ℓ
i=1, vk is a freshly generated signature key; and Addr is the return address
for the voter to receive treasury reward. The voter’s ID is deﬁned as the hash of
vk, denoted as Vi := hash(vk).
Let βmin be a predeﬁned system parameter. To register as an expert, a stake
holder (or a set of stake holders) need(s) to deposit exact βmin amount of coins,
by submitting a special expert registration transaction:
Tx
(
{Ini}n
i=1; TCoin; {Expert-Reg,TID,vk,Addr}
)
,
where {Ini}n
i=1 are the input coins, and TCoin is a special output coin whose
spending condition is deﬁned in Subsection “supplying the treasury”. Moreover,
the coin value TCoin.Value ≥βmin. In the Payload ﬁeld, Expert-Reg is a tag
that indicates it is a special expert registration transaction; TID is the treasury
ID that is used to uniquely identify a treasury period; vk is a freshly generated
signature key; and Addr is the return address for the expert to receive treasury
reward.
The expert’s ID is deﬁned as the hash of vk, denoted as Ej := hash(vk). Note
that the expert does not gain reward based on the amount of deposited coins,
so it is not rational to deposit signiﬁcantly more than βmin coins in practice.
3.7 Voting committee selection
At the beginning of the voting epoch, the voting committee of the previous
treasury epoch jointly reveal the committed seed, seed.
Let sti = ∑ℓ
j=1 Sj.Value for all the stake coins Sj claimed in the payload of
the voter registration transaction of vki, i.e. sti is the total stake amount claimed
by vki. Once seed is announced, any registered voter, who have an address vki

14 B. Zhang, R. Oliynykov and H. Balogun
with claimed stake sti, can volunteer to participate in the voting committee if
the following inequality holds:
hash
(
vki,signsk′
i
(seed)
)
≤sti ·T
where sk′
i is the corresponding signing key for vki, and T is a pre-deﬁned thresh-
old. When the inequation holds, he/she can submit a special registration trans-
action in form of
Tx
(
{Ini}n
i=1; TCoin;
{
VC-Reg,TID,vk, ˜pk,signsk′
i
(seed),Addr
})
,
where {Ini}n
i=1 are the input coins, and TCoin is a special output coin whose
spending condition is deﬁned in Subsection “supplying the treasury”, below.
Moreover, the coin value TCoin.Value ≥γmin. In the Payload ﬁeld, VC-Reg is a
tag that indicates it is a special voting committee registration transaction; TID
is the treasury ID that is used to uniquely identify a treasury period; vk is a
freshly generated signature veriﬁcation key; ˜pk is a freshly generated public key
for a pre-deﬁned public key cryptosystem; signsk′
i
(seed) is the signature of seed
under the signing key corresponding to vki; and Addr is the return address for
the committee member to receive treasury reward. The threshold T is properly
deﬁned to ensure that approximately λ′= ω(log λ) (e.g., λ′= polylog(λ)) com-
mittee members are selected, assuming constant fraction of them will be active.
Note that, analogous to most proof-of-stake systems, T needs to be updated
frequently. See [11] for a common threshold/diﬃculty T adjustment approach.
Remark. Jumping ahead, we will need honest majority of the voting committee
to guarantee voter privacy and protocol termination. Assume the majority of
the stake of all the registered voters is honest; therefore, the probability that a
selected committee member is honest is p= 1/2 + ε for any ε∈(0,1/2]. Let X
be the number of malicious committee members selected among all λ′committee
members. Since λ′= ω(log λ), by Chernoﬀ bound, we have
Pr[X ≥λ′/2] = Pr[X ≥(1 + δ)(1/2 −ε)λ′]
<exp(−δ2(1/2 −ε)λ′/4)
= 1
exp(ω(log λ)) = negl(λ)
for δ= 2ε/(1 −2ε).
3.8 Supplying the treasury
Treasury funds are accumulated via a collection of coins. For example, the tax-
ation/haircut of the block reward can be collected through a special transaction
at the beginning of each block. The output of this type of transactions are new
coins, whose spending condition, Cond, speciﬁes that the coin can only be spent
according to the corresponding treasury decision. As will be mentioned in de-
tails later, the treasury funds will be distributed in forms of transactions jointly
made by the corresponding voting committee; therefore, the coins dedicated to

A Treasury System for Cryptocurrencies 15
certain treasury period must allow the voting committee in that treasury period
to jointly spend. More speciﬁcally, there are λ′ committee members selected at
the beginning of the voting epoch of each treasury period. Let seedTIDi denote
the seed opened in the treasury period indexed by TIDi. Let {vkj}ℓ
j=1 be the
set of signature veriﬁcation keys in the valid committee registration transactions
proposed by vki such that the condition hash
(
vki,signsk′
i
(seed)
)
≤sti ·T holds.
The treasury coin can be spent in a transaction if majority of the signatures
w.r.t. {vkj}ℓ
j=1 are present.
3.9 Handling the treasury speciﬁc data in the payload
Note that typically the underlying blockchain transaction validation rules do
not take into account of the content stored in the payload of a transaction.
Therefore, additional checks are needed for the treasury speciﬁc transactions.
More speciﬁcally, we verify the payload data of those transactions with additional
algorithms. In particular, a coin must be frozen during the entire treasury period
in order to claim its stake. This can be done by, for example, adding extra
constrain in spending condition, saying that the coin cannot be spent until the
certain block height, which is no earlier than the end of the treasury period.
Furthermore, the stake of one coin can only be claimed once during each treasury
period.
3.10 Decision making
During the decision making, the voting committee members, the voters, and the
experts follow the protocol description in Sec. 4, below. It covers the key gen-
eration stage, the ballot casting stage, and the tally stage. In terms of security,
as shown before, with overwhelming probability, the majority of the committee
members are honest, which can guarantee voter privacy and protocol termina-
tion. In an unlikely extreme case, where all the voting committee members are
corrupted, our voting scheme can still ensure the integrity of the voting result.
If a cheating voting committee member is detected, she will lose all her deposit.
For each project, the voters/experts need to submit an independent ballot.
The voter can either delegate his voting power to some expert or directly ex-
press his opinion on the project; whereas, the expert shall only vote directly on
the project. In our prototype, we adopt the “ YES-NO-ABSTAIN” type of vot-
ing scheme. More speciﬁcally, after the voting, the project proposals are scored
based on the number of yes votes minus the number of no votes. Proposals that
got at least 10% (of all votes) of the positive diﬀerence are shortlisted, and all
the remaining project proposals are discarded. Shortlisted proposals are ranked
according to their score, and the top ranked proposals are funded in turns until
the treasury fund is exhausted. Each of the voting committee members will then
sign the treasury decision and treasury transactions, and those transactions are
valid if it is signed by more than t-out-of-k voting committee members.

16 B. Zhang, R. Oliynykov and H. Balogun
3.11 Post-voting execution
Certain proportion (e.g. 20%) of the treasury fund will be used to reward the
voting committee members, voters and experts. The voting committee members
Cℓ ∈C will receive a ﬁx amount of reward, denoted asζ1. Note that as the voting
committee members are required to perform more actions in the next treasury
period, their reward will only be transferred after the completion of those actions
at the end of pre-voting epoch in the next treasury period. The voter Vi ∈V
will receive reward that is proportional to his/her deposited amount, denoted as
ζ2 ·sti, where sti is the amount of the stake claimed byVi. The expert Ej ∈E will
receive reward that is proportional to his/her received delegations, denoted as
ζ3 ·Dj, where Dj is the amount of delegations that Ej has received. Meanwhile,
if a voting committee member cheats or an expert fails to submit a valid ballot,
he/she will lose the deposited coin as a punishment. In addition, the voting
committee members will jointly generate and commit to a random seed for the
next treasury period, in a protocol depicted as follows. To generate and commit
a random seed, voting committee members Cℓ, ℓ ∈[k] needs to invoke a coin
ﬂipping protocol. However, the cost of such a protocol is very small when they
already jointly setup a public key pk. More speciﬁcally, each voting committee
members Cℓ, ℓ ∈[k] will pick a random group element Rℓ ←G and post the
encryption of it, Cℓ ←Encpk(Rℓ) to the blockchain. C := ∏k
ℓ=1 Cℓ is deﬁned as
the committed/encrypted seed for the next treasury period. Note that C can be
jointly decrypted as far as majority of the voting committee members are honest,
and the malicious voting committee members cannot inﬂuence the distribution
of the seed.
3.12 Partitionary budgeting
The main goal of treasury is decentralized community-driven self-sustainable
cryptocurrency development through projects funding and adoption. The naive
approach is to select projects for funding by ranking all submitted proposals
according to the number of votes they get and take a number of projects whose
total budget does not exceed the treasury budget. However, there exists a risk
of underfunding vital areas due to numerous project submissions and inﬂated
discussions on some other areas. We can categorize proposals and allocate a
certain amount of treasury funding for each category to independently guarantee
funds to every vital area.
Analysis of existing blockchain development funding [2] reveal marketing, PR,
integration, software development and organisational costs are most prominent
categories. Considering this and general business development rules, we propose
to include (at least) the following categories.
– Marketing. This covers activities devoted to cryptocurrency market share
growth; market analysis, advertisement, conferences, etc. The vastness of the
area demands this category should take the biggest percent of the funding
budget.

A Treasury System for Cryptocurrencies 17
– Technology adoption. This includes costs needed for wider spreading of
cryptocurrency; integration with various platforms, websites and applica-
tions, deployment of ATMs etc.
– Development and security. This includes costs allocated for funding core
and non-core development, security incident response, patch management,
running testnets, as well as similar critical technology areas.
– Support. This category includes user support, documentation, maintaining
of web-infrastructure needed for the community and other similar areas.
– Organization and management. This category includes costs on team
coordination and management, legal support, etc.
– General. This includes projects not covered by the earlier categories, e.g.,
research on prospective technologies for cryptocurrency application, external
security audit, collaboration with other communities, charity and so on.
It should be noted that the given list of categories is not ﬁnal, and treasury
deployment in cryptocurrencies will take into account speciﬁc of a given solution
based on its development eﬀort.
Nevertheless, having such an approach guarantees that critical areas for cryp-
tocurrency routine operation, support and development will always get funding
via treasury, which in turn, guarantees cryptocurrency self-sustainability.
4 The proposed voting scheme
4.1 Security modeling
The entities involved in the voting schemes are a set of voting committee mem-
bers C:= {C1,..., Ck}, a set of voters V:= {V1,..., Vn}, and a set of experts
E:= {E1,..., Em}. We consider the security of our treasury voting scheme in
the UC framework with static corruption. The security is based on the indistin-
guishability between real/hybrid world executions and ideal world executions,
i.e., for any PPT real/hybrid world adversary Awe will construct an ideal world
PPT simulator Sthat can present an indistinguishable view to the environment
Zoperating the protocol.
The Ideal world execution. In the ideal world, the voting committee C,
the voters V, and the experts E only communicate to an ideal functionality
Ft,k,m,n
Vote during the execution. The ideal functionality Ft,k,m,n
Vote accepts a number
of commands from C,V,E. At the same time it informs the adversary of certain
actions that take place and also is inﬂuenced by the adversary to elicit certain
actions. The ideal functionality Ft,k,m,n
Vote is depicted in Fig. 6, and it consists of
three phases: Preparation, Voting/Delegation, and Tally.
Preparation phase. During the preparation phase, the voting committees
Ci ∈C need to initiate the voting process by sending ( Init,sid) to the ideal
functionality Ft,k,m,n
Vote . The voting will not start until all the committees have
participated the preparation phase.

18 B. Zhang, R. Oliynykov and H. Balogun
The functionality Ft,k,m,n
Vote interacts with a set of voting committees C :=
{C1,..., Ck}, a set of voters V := {V1,..., Vn}, a set of experts E :=
{E1,..., Em}, and the adversary S. It is parameterized by a delegation cal-
culation algorithm DelCal (described in Fig. 7) and a tally algorithm TallyAlg
(described in Fig. 8) and variables φ1,φ2, τ, J1,J2,J3, T1 and T2. Denote
Ccor and Chonest as the set of corrupted and honest voting committees, respec-
tively.
Initially, φ1 = ∅, φ2 = ∅, τ = ∅, J1 = ∅, J2 = ∅, and J3 = ∅.
Preparation:
– Upon receiving (Init,sid) from the voting committee Ci ∈C, set
J1 := J1 ∪{Ci}, and send a notiﬁcation message ( InitNotify,sid,Ci) to
the adversary S.
Voting/Delegation:
– Upon receiving (Vote,sid,vi) from the expert Ei ∈E, if |J1|<t, ignore
the request. Otherwise, record ( Ei,Vote,vi) in φ1; send a notiﬁcation
message (VoteNotify,sid,Ei) to the adversary S. If |Ccor|≥ t, then
additionally send a message ( Leak,sid,Ei,Vote,vi) to the adversary S.
– Upon receiving (Cast,sid,vj,αj) from the voter Vj ∈V, if |J1|<t,
ignore the request. Otherwise, record ( Vj,Cast,vj,αj) in φ2; send a
notiﬁcation message (CastNotify,sid,Vj,αj) to the adversary S. If
|Ccor|≥ t, then additionally send a message ( Leak,sid,Vj,Cast,vj) to
the adversary S.
Tally:
– Upon receiving (DelCal,sid) from the voting committee Ci ∈C, set
J2 := J2 ∪{Ci}, and send a notiﬁcation message
(DelCalNotify,sid,Ci) to the adversary S.
– If |J2 ∪Chonest|+ |Ccor|≥ t, send (LeakDel,sid,DelCal(E,φ2)) to S.
– If |J2|≥ t, set δ←DelCal(E,φ2).
– Upon receiving (Tally,sid) from the voting committee Ci ∈C, set
J3 := J3 ∪{Ci}, and send a notiﬁcation message ( TallyNotify,sid,Ci)
to the adversary S.
– If |J3 ∪Chonest|+ |Ccor|≥ t, send (LeakTally,sid,TallyAlg(V,E,φ1,φ2,δ))
to S.
– If |J3|≥ t, set τ ←TallyAlg(V,E,φ1,φ2,δ).
– Upon receiving (ReadTally,sid) from any party, if δ= ∅∧ τ = ∅
ignore the request. Otherwise, return ( ReadTallyReturn,sid,(δ,τ)) to
the requester.
The ideal functionality Ft,k,m,n
Vote
Fig. 6: The ideal functionality Ft,k,m,n
Vote

A Treasury System for Cryptocurrencies 19
Voting/Delegation phase. During the voting/delegation phase, the expert
Ei ∈E can vote for his choice vi by sending ( Vote,sid,v i) to the ideal func-
tionality Ft,k,m,n
Vote . Note that the voting choice vi is leaked only when majority of
the voting committees are corrupted. The voter Vj ∈V, who owns αj stake, can
either vote directly for his choice vj or delegate his voting power to an expert
Ei ∈E. Similarly, when all the voting committees are corrupted, Ft,k,m,n
Vote leaks
the voters’ ballots to the adversary S.
Tally phase. During tally phase, the voting committee Ci ∈ Csends
(DelCal,sid) to the ideal functionality Ft,k,m,n
Vote to calculate and reveal the
delegations received by each expert. After that, they then send ( Tally,sid) to
the ideal functionality Ft,k,m,n
Vote to open the tally. Once all the committees have
opened the tally, any party can read the tally by sending ( ReadTally,sid) to
Ft,k,m,n
Vote . Note that due to the nature of threshold cryptography, the adversaryS
can see the voting tally result before all the honest parties. Hence, the adversary
can refuse to open the tally depending on the tally result. The tally algorithm
TallyAlg is described in Fig. 8.
The real/hybrid world execution. In the real/hybrid world, the treasury
voting scheme utilises a number of supporting components. Those support-
ing components are modelled as ideal functionalities. First of all, we need a
blockchain functionality FLedger (cf. Fig. 4) to model the underlying blockchain
infrastructure that the treasury system is built on. We then use the key gen-
eration functionality Ft,k
DKG [8] for threshold key generation of the underlying
public key crypto system. Finally, a global clock functionality GClock(cf. Fig. 3)
is adopted to model the synchronised network environment. Let EXECΠ,A,Z de-
note the output of the environment Z when interacting with parties running
the protocol Π and real-world adversary A. Let EXECF,S,Z denote output of Z
when running protocol φinteracting with the ideal functionality Fand the ideal
adversary S.
Deﬁnition 1. We say that a protocol Π UC-realizes Fif for any adversary A
there exists an adversary Ssuch that for any environment Zthat obeys the rules
of interaction for UC security we have EXECΠ,A,Z≈EXECF,S,Z.
4.2 The voting scheme
Let m be the number of experts and n be the number of voters. Let e(m)
i ∈
{0,1}m be the unit vector where its i-th coordinate is 1 and the rest coor-
dinates are 0. We also abuse the notation to denote e(ℓ)
0 as an ℓ-vector con-
tains all 0’s. We use Encpk(e(ℓ)
i ) to denote coordinate-wise encryption of e(ℓ)
i , i.e.
Encpk(e(ℓ)
i,1),..., Encpk(e(1)
i,ℓ), where e(ℓ)
i = (e(ℓ)
i,1,...,e (ℓ)
i,ℓ).

20 B. Zhang, R. Oliynykov and H. Balogun
Input: a set of the expert labels E, and a set of ballots φ2
Output: the delegation result δ
Init:
– For i∈[1,m], create and initiate Di = 0.
Delegation interpretation:
– For each ballot B ∈φ2: parse B in form of ( Vj,Cast,vj,αj); if
vj = (Delegate,Ei) for some Ei ∈E, then Di := Di + αj.
Output:
– Return δ:= {(Ei,Di)}i∈[m].
Algorithm DelCal
Fig. 7: The delegation calculation algorithm DelCal
Input: a set of the voters V, a set of the experts E, two sets of ballots φ1,φ2
and the delegation δ.
Output: the tally result τ
Init:
– Create and initiate τyes = 0, τno = 0 and τabstain = 0.
– Parse δ as {(Ei,Di)}i∈[m].
Tally Computation:
– For each ballot B ∈φ2: parse B in form of ( Vj,Cast,vj,αj); if
vj = (Vote,aj) for some aj ∈{yes,no,abstain}, then τaj := τaj + αj.
– For each ballot B ∈φ1: parse B in form of ( Ei,Vote,bi) for some
bi ∈{yes,no,abstain}, then τbi := τbi + Di.
Output:
– Return τ := (τyes,τno,τabstain).
The tally algorithm TallyAlg
Fig. 8: The tally algorithm

A Treasury System for Cryptocurrencies 21
Vote encoding. In our scheme, we encode the vote into a (unit) vector. Let
encodeE and encodeV be the vote encoding algorithm for the expert and voter,
respectively. For an expert, upon receiving input x∈{Yes,No,Abstain}, the
encodeE returns 100, 010, 001 for Yes,No,Abstain, respectively. For a voter,
the input is y ∈{E1,..., Em}∪{ Yes,No,Abstain}. When y = Ei, i ∈[m],
it means that the voter delegate his/her voting power to the expert Ei. When
y ∈{Yes,No,Abstain}, it means that the voter directly vote on the project.
The encodeV returns a unit vector of length ( m+ 3), denoted as v, such that
v= e(m+3)
i if y= Ei, for i∈[m]; and v is set to e(m+3)
m+1 , e(m+3)
m+2 , and e(m+3)
m+3 if y
is Yes,No,Abstain, respectively.
Since sending data to the blockchain consumes coins, we implicitly assume
all the experts E and voters V have spare coins to pay the transaction fees
that occurred during the protocol execution. More speciﬁcally, we let each party
prepare {Ini}ℓ1
i=1,{Outj}ℓ2
j=1 s.t.
ℓ1∑
i=1
Ini.Value ≥
ℓ2∑
j=1
Outj.Value .
Denote the corresponding coins owned by a voter Vi ∈ V, an expert Ej ∈
E, and a voting committee member Ct ∈ Cas ( {In(Vi)
η }ℓ1
η=1,{Out(Vi)
η }ℓ2
η=1),
({In(Ej)
η }ℓ1
η=1,{Out(Ej)
η }ℓ2
η=1), and ( {In(Ct)
η }ℓ1
η=1,{Out(Ct)
η }ℓ2
η=1), respectively. The
protocol is depicted in Fig. 9. It consists of preparation phase, voting/delegation
phase, and tally phase.
Sending/Reading data to/from FLedger. Fig. 10 describes the macro for
a party to send and read data to/from the blockchain FLedger. According the
blockchain model proposed by [10], three types of delays need to be considered.
First, we have a bounded network delay, and it is assumed that all messages can
be delivered within ∆1 rounds, which is 2∆1 clock-ticks in [10]. Subsequently, a
desynchronised user can get up-to-date within 2 ∆1 rounds (i.e. 4∆1 clock-ticks)
after registration. The second type of delay is the fact that the adversary can
hold a valid transaction up to certain blocks, but she cannot permanently denial-
of-service such a transaction. This is modeled by the ExtendPolicy in FLedger,
where if a transaction is more than ∆2 rounds (i.e. 2 ∆2 clock-ticks) old, and
still valid with respect to the current state, then it will be included into the
state. Finally, we have a so-called windowsize. Namely, the adversary can set
state-slackness of all the honest parties up to the windowsize, which is consistent
with the common preﬁx property in [12]. Hence, all the honest parties can have
a common state of any blocks that have been proposed more than windowsize.
Denote ∆3 rounds (i.e. 2∆3 clock-ticks) as the windowsize.
To send a message xto FLedger, we need to ﬁrst check if this party has dereg-
istered and desynchronized. If so, the party needs to ﬁrst send ( Register,sid)
to FLedger. Note that the registered but desynchronized party can still send a
transaction before it is fully updated. We simply make a ‘dummy’ transaction

22 B. Zhang, R. Oliynykov and H. Balogun
Denote the corresponding coins owned by a voter Vi ∈V , an expert Ej ∈
E, and a voting committee member Ct ∈C as ({In(Vi)
η }ℓ1
η=1,{Out(Vi)
η }ℓ2
η=1),
({In
(Ej)
η }ℓ1
η=1,{Out
(Ej)
η }ℓ2
η=1), and ({In(Ct)
η }ℓ1
η=1,{Out(Ct)
η }ℓ2
η=1), respectively.
Preparation phase:
– Upon receiving (Init,sid) from the environment Z, the committee Cj,
j ∈[k] sends (KeyGen,sid) to Ft,k
DKG to generate pk and obtain the
corresponding partial private key skj from Ft,k
DKG.
Voting/Delegation phase:
– Upon receiving (Vote,sid,vj) from the environment Z, the expert Ej,
j ∈[m] does the following:
• Send (ReadPK,sid) to Ft,k
DKG, obtaining (PublicKey,sid,pk).
• Set the unit vector e(3) ←encodeE(vj). Compute cj
(3) ←Encpk(e(3))
and its NIZK proof πj (Cf. Sec. 5).
• Execute macro Send-Msg
(
(cj
(3),πj),{In
(Ej)
η }ℓ1
η=1,{Out
(Ej)
η }ℓ2
η=1
)
. (Cf.
Fig. 10)
– Upon receiving (Cast,sid,vi,αi) from the environment Z, the voter Vi,
i∈[n] does the following:
• Send (ReadPK,sid) to Ft,k
DKG, obtaining (PublicKey,sid,pk).
• Set the unit vector e(m+3) ←encodeV(vi). Compute
ui
(m+3) ←Encpk(e(m+3)) and its NIZK proof σi (Cf. Sec. 5).
• Execute macro
Send-Msg
(
(ui
(m+3),σi,αi),{In(Vi)
η }ℓ1
η=1,{Out(Vi)
η }ℓ2
η=1
)
. (Cf. Fig. 10)
Tally phase:
– Upon receiving (DelCal,sid) from the environment Z, the committee
Ct, t∈[k] does:
• Execute macro Read-Msg and obtain data.
• Fetch ballots {(ci
(3),πi)}i∈[m] and {(uj
(m+3),σj,αj)}j∈[n] from data.
• For i∈[m], check Verify(ci
(3),πi) = 1; for j ∈[n],
Verify(uj
(m+3),σj) = 1. Remove all the invalid ballots.
• For j ∈[n], if a valid uj
(m+3) is posted, parse uj
(m+3) to
(aj
(m),bj
(3)).
• For j ∈[n], ℓ∈[0,m −1], compute zi,ℓ := a
αj
j,ℓ.
• For i∈[0,m −1], compute si := ∏n
ℓ=1 zℓ,i and jointly decrypt it to
wi (Cf. [9]).
– Upon receiving (Tally,sid) from the environment Z, the committee Ct,
t∈[k] does:
• For i∈[0,m −1], ℓ∈[0,2], compute di,ℓ := cwi
i,ℓ.
• For ℓ∈[0,2], compute xℓ := ∏m−1
j=0 dj,ℓ ·∏n
j=1 b
αj
j,ℓ and jointly
decrypt it to yℓ (Cf. [9]). Execute macro
Send-Msg
(
(xℓ,yℓ),{In(Ct)
η }ℓ1
η=1,{Out(Ct)
η }ℓ2
η=1
)
. (Cf. Fig. 10)
– Upon receiving (ReadTally,sid) from the environment Z, the party P
does the following:
• Execute macro Read-Msg and obtain data.
• Fetch {(xi,yi)}i∈[0,2] from data, and return
(ReadTallyReturn,sid,(y0,y1,y2)) to the environment Z.
The voting protocol Πt,k,m,n
Vote
Fig. 9: The voting protocol Πt,k,m,n
Vote in {FLedger,Ft,k
DKG}-hybrid model

A Treasury System for Cryptocurrencies 23
whose input coins and output coins share the same owner (spending condition),
and the message xis stored in the payload of the transaction. To read a message
(stored in the payload of some transaction) from FLedger, analogously a deregis-
tered party needs to ﬁrst send (Register,sid) to FLedger. After 4δ1 clock-ticks,
the party can get synchronised. In order to receive the latest message, the party
needs to wait a maximum of 2( ∆2 + ∆3) clock-ticks for the transaction that
carries the intended message to be included in the state of the party.
Macro Send-Msg(x,{Ini}ℓ1
i=1,{Outj}ℓ2
j=1):
– If the party has deregistered and desynchronized:
• Send (Register,sid) to FLedger.
• Send
(
Submit,sid, Tx({Ini}ℓ1
i=1; {Outj}ℓ2
j=1; x)
)
to FLedger.
• Send (De-Register,sid) to FLedger.
– If the party is already synchronized:
• Send
(
Submit,sid, Tx({Ini}ℓ1
i=1; {Outj}ℓ2
j=1; x)
)
to FLedger.
Macro Read-Msg:
– If the party has deregistered and desynchronized:
• Send (Register,sid) to FLedger.
• Wait for max{4∆1,2(∆2 + ∆3)}clock-ticks by keeping sending
(Tick,sid) to the GClock.
• Send (Read,sid) to FLedger and receive (Read,sid, data) from
FLedger.
• Send (De-Register,sid) to FLedger.
– If the party is already synchronized:
• Wait for max{4∆1,2(∆2 + ∆3)}clock-ticks by keeping sending
(Tick,sid) to the GClock.
• Send (Read,sid) to FLedger and receive (Read,sid, data) from
FLedger.
– Return data.
Sending and reading messages
Fig. 10: Macro for sending and receiving message via FLedger
4.3 Security
The security of the treasury voting protocol is analysed in the UC framework.
We provide Theorem 1.

24 B. Zhang, R. Oliynykov and H. Balogun
Theorem 1. Let t,k,n,m = poly( λ) and k/2 < t ≤ n. Protocol Πt,k,n,m
Vote
described in Fig. 9 UC-realizes Ft,k,m,n
Vote in the {FLedger,Ft,k
DKG}-hybrid world
against static corruption under the DDH assumption.
Proof. To prove the theorem, we construct a simulator S such that no non-
uniform PPT environment Z can distinguish between (i) the real execution
EXEC
FLedger,Ft,k
DKG
Πt,k,n,m
Vote ,A,Z where the parties V:= {V1,..., Vn}, E:= {E1,..., Em}and
C:= {C1,..., Ck}run protocol Πt,k,n,m
Vote in the {FLedger,Ft,k
DKG}-hybrid world
and the corrupted parties are controlled by a dummy adversary Awho sim-
ply forwards messages from/to Z, and (ii) the ideal execution EXECFt,k,m,n
Vote ,S,Z
where the parties interact with functionality Ft,k,m,n
Vote in the ideal model and
corrupted parties are controlled by the simulator S. Let Vcor ⊆V, Ecor ⊆E and
Ccor ⊆C be the set of corrupted voters, experts and voting committee members,
respectively. Note that the underlying encryption scheme is IND-CPA secure,
and its corresponding NIZK proofs are simulatable ZK under the DDH assump-
tion.
Simulator. The simulator Sinternally runs A, forwarding messages to/from
the environment Z. The simulator Ssimulates honest voters Vi ∈V\Vcor, honest
experts Ei ∈E\E cor, trustees Cj ∈C\C cor and functionalities FLedger,Ft,k
DKG. In
addition, the simulator Ssimulates the following interactions with A.
In the preparation phase:
– Upon receiving (InitNotify,sid,Cj) from the external Ft,k,m,n
Vote for an hon-
est voting committee Cj ∈C\C cor, the simulator Sacts as Cj, following the
protocol Πt,k,n,m
Vote as if Cj receives (Init,sid) from the environment Z.
– Ssimulates Ft,k
DKG so that it generates and stores ( pk,sk).
In the voting/delegation phase:
– Upon receiving (VoteNotify,sid,Ej) from the external Ft,k,m,n
Vote for an hon-
est expert Ej ∈E\E cor, the simulator Sreads pk from Ft,k
DKG. Scomputes
cj(3) ←Encpk(0(3)) and simultates its NIZK proof πj using the NIZK simula-
tor. It then executes macro Send-Msg
(
(cj(3),πj),{In(Ej)
η }ℓ1
η=1,{Out(Ej)
η }ℓ2
η=1
)
.
– Upon receiving ( CastNotify,sid,Vi,αj) from the external Ft,k,m,n
Vote
for an honest expert Vi ∈ V \ Vcor, the simulator S reads pk
from Ft,k
DKG. S computes ui(m+3) ← Encpk(0(m+3)) and simultates its
NIZK proof πi using the NIZK simulator. It then executes macro
Send-Msg
(
(ui(m+3),σi,αi),{In(Vi)
η }ℓ1
η=1,{Out(Vi)
η }ℓ2
η=1
)
.
– Once the simulated FLedger receives (Post,sid,cj(3)) from a corrupted ex-
pert Ej ∈Ecor, the simulator Suses sk to decrypt cj(3), obtaining the vote
vj. Sthen sends (Vote,sid,vi) to Ft,k,m,n
Vote on behave of Ej.
– Once the simulated FLedger receives ( Post,sid,ui(m+3),αi) from a cor-
rupted voter Vi ∈Vcor, the simulator Suses sk to decrypt ui(m+3), obtaining
the vote vi. Sthen sends (Vote,sid,vi,αi) to Ft,k,m,n
Vote on behave of Vi.

A Treasury System for Cryptocurrencies 25
In the tally phase:
– Upon receiving ( DelCalNotify,sid,Cj) from the external Ft,k,m,n
Vote for an
honest trustee Cj ∈C\Ccor, the simulator Sacts as Cj, following the protocol
Πt,k,n,m
Vote as if Cj receives (DelCal,sid) from Z.
– Upon receiving ( TallyNotify,sid,Cj) from the external Ft,k,m,n
Vote for an
honest trustee Cj ∈C\Ccor, the simulator Sacts as Cj, following the protocol
Πt,k,n,m
Vote as if Cj receives (Tally,sid) from Z.
– Upon receiving ( LeakDel,sid,δ) from the external Ft,k,m,n
Vote , the simulator
Ssimulates the last honest committee Ct’s decryption share according to δ,
and it simulates the corresponding NIZK proof in the 1st round of the tally
phase.
– Upon receiving (LeakTally,sid,τ) from the externalFt,k,m,n
Vote , the simulator
Ssimulates the last honest committee Ct’s decryption share according to τ,
and it simulates the corresponding NIZK proof in the 2nd round of the tally
phase.
Indistinguishability. The indistinguishability is proven through a series of hy-
brid worlds H0,..., H4.
Hybrid H0: It is the real protocol execution EXEC
FLedger,Ft,k
DKG
Πt,k,n,m
Vote ,A,Z.
Hybrid H1: H1 is the same as H0 except that during the voting/delegation
phase, in H1, the honest voter Vj’s encrypted ballots are replaced with
Encpk(0(m+3)) and simulates its corresponding unit-vector NIZK proof.
Claim. H1 and H0 are indistinguishable if the underlying encryption scheme is
IND-CPA and the unit-vector NIZK proof is simulatable ZK.
Proof. The proof is straightforward. Namely, if an adversary Acan distinguish
H1 from H0, then we can construct an adversary Bwho can either break the
IND-CPA game of the PKE encryption or the ZK probability of the unit-vector
NIZK proof. ⊓ ⊔
Hybrid H2: H2 is the same as H1 except the following: During the vot-
ing/delegation phase, inH2, the honest expertEi’s encrypted ballots are replaced
with Encpk(0(3)) and simulates its corresponding unit-vector NIZK proof.
Claim. H2 and H1 are indistinguishable if the underlying encryption scheme is
IND-CPA and the unit-vector NIZK proof is simulatable ZK.
Proof. The same as the previous proof.
Hybrid H3: H3 is the same as H2 except the followings. During the tally phase,
H3 uses NIZK simulator to simulate all the decryption proofs instead of the real
ones.
Claim. H3 and H2 are indistinguishable if the underlying decryption NIZK is
simulatable ZK.

26 B. Zhang, R. Oliynykov and H. Balogun
Proof. The advantage of the adversary is bounded by the ZK property of the
decryption NIZK. ⊓ ⊔
Hybrid H4: H4 is the same as H3 except the followings. During the tally phase,
the honest committee Ct’s decryption shares are backwards calculated from the
δ and τ received from the Ft,k,m,n
Vote .
Claim. H4 and H3 are statistically indistinguishable.
Proof. The distribution of the decryption shares inH4 have identical distribution
to the shares in H3. ⊓ ⊔
The adversary’s view of H4 is identical to the simulated view
EXECFt,k,m,n
Vote ,S,Z. Therefore, no PPT Z can distinguish the view of the ideal
execution from the view of the real execution with more than negligible proba-
bility. This concludes our proof. ⊓ ⊔
5 A new unit vector ZK proof
5.1 Zero-knowledge proofs/arguments
Let Lbe an NP language and RLis its corresponding polynomial time decidable
binary relation, i.e., L:= {x |∃w : (x,w) ∈RL}. We say a statement x ∈L if
there is a witness w such that (x,w) ∈RL. Let the prover P and the veriﬁer V
be two PPT interactive algorithms. Denote τ ←⟨P(x,w),V (x)⟩as the public
transcript produced by P and V. After the protocol, V accepts the proof if and
only if φ(x,τ) = 1, where φ is a public predicate function.
Deﬁnition 2. We say (P,V ) is a perfectly complete proof/argument for an NP
relation RL if for all non-uniform PPT interactive adversaries Ait satisﬁes
– Perfect completeness:
Pr
[(x,w) ←A; τ ←⟨P(x,w),V (x)⟩:
(x,w) ̸∈RL∨φ(x,τ) = 1
]
= 1
– (Computational) soundness:
Pr
[x←A; τ ←⟨A,V (x)⟩:
x̸∈L∧ φ(x,τ) = 1
]
= negl(λ)
Let V(x; r) denote the veriﬁer V is executed on input xwith random coin r.
A proof/argument (P,V ) is called public coin if the veriﬁer V picks his challenges
randomly and independently of the messages sent by the prover P.
Deﬁnition 3. We say a public coin proof/argument (P,V ) is a perfect special
honest veriﬁer zero-knowledge (SHVZK) for a NP relation RL if there exists a
PPT simulator Sim such that
Pr


(x,w,r ) ←A;
τ ←⟨P(x,w),V (x; r)⟩:
(x,w) ∈RL∧A(τ) = 1

≈Pr


(x,w,r ) ←A;
τ ←Sim(x; r) :
(x,w) ∈RL∧A(τ) = 1



A Treasury System for Cryptocurrencies 27
Public coin SHVZK proofs/arguments can be transformed to a non-
interactive one (in the random oracle model [13]) by using Fiat-Shamir heuristic
[14] where a cryptographic hash function is used to compute the challenge in-
stead of having an online veriﬁer.
5.2 Schwartz-Zippel lemma
For completeness, we recap a variation of the Schwartz-Zippel lemma [15] that
will be used in proving the soundness of the zero-knowledge protocols.
Lemma 1 (Schwartz-Zippel). Let f be a non-zero multivariate polynomial of
degree dover Zp, then the probability of f(x1,...,x n) = 0 evaluated with random
x1,...,x n ←Zp is at most d
p.
Therefore, there are two multi-variate polynomials f1,f2. If f1(x1,...,x n) −
f2(x1,...,x n) = 0 for random x1,...,x n ←Zp, then we can assume that f1 =
f2. This is because, if f1 ̸= f2, the probability that the above equation holds is
bounded by max(d1,d2)
p , which is negligible in λ.
5.3 The proposed unit vector ZK proof/argument
We denote a unit vector of length n as e(n)
i = (ei,0,...,e i,n−1), where its i-th
coordinate is 1 and the rest coordinates are 0. Conventionally, to show a vec-
tor of ElGamal ciphertexts element-wise encrypt a unit vector, Chaum-Pedersen
proofs [6] are used to show each of the ciphertexts encrypts either 0 or 1 (via
Sigma OR composition) and the product of all the ciphertexts encrypts 1. Such
kind of proof is used in many well-known voting schemes, e.g., Helios. However,
the proof size is linear in the length of the unit vector, and thus the communi-
cation overhead is quite signiﬁcant when the unit vector length becomes larger.
In this section, we propose a novel special honest veriﬁer ZK (SHVZK) proof
for unit vector that allows the prover to convince the veriﬁer that a vector
of ciphertexts ( C0,...,C n−1) encrypts a unit vector e(n)
i , i ∈[0,n −1] with
O(log n) proof size. Without loss of generality, assume nis a perfect power of 2.
If not, we append Encpk(0; 0) (i.e., trivial ciphertexts) to make the total number
of ciphertexts to be the next power of 2. The proposed SHVZK protocol can
also be Fiat-Shamir transformed to a non-interactive ZK (NIZK) proof in the
random oracle model. The basic idea of our construction is inspired by [16],
where Groth and Kohlweiss proposed a Sigma protocol for the prover to show
that he knows how to open one out of many commitments. The key idea behind
our construction is that there exists a data-oblivious algorithm that can take
input as i ∈{0,1}log n and output the unit vector e(n)
i . Let i1,...,i log n be the
binary representation of i. The algorithm is depicted in Fig. 11.
Intuitively, we let the prover ﬁrst bit-wisely commit the binary presentation
of i∈[0,n −1] for the unit vector e(n)
i . The prover then shows that each of the

28 B. Zhang, R. Oliynykov and H. Balogun
Input: index i= (i1,...,i log n) ∈{0,1}log n
Output: unit vector e(n)
i = (ei,0,...,e i,n−1) ∈{0,1}n
1. For ℓ∈[log n], set bℓ,0 := 1 −iℓ and bℓ,1 := iℓ;
2. For j ∈[0,n −1], set ei,j := ∏log n
ℓ=1 bℓ,jℓ, where j1,...,j log n is the binary
representation of j;
3. Return e(n)
i = (ei,0,...,e i,n−1);
The algorithm that maps i∈[0,n −1] to e(n)
i
Fig. 11: The algorithm that maps i∈[0,n −1] to e(n)
i
commitments of ( i1,...,i log n) indeed contain 0 or 1, using the Sigma protocol
proposed in Section 2.3 of [16]. Note that in the 3rd move of such a Sigma
protocol, the prover reveals a degree-1 polynomial of the committed message.
Denote zℓ,1 := iℓx+ βℓ, ℓ ∈[log n] as the corresponding degree-1 polynomials,
where βℓ are chosen by the prover and x is chosen by the veriﬁer. By linearity,
we can also deﬁne zℓ,0 := x−zℓ,1 = (1 −iℓ)x−βℓ, ℓ∈[log n]. According to the
algorithm described in Fig.11, for j ∈[0,n −1], let j1,...,j log n be the binary
representation of j, and the product ∏log n
ℓ=1 zℓ,jℓ can be viewed as a degree-(logn)
polynomial of the form
pj(x) = ei,jxlog n +
log n−1∑
k=0
pj,kxk
for some pj,k, k ∈[0,log n−1]. We then use batch veriﬁcation to show that
each of Cj indeed encrypts ei,j. More speciﬁcally, for a randomly chosen y ←
Zp, let Ej := ( Cj)xlog n
·Enc(−pj(x); 0); the prover needs to show that E :=∏n−1
j=0 (Ej)yj
·∏log n−1
k=0 (Dk)xk
encrypts 0, where Dℓ := Encpk(∑n−1
j=0 (pj,ℓ·yj); Rℓ),
ℓ ∈[0,log n−1] with fresh randomness Rℓ ∈Zp. The construction is depicted
in Fig. 12, and it consists of 5 moves. Both the prover and the veriﬁer shares a
common reference string (CRS), which is a Pedersen commitment key that can
be generated using random oracle. The prover ﬁrst commits to each bits of the
binary representation of i, and the commitments are denoted as Iℓ, ℓ ∈[log n].
Subsequently, it produces Bℓ,Aℓ as the ﬁrst move of the Sigma protocol in
Sec. 2.3 of [16] showing Iℓ commits to 0 or 1. Jumping ahead, later the prover
will receive a challenge x ←{0,1}λ, and it then computes the third move of
the Sigma protocols by producing {zℓ,wℓ,vℓ}log n
ℓ=1 . To enable batch veriﬁcation,
before that, the prover is given another challenge y ← {0,1}λ in the second
move. The prover the computes and sends the aforementioned {Dℓ}log n−1
ℓ=0 . The
veriﬁcation consists of two parts. In the ﬁrst part, the veriﬁer checks the following
equations to ensure that Iℓ commits to 0 or 1.
– (Iℓ)x ·Bℓ = Comck(zℓ; wℓ)
– (Iℓ)x−zℓ ·Aℓ = Comck(0; vℓ)

A Treasury System for Cryptocurrencies 29
In the second part, the veriﬁer checks if
n−1∏
j=0
(
(Cj)xlog n
·Encpk(−
log n∏
ℓ=1
zℓ,jℓ; 0)
)yj
·
log n−1∏
ℓ=0
(Dℓ)xℓ
is encryption of 0 by asking the prover to reveal the randomness.
CRS: the commitment key ck
Statement: the public key pk and the ciphertexts C0 :=
Encpk(ei,0; r0),...,C n−1 := Encpk(ei,n−1; rn−1)
Witness: the unit vector e(n)
i ∈{0,1}n and the randomness r0,...,r n−1 ∈
Zp
Protocol:
– The prover P, for ℓ= 1,..., log n, does:
• Pick random αℓ,βℓ,γℓ,δℓ ←Zp;
• Compute Iℓ := Comck(iℓ; αℓ), Bℓ := Comck(βℓ; γℓ) and
Aℓ := Comck(iℓ ·βℓ; δℓ);
– P →V: {Iℓ,Bℓ,Aℓ}log n
ℓ=1 ;
– V →P: Random y←{0,1}λ;
– The prover P for ℓ= 0,..., log n−1, does:
• Pick random Rℓ ←Zp and compute
Dℓ := Encpk
(∑n−1
j=0 (pj,ℓ ·yj); Rℓ
)
– P →V: {Dℓ}log n−1
ℓ=0 ;
– V →P: Random x←{0,1}λ;
– The prover P does the following:
• Compute R:= ∑n−1
j=0 (rj ·xlog n ·yj) + ∑log n−1
ℓ=0 (Rℓ ·xℓ);
• For ℓ= 1,..., log n, compute zℓ := iℓ ·x+ βℓ, wℓ := αℓ ·x+ γℓ, and
vℓ := αℓ(x−zℓ) + δℓ;
– P →V: R and {zℓ,wℓ,vℓ}log n
ℓ=1
Veriﬁcation:
– Check the followings:
– For ℓ= 1,..., log n, does:
• (Iℓ)x ·Bℓ = Comck(zℓ; wℓ)
• (Iℓ)x−zℓ ·Aℓ = Comck(0; vℓ)
– ∏n−1
j=0
(
(Cj)xlog n
·Encpk(−∏log n
ℓ=1 zℓ,jℓ; 0)
)yj
·∏log n−1
ℓ=0 (Dℓ)xℓ
= Encpk(0; R),
where zj,1 = zj and zj,0 = x−zj.
Unit vector ZK argument
Fig. 12: Unit vector ZK argument

30 B. Zhang, R. Oliynykov and H. Balogun
Theorem 2. Assume the DDH problem is hard. The protocol described in
Fig. 12 is a 5-move public coin special honest veriﬁer zero-knowledge argument
of knowledge of e(n)
i = ( ei,0,...,e i,n−1) ∈{0,1}n and (r0,...,r n−1) ∈(Zp)n
such that Cj = Encpk(ei,j; rj), j ∈[0,n −1].
Proof. For perfect completeness, we ﬁrst observe that the veriﬁcation equa-
tions (Iℓ)x ·Bℓ = Comck(zℓ; wℓ) and ( Iℓ)x−zℓ ·Aℓ = Comck(0; vℓ) holds. Indeed,
by additively homomorphic property of the commitment scheme, ( Iℓ)x ·Bℓ =
Comck(iℓ·x+ βℓ; αℓ·x+ γℓ) and (Iℓ)x−zℓ ·Aℓ = Comck(iℓ·(x−zℓ) +iℓ·βℓ; αℓ·
(x−zℓ) +δℓ) = Comck(iℓ(1 −iℓ) ·x; vℓ). Since iℓ(1 −iℓ) = 0 when iℓ ∈{0,1}, we
have (Iℓ)x−zℓ ·Aℓ = Comck(0; vℓ). Moreover, for each j ∈[0,n −1], ∏log n
ℓ=1 zℓ,jℓ is
a polynomial in the form of
pj(x) = ei,jxlog n +
log n−1∑
k=0
pj,kxk
where x is the veriﬁer’s challenge. Therefore, it is easy to see that
n−1∏
j=0
(
(Cj)xlog n
·Encpk(−
log n∏
ℓ=1
zℓ,jℓ; 0)
)yj
·
log n−1∏
ℓ=0
Encpk(
n−1∑
j=0
(pj,ℓ ·yj); Rℓ)xℓ
= Encpk
(n−1∑
j=0
(
ei,j ·xlog n −pj(x) +
log n−1∑
ℓ=0
pj,ℓ ·xℓ)
·yj; R
)
= Encpk(0; R) .
For soundness, ﬁrst of all, the Sigma protocols for commitments of iℓ,
ℓ ∈ [log n] is specially sound, i.e., given two transactions with the same
{Iℓ,Bℓ,Aℓ}log n
ℓ=1 and two diﬀerent x and {zℓ,wℓ,vℓ}log n
ℓ=1 , there exists a PPT ex-
tractor that can output the corresponding witness iℓ ∈{0,1}.
Moreover, ∏n−1
j=0
(
(Cj)xlog n
·Encpk(−∏log n
ℓ=1 zℓ,jℓ; 0)
)yj
builds a degree-log n
polynomial w.r.t. x in the plaintext. While, ∏log n−1
ℓ=0 (Dℓ)xℓ
encrypts a degree-
(log n−1) polynomial w.r.t. x. Since x is randomly sampled after Dℓ is com-
mitted, Schwartz-Zippel lemma, ∏n−1
j=0
(
(Cj)xlog n
·Encpk(−∏log n
ℓ=1 zℓ,jℓ; 0)
)yj
·∏log n−1
ℓ=0 (Dℓ)xℓ
encrypts a zero polynomial w.r.t. xwith overwhelming probabil-
ity if the polynomial evaluation is 0. Therefore,Q(y) := ∑n−1
j=0 (ei,j−∏log n
ℓ=1 iℓ,jℓ)·
yj = 0 with overwhelming probability. Similarly, by Schwartz-Zippel lemma,
Q(y) is a zero polynomial; hence, we have for j ∈[0,n −1], ei,j = ∏log n
ℓ=1 iℓ,jℓ
with overwhelming probability.
In terms of special honest veriﬁer zero-knowledge, we now construct a sim-
ulator Sim that takes input as the statement ( C0,...,C n−1) and the given

A Treasury System for Cryptocurrencies 31
challenges x,y ∈ {0,1}λ, and it outputs a simulated transcript whose distri-
bution is indistinguishable from the real one. More speciﬁcally, Sim ﬁrst ran-
domly picks iℓ ← {0,1} and αℓ,βℓ,γℓ,δℓ ← Zp, ℓ ∈ [log n]. It then com-
putes {Iℓ,Bℓ,Aℓ}log n
ℓ=1 and {zℓ,wℓ,vℓ}log n
ℓ=1 according to the protocol description.
For ℓ ∈ {1,..., log n−1}, it then picks random Uℓ,Rℓ ←Zp and computes
Dℓ := Encpk(Uℓ; Rℓ). It then randomly picks R←Zp, computes
D0 := Encpk(0; R)
∏n−1
j=0
(
(Cj)xlog n
Encpk(−∏log n
ℓ=1 zℓ,jℓ; 0)
)yj
·∏log n−1
ℓ=1 (Dℓ)xℓ
After that, Sim outputs the simulated transcript as
(
{Iℓ,Bℓ,Aℓ}log n
ℓ=1 ,y, {Dℓ}log n−1
ℓ=0 ,x, {zℓ,wℓ,vℓ}log n
ℓ=1
)
.
This concludes our proof. ⊓ ⊔
6 Implementation and performance
6.1 Prototyping
The proposed treasury system was implemented as a fully functional cryptocur-
rency prototype. As an underlying framework we used Scorex 2.0 [17] that pro-
vides basic blockchain functionality. It is a ﬂexible modular framework designed
particularly for fast prototyping with a rich set of already implemented func-
tionalities such as asynchronous peer-to-peer network layer, built-in blockchain
support with pluggable and extendable consensus module, simple transactions
layer, JSON API for accessing the running node, etc. As treasury requires basic
blockchain functions, we decided to select TwinsCoin [11] example and extend it
with the proposed treasury system. Treasury integration required modiﬁcation
of the existed transactions structure and block validation rules, as well as intro-
duction of new modules for keeping treasury state and managing transactions
forging. All cryptographic protocols related to the voting procedure were imple-
mented in a separate library to simplify code maintanance. It is also possible
to reuse it not only in the blockchain systems but also as a standalone voting
system. The implementation uses BouncyCastle library (ver.1.58) that provides
needed elliptic curve math. Some operations in the ﬁnite ﬁeld were implemented
with help of the BigInteger class from the Java Core. Subprotocols of the de-
veloped system were implemented exactly as they are described in the paper
without any protocol-level optimizations.
6.2 Test network
For testing developed treasury prototype in real environment a local network of
12 full nodes was launched. It successfully worked for several days with dozens
of epochs. The treasury network had 9 voters with diﬀerent amount of stake,

32 B. Zhang, R. Oliynykov and H. Balogun
Fig. 13: DKG protocol execution time depending on the number of committee members
3 experts, 12 candidates to the voting committee (10 of them were selected to
participate). The numbers of proposals varied from 1 to 7. Treasury cycle had 780
blocks. Underlying blockchain with TwinsCoin consensus had block generation
time of 10 seconds (or approximately 4.5 hours treasury cycle).
During the tests many abnormal situations were simulated, for instance, a
malicious behavior of the committee members, absence of the voters and expers,
refusal to participate in the decryption stage, etc. With a correctly working
majority of the committee members, the voting results were always successfully
obtained and rewards were correctly distributed.
6.3 Evaluations
For evaluating performance of the cryptographic protocols a special set of tests
were developed as a part of the cryptographic library. The working station has
Intel Core i7-6500U CPU @ 2.50GHz and 16GB RAM.
We benchmarked key generation protocol running time for diﬀerent number
of voting committee members: from 10 to 100 (high numbers might be required
to guarantee honest majority on member random selection among large amount
of members). Shared public key generation was made both for all honest com-
mittee members and in presence of malicious ones (any minority amount, their
exact ratio does not have inﬂuence on protocol running time for any honest
participant). Results are given in Fig. 13.
Besides it, there is an estimated amount of data needed to be transmitted over
a peer-to-peer network to complete the protocol, in dependence of committee

A Treasury System for Cryptocurrencies 33
Fig. 14: Total size of the DKG protocol messages to be sent over the peer-to-peer
network depending on the number of committee members
size and malicious members ratio. Results are given in Fig. 14 (recall that even
controlling 50% of the committee, an attacker can break conﬁdentiality of voters’
ballots, but not their integrity or tally result).
Ballot generation is done once by a voter and takes less than 1 second for
several hundreds of experts, so it has little inﬂuence on the voting protocol per-
formance. To get tally results, it is needed to collect all ballots from participating
voters, validate their correctness (via attached NIZK) and then do tally for all
correct ballots. Figure 15 shows the prover’s running time, the veriﬁer’s running
time and the size of the unit vector ZK proof that has been used in the ballot
casting.
Finally, the overall communication cost for all the voting ballots per project
during the entire treasury period is depicted in Fig. 16. In particular, for a
treasury period with 5000 voters and 50 experts, the overall communication is
approximately 20 MB per project. Let us note that in practice, the treasury
period is long enough, say, 30 days (approximately 4320 blocks for Bitcoin),
so blockchain space overhead for treasury deployment in the cryptocurrency
blockchain is insigniﬁcant.
Remark. Note that in practice, the treasury period is long enough, say, 30
days (approximately 4320 blocks for Bitcoin), so blockchain space overhead for
treasury deployment in the cryptocurrency blockchain is insigniﬁcant. At the
same time, we consider a sidechain approach [18], [19], [20] for treasury imple-
mentation as an eﬀective solution. It allows separation of treasury functionality
from the mainchain consensus, providing a number of advantages. In partic-
ular, treasury protocols do not inﬂuence the mainchain consensus, moving all

34 B. Zhang, R. Oliynykov and H. Balogun
Fig. 15: The prover’s running time, veriﬁer’s running time and the size of the unit
vector ZK proof.
implementation complexity in a sidechain. This modular construction also saves
mainchain space for core clients.
7 Analysing consensus
The overarching aim of decision-making mechanisms is to reach the best de-
cision. However, it is usually unclear what constitutes the best alternative. In
other words, in a multi-party decision-making process, it is diﬃcult to agree
on what constitutes the best solution, due to diﬀerences in individual pref-
erences,interests, knowledge, skill, orientation, etc. Therefore, integration of
community-wide knowledge, skills and expertise of members is fundamental for
long-term sustainability (especially for blockchain developmental projects).
Consensus building [21] has been identiﬁed as a way to deal with complex,
strategic and often controversial planning and decision-making. Sustained in-
novation and development requires the continued maintenance of the complex
interaction between all stakeholders (with varying expertise, skill sets and val-
ues). The goal is to adopt and implement solutions that oﬀers “mutual” gains
among contending stakeholders. Consensus building or processes are typically
time-costly and resource-consuming. However, blockchain infrastructure and na-
ture of blockchains mitigates against these potential drawbacks. For instance, by

A Treasury System for Cryptocurrencies 35
Fig. 16: The overall communication for all the voting ballots during an entire treasury
period.
design, treasury system planning supports lengthy discussions and deliberations
over the range of treasury epochs available in any single treasury period. Further-
more, the decentralised nature of blockchain technologies reduces the monetary
costs associated with collaborative decision making.
Critics of collaborative decision-making argue that, perhaps, consensus kills
innovation, creativity and uniqueness. They suggest that individuals that partic-
ipate in the process tend to abandon their decisions, so as to align with the rest
of the group. However, this is not necessarily true considering the negotiation
(debates) and interaction that takes place before compromises are made or de-
cisions are reached. Consensus empowers the individual through social activity
and interaction, rather than suppress the individual [22].
One of the goals of collaborative decision-making (community-inclusive par-
ticipation) is improved community relations, and research evidence shows that
engaged citizenry/community is better than a passive one [23]. As a result, cit-
izens become willing evaluators of decisions and policies, which results in im-
proved community-wide support for decisions reached. Thus, making governance,
which is particularly important to blockchain systems, easy.
Agreement, perhaps, is the single most popular criterion for evaluating con-
sensus. Typically in the literature, consensus is analysed in terms of agreement,
and is not Majority Rule . Consensus involves the evaluation of the agreement
among a set of parties on a set of alternative solutions [24] in a multi-party col-

36 B. Zhang, R. Oliynykov and H. Balogun
laborative decision-making process (e.g., the treasury system decision-making
process). Classical deﬁnitions of consensus imply absolute agreement among all
parties as a condition for consensus. This type of (full) consensus is quite feasible
within small teams or organisations with members having relevant information
needed for decision-making. However, the extremely low possibility of achieving
this, makes this deﬁnition problematic and less useful. By extension, this deﬁ-
nition would equate the utility of decisions with “almost unanimous” (i.e., very
high but not perfect) agreement to those with complete disagreement - as both
not being useful.
Nonetheless, in real-world scenarios multi-party decisions need not be unan-
imous or in absolute agreement (full consensus) for decisions to be use-
ful. Therefore, in order to accommodate the spectrum of consensus between
full/unanimous agreement and total disagreement, [24] deﬁned soft agreement
as an iterative dynamic process that evaluates the agreement between all partic-
ipants, and the agreement between the individual participant’s preference and
the group solution. Typically, two related measures, Consensus measure (mea-
sure of agreement among all participants) and Proximity measure (measure of
agreement between individual solutions and collective solution) [24,21] are used
to evaluate consensus.
Regardless of the quality of agreement achieved/reached, the outcome of a
ﬂawed process lacks credibility, is less likely to receive widespread support and
would likely result in more tensions among member stakeholders. Well designed
consensus processes that involves every stakeholder, regardless of the amount of
stake they hold, is likely to produce fair outcomes [21] and receive community-
wide acceptance.
In line with the aim of collaborative decision-making, we note that our key
goal of evaluating consensus is not to produce “winners and losers”, rather, the
goal is to forge, enhance and encourage community-wide participation and ac-
ceptance (sense of responsibility and belonging ) and ownership of the growth,
changes and developments of the underlying blockchain system. Therefore, feed-
back is a key component of consensus evaluation. Information obtained from
proximity measure is useful for inﬂuencing discussion and minimising disagree-
ment among stakeholders [24].
Evidently, developments or changes with greater consensus are more durable
and sustainable because high consensus implies a higher agreement (support)
among the stakeholders of the decision making process. Furthermore, agreements
of this nature tend to be of very high quality because they take into consideration
the knowledge (rather than interest alone) oﬀered by each stakeholder [21].
With the help of an illustrative example of a treasury period, we now present
an evaluation of consensus of the treasury system decision-making process.
7.1 Example treasury consensus evaluation
Typically, consensus is measured through the use of some dissimilarity function
e.g., cosine of angles, Euclidean distance, etc. between corresponding individ-
ual preferences/solutions (proximity measure) and group solution, as well as

A Treasury System for Cryptocurrencies 37
the evaluation of agreement among all participants on the ﬁnal/group solution
(consensus measure).
For the purpose of consensus measurement in our treasury system decision-
making, we propose an adaptation of the approach in [25] which is itself is an
adaptation of [24] in order to accommodate nuances peculiar to blockchain sys-
tems (or cryptocurrencies), e.g., cryptocurrency stake distribution. Speciﬁcally,
for treasury system consensus measurement, we identify the following key ele-
ments:
– Proposals (or alternative solutions)
– Stake holders in the system (or participants in the decision-making process)
– Treasury funds (or available resources)
– The decision-making process (or voting scheme)
– Outcomes of the decision-making process (or solution set)
– Agreement among all participants (or consensus measure)
– Agreement between individual solutions and the treasury outcome/solution
(or proximity measure)
Additionally, we highlight the processes for consensus evaluation in the trea-
sury system collaborative decision-making scheme:
– Preference speciﬁcation
– Collective solution calculation
– Distance measure
– Distance aggregation
– Consensus measure and
– Proximity measure
We now present each of the various stages involved in the consensus evalua-
tion process.
List of titles of proposals requesting funds
– Proposal 1 : Purchase and Installation of ATMs for the cryptocurrency
– Proposal 2 : Facilitation of listing of cryptocurrency on major cryptocur-
rency exchanges
– Proposal 3 : Cryptocurrency awareness and advertisement campaigns
boost cryptocurrency exchange rate
– Proposal 4 : Creation of online educational resources such as YouTube
videos, and general training for cryptocurrency trading
– Proposal 5 : Construction of cryptocurrency international headquarters
and liaison oﬃce on every continent
– Proposal 6 : Development of third-party software and tools to support
cryptocurrency, e.g., establishment of a new peer-to-peer mining pool soft-
ware
– Proposal 7 : Establishment of a cryptocurrency legal team
– Proposal 8 : Organisation of a cryptocurrency conference
– Proposal 9 : Analysis of cryptocurrency protocol security and proofs
– Proposal 10 : Organisation of an annual dinner party and award night for
community members

38 B. Zhang, R. Oliynykov and H. Balogun
Participation information. We assume 5 people (2 experts and 3 voters) are
involved in the current treasury voting process. For simplicity, without the loss
of generality, we also assume a ﬂat model of stake distribution in this illustrative
treasury period. That is, we assume that all participants (expert/voter) have
equal stake in the system (e.g., 1 cryptocoin).
Preference speciﬁcation. Each participant respectively specify his preferences
based on his assessment of the individual proposals, using criteria/guidelines such
as: usefulness of proposal, timeliness, cost-beneﬁt impact of proposal, proﬁle of
proposer, relevance of project, urgency of proposal, amount of funds requested,
duration of project, team in charge of project, quality of proposal, etc. However,
users are free to further evaluate proposals as they deem ﬁt (or based on their
personal judgment).
Particularly, users vote YES, NO, ABSTAIN for proposals either directly or
indirectly by delegating their voting power to experts in that particular area. We
encode a YES, NO, or ABSTAIN votes as 1,0,or ⊥respectively. We remark that
the ballots of users who vote ⊥for any proposal are treated as being the same
as the treasury outcome for that proposal. Hence, for consensus evaluation, they
are considered as being in agreement with whatever the outcome of the aﬀected
proposal is.
Collective solution calculation. For voting on the treasury, the group solu-
tion is obtained through the application of the voting rule (e.g., majority voting,
fuzzy threshold voting) on the ballot casted by the experts and voters. Speciﬁ-
cally, for our treasury system, where the voting rule is Fuzzy Threshold Voting,
this corresponds to ranking of the alternative proposals based on the number of
votes for minus the number of votes against , and checking that the remainder
is at least 10% of all votes recorded. Thereafter, winning votes are determined
as those that receive funding from the (ranked) list of all “qualiﬁed” proposals.
Therefore, proposals that meet the minimum threshold but do not receive fund-
ing because of the limitation of available funds (and their relatively low overall
position in the ranked list) are not considered members of the set of “winning
proposals”. The set of “winning projects ” are those who will receive funding
according to the decision reached on the treasury system (voting result). Table
1 provides information on how participants casted their ballots.
(Normalised) distance measure. For each participant, we calculate distance
measure (DM) of every vote/ballot for each project by comparing the partici-
pant’s choice with the treasury system funding decision. We apply the dissimi-
larity function below:
DMi,j = |PPi,j −TSj|
NDMi,j = DMi,j
|PS|

A Treasury System for Cryptocurrencies 39
Table 1: User preference
Prj 1 Prj 2 Prj 3 Prj 4 Prj 5 Prj 6 Prj 7 Prj 8 Prj 9 Prj 10
User 1 1 B 1 B 1 B A A B ⊥
User 2 ⊥ 1 1 ⊥ 0 1 1 0 ⊥ 1
User 3 / Expert A 1 1 1 0 0 1 0 0 1 0
User 4 / Expert B 1 1 0 1 0 1 0 1 1 0
User 5 0 1 A 1 ⊥ A 1 ⊥ A 1
Total 3 5 4 3 1 5 2 1 4 2
Treasury Decision 0 1 1 0 0 1 0 0 1 0
where DMi,j (respectively, NDMi,j) is the distance (respectively, normalised
distance ) between the ith participant’s choice for project j and the treasury
solution for project j is TSj. PPi,j is the ith participant’s preference/choice for
project j and PS is the preference size of voter’s choice. In the case of our trea-
sury system PS = 2, for Yes and No, because Abstain is handled diﬀerently.
As earlier explained, for consensus evaluation, the choice of voters/experts who
vote Abstain i.e. ⊥are considered as being the same as treasury funding deci-
sion for any particular project. Hence, a distance measure of zero(0) is assigned
for a participant who votes Abstain for any project proposal. The distance
measure for the treasury system decision making is presented in Table 2.
Table 2: Distance speciﬁcation
Prj 1 Prj 2 Prj 3 Prj 4 Prj 5 Prj 6 Prj 7 Prj 8 Prj 9 Prj 10
User 1 1 0 0 1 1 0 0 0 0 0
User 2 0 0 0 0 0 0 1 0 0 1
User 3 / Expert A 1 0 0 0 0 0 0 0 0 0
User 4 / Expert B 1 0 1 1 0 0 0 1 0 0
User 5 0 0 0 1 0 0 1 0 0 1
Distance aggregation and consensus degree on projects. Using the nor-
malised distance measure, NDM, we calculate the degree of consensus among all
participants (voters and experts) on each project as follows:
CDj = 1 −
p∑
i=1
NDMi,j
p
where CDj is the consensus degree for project j, and p is the size/number of
participants.

40 B. Zhang, R. Oliynykov and H. Balogun
Table 3: Consensus degree
Prj 1 Prj 2 Prj 3 Prj 4 Prj 5 Prj 6 Prj 7 Prj 8 Prj 9 Prj 10
User 1 0.5 0 0 0.5 0.5 0 0 0 0 0
User 2 0 0 0 0 0 0 0.5 0 0 0.5
User 3 / Expert A 0.5 0 0 0 0 0 0 0 0 0
User 4 / Expert B 0.5 0 0.5 0.5 0 0 0 0.5 0 0
User 5 0 0 0 0.5 0 0 0.5 0 0 0.5
Total 1.5 0 0.5 1.5 0.5 0 1.0 0.5 0 1.0
Consensus degree 0.7 1.0 0.9 0.7 0.9 1.0 0.8 0.9 1.0 0.8
Table 4: Consensus measure for various values of β
β 0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0
CM 0.87 0.881 0.891 0.902 0.912 0.923 0.933 0.944 0.954 0.964 0.975
Consensus measure. We now proceed to calculate overall consensus among
all participants (for our example treasury period decision under review) through
an aggregation of the consensus degrees, CD. The consensus measure, CM, is
calculated through the aggregation procedure of [26], which utilises Ordered
Weighted Average (OWA). The goal of the aggregation operator is to enable the
consensus degrees on the “winning projects” have more importance or weight [24]
in the aggregation procedure. The expression for CM is as follows:
CM = (1 −β) ·
n∑
i=1
CDi
n + β·
t∑
s=1
CDWs
t
where CDW is the set of consensus degrees for “winning projects”, t is its
cardinality, nis the total number of projects, and β ∈[0,1] is used to control the
inﬂuence of consensus degree of the winning projects on the overall consensus
measure in the treasury system. Clearly, higher values of β causes consensus
degree of the winning projects to highly inﬂuence the overall consensus measure.
Typical values of β recommended in the literature are 0 .7,0.8, and 0.9 [24,25].
We use a β value of 0 .8 in our treasury system to emphasize the importance
of consensus degree among the participants on the winning projects. Table 4
shows the consensus measure for diﬀerent values of β.
Table 5: Proximity measure for β = 0.8
Prj. 1 Prj. 2 Prj. 3 Prj. 4 Prj. 5 Prj. 6 Prj. 7 Prj. 8 Prj. 9 Prj. 10 Avg.PMi PMi(β= 0.8)
U1 0.5 1 1 0.5 0.5 1 1 1 1 1 0.85 (1 −β)0.85 +β 0.97
U2 1 1 1 1 1 1 0.5 1 1 0.5 0.9 (1 −β)0.9 +β 0.98
U3/E.A 0.5 1 1 1 1 1 1 1 1 1 0.95 (1 −β)0.95 +β 0.99
U4/E.B 0.5 1 0.5 0.5 1 1 1 0.5 1 1 0.8 (1 −β)0.8 + 0.875β 0.86
U5 1 1 1 0.5 1 1 0.5 1 1 0.5 0.85 (1 −β)0.85 +β 0.97

A Treasury System for Cryptocurrencies 41
Proximity measure of each participant. Here, we evaluate the proximity
measure of each participant’s voting preference to the collective treasury (fund-
ing) decision by aggregating each participant’s distance measure across all the
projects. Similar to the calculation of the consensus measure, we utilise OWA
aggregation operator as follows:
PMi = (1 −β)
∑p
j=1(1 −NDMi,j)
p + β
(
1 −
∑t
k=1 NDMWi,k
t
)
where NDMi,j is the distance measure between participant i′s preference for
project j and the treasury (collective) decision for project j. For participant
i, NDMWi,k is a special normalised distance measure between the collective
decision for project k in the “set of winning projects ” and the correspond-
ing participant i′s preference for that project. That is, NDMW only considers
normalised distance measures for projects that receive funding a.k.a winning
projects.
As earlier explained, we assign a value of 0 .8 to β and present the proximity
measure between each participant’s preference and the treasury funding decision
in Table 5.
Evidently, participants with high proximity measures contribute positively
towards the treasury system consensus while proximity measures close to zero
signify negative contribution towards overall treasury system consensus. Addi-
tionally, it can be observed that User 1 and User 5 both have the same proximity
measure of 0.97, despite having diﬀerent voting preferences. However, this is so
because the two users voted exactly the same way for projects in the “winning
set”, and the “winning set” or collective decision highly inﬂuenced our aggre-
gated measures due to the high value of β used.
8 Related work
The Dash governance system (DGS) [1] also referred to as Dash governance by
blockchain (DGBB) is the pioneer treasury implementation for cryptocurrency
development funding on any real-world cryptocurrency. The DGS allows regular
users on the Dash network to participate in the development process of the
Dash cryptocurrency by allowing them submit project proposals (for advancing
the cryptocurrency) to the network. A subset of users known as Masternodes
then vote to decide what proposals from the submitted proposals get funding.
Every voting cycle (approximately one month), winning proposals are voted for
and funded from the accrued resources in the blockchain treasury. 10% of all
block rewards within each monthly voting period is contributed towards the
blockchain treasury, from which proposals are then funded. Although the DGS
works in practice, there are open questions to it. For instance, voting on the
DGS is not private, thereby leaving nodes susceptible to coercion.
Beyond voting, the Dash Governance System (DGS) [1,2], is the ﬁrst self-
sustenance/funding mechanism in any cryptocurrency or blockchain system.
However, the DGS does not support delegative voting and ballot privacy.

42 B. Zhang, R. Oliynykov and H. Balogun
A second system is the ZenCash (now - Horizen) multi-stakeholder gov-
ernance model. By design, it adopts a ﬂexible multi-stakeholder governance
model [27]. The core idea is to remove centralisation which entrusts enormous
powers with a minority. Participation is voluntary and decision-making powers
cuts across all categories of stakeholders proportional to their resources(stake).
Initially, the Horizen (ZenCash) system has a Core Team (inclusive of
founders of Zen) and a DAO (consisting of industry leaders) that controls 3 .5%
of block mining rewards and 5% of rewards respectively. The plan is to evolve,
develop and adopt a hybrid voting mechanism that enables all stakeholders to
inﬂuence decisions and resource allocations on the blockchain. This evolution
would result in a system of DAOs, with competing DAOs responsible for working
on diﬀerent problems. Collectively, the DAOs will be responsible for activities
(building, maintaining, improving software, legal, marketing, and advertising)
that will ensure the long-term sustainability of Zen.
Community members/stakeholders are allowed to participate in the develop-
ment of Zen via project proposals which are funded by the DAOs through the 5%
block mining reward allocation they receive. We remark that proposals are only
to be funded subject to successful voting. Although, at launch, only one DAO
“staﬀed with respected professionals” exists. The staﬀ strength of each DAO is
between 3 −5 members and could potentially be increased to any number. A
dispute resolution mechanism is to be provided for solving issues among DAO
members. Delegative voting is not supported and the system uses ﬁxed amount
of voting tokens.
Liquid democracy (also known as delegative democracy [3]) as an hybrid of
direct democracy and representative democracy provides the beneﬁts of both
system (whilst doing away with their drawbacks) by enabling organisations to
take advantage of the experts in a voting process and also gives every member
the opportunity to vote [28,29]. Although the advantages of liquid democracy has
been widely discussed in the literature [30,31,32,33,34], there are few provably
secure construction of liquid democracy voting.
Most real-world implementations of liquid democracy only focus on the func-
tionality aspect of their schemes. For instance, Google Vote [35] is an internal
Google experiment on liquid democracy over the social media, Google+, which
does not consider voter privacy. Similarly, systems such as proxyfor.me [36], Liq-
uidFeedback [37], Adhocracy [38], GetOpinionated,[39] also oﬀer poor privacy
guarantees. It is worth mentioning that Sovereign [40] is a blockchain-based
voting protocol for liquid democracy; therefore, its privacy is inherited from
the underlying blockchain, which provides pseudonymity-based privacy. Wasa2il
[41] is able to achieve end-to-end veriﬁability because this foils privacy. The best
known liquid democracy and proxy democracy voting schemes are nVotes [42]
and Statement Voting [28,29]. However, those systems require mix-nets as their
underlying primitive. This makes them less compatible to the blockchain setting
due to the heavy work load of the mixing servers.
There are a few blockchain based e-voting schemes in the literature, but most
of them, e.g., Agora [43], only use the blockchain as a realization of the bulletin

A Treasury System for Cryptocurrencies 43
board. The actual e-voting schemes are not integrated with the blockchain. [44]
is a proposed blockchain-based voting solution that heavily relies on an external
“trusted third party” between users and the election authority/authentication
authority, in order to ensure anonymity/privacy of voters. Each candidate is
voted for by having transactions sent to them. Nonetheless, privacy or anonymity
of voters can be broken by collusion between the authentication organisation
and the trusted third party. [45] proposes an end-to-end voting system based
on Bitcoin that utilises a Kerberos-based protocol to achieved voter identity
anonymisation. Voting takes place via sending of tokens from voters to address
(public key) of candidates. However, voting is not private and other voters can
be inﬂuenced by the trend or likelihood of the overall results (before voting is
concluded). Furthermore, the scheme is susceptible to coercion.
Our work diﬀers from these earlier works because it not only supports liquid
democracy whilst preserving privacy of the voters and delegates, it is also prac-
tical in the sense that it considers real-life concerns (e.g., monthly duration of
treasury epoch) associated with a treasury system for blockchains.
9 Conclusion
In this work, we initiated the study of blockchain treasury systems for the com-
munity to collaboratively collect and distribute funds in a decentralised manner.
We note that the voting scheme used in the treasury system can be further im-
proved with game-theoretic approaches to enable better collaborative decision
making. The proposed system can also be extended to serve blockchain self-
governance. Our treasury system is planned for practical deployment in cryp-
tocurrencies in 2019. In particular, the treasury model is in the roadmap of
Cardano [46], to be a part of the Voltaire release [47]. Horizen (former ZenCash)
also implements DAO Treasury Protocol-level Voting System [48] based on our
scheme.
Acknowledgment
This work is partially supported by EPSRC grant EP/P034578/1, PETRAS
PRF, and IOHK Ltd. We thank Dmytro Kaidalov and Andrii Nastenko from
IOHK for the prototype implementation and benchmarks.

44 B. Zhang, R. Oliynykov and H. Balogun
References
1. Evan Duﬃeld, Daniel Diaz, “Dash: A payments-focused cryptocurrency,” 2018.
2. D. Kaidalov, A. Nastenko, et al., “Dash governance system: Analysis and sugges-
tions for improvements.”
3. B. Ford, “Delegative democracy,” Manuscript, 2002.
4. D. Kaidalov, L. Kovalchuk, et al., “A proposal for an ethereum classic treasury
system.”
5. R. Canetti, “Universally composable security: A new paradigm for cryptographic
protocols.” Cryptology ePrint Archive, Report 2000/067, 2000. https://eprint.iacr.
org/2000/067.
6. D. Chaum and T. P. Pedersen, “Wallet databases with observers,” in CRYPTO
’92, vol. 740, pp. 89–105, 1993.
7. “Treasury prototype implementation.”
8. D. Wikstr¨ om, “Universally composable DKG with linear number of exponentia-
tions,” in SCN 2004, pp. 263–277, 2004.
9. R. Gennaro, S. Jarecki, H. Krawczyk, and T. Rabin, “Secure distributed key gen-
eration for discrete-log based cryptosystems,” in EUROCRYPT ’99, pp. 295–310,
Springer Berlin Heidelberg, 1999.
10. C. Badertscher, U. Maurer, D. Tschudi, and V. Zikas, “Bitcoin as a transaction
ledger: A composable treatment,” in CRYPTO 2017, vol. 10401, pp. 324–356,
Springer, 2017.
11. A. Chepurnoy, T. Duong, L. Fan, and H. Zhou, “Twinscoin: A cryptocurrency
via proof-of-work and proof-of-stake,” IACR Cryptology ePrint Archive, vol. 2017,
p. 232, 2017.
12. J. A. Garay, A. Kiayias, and N. Leonardos, “The bitcoin backbone protocol: Anal-
ysis and applications,” in EUROCRYPT 2015, vol. 9057, pp. 281–310, Springer,
2015.
13. M. Bellare and P. Rogaway, “Random oracles are practical: A paradigm for de-
signing eﬃcient protocols,” in CCS ’93, pp. 62–73, 1993.
14. A. Fiat and A. Shamir, “How to prove yourself: Practical solutions to identiﬁcation
and signature problems,” in CRYPTO’ 86, pp. 186–194, 1986.
15. J. T. Schwartz, “Fast probabilistic algorithms for veriﬁcation of polynomial iden-
tities,” J. ACM, vol. 27, pp. 701–717, Oct. 1980.
16. J. Groth and M. Kohlweiss, One-Out-of-Many Proofs: Or How to Leak a Secret
and Spend a Coin, pp. 253–280. Springer, 2015.
17. “Scorex 2 - the modular blockchain framework.”
18. A. Back et al., “Enabling blockchain innovations with pegged sidechains,” 2014.
19. P. Gaˇ zi, A. Kiayias, and D. Zindros, “Proof-of-stake sidechains,” inIEEE Sympo-
sium on Security & Privacy, 2019.
20. A. Kiayias and D. Zindros, “Proof-of-work sidechains.” Cryptology ePrint Archive,
Report 2018/1048, 2018.
21. J. E. Innes and D. E. Booher, “Consensus building and complex adaptive systems,”
Journal of the American Planning Association, vol. 65, no. 4, pp. 412–423, 1999.
22. J. Trimbur, “Consensus and diﬀerence in collaborative learning,” College English,
vol. 51, no. 6, p. 602, 1989.
23. R. A. Irvin and J. Stansbury, “Citizen participation in decision making: Is it worth
the eﬀort?,” Public Administration Review, vol. 64, pp. 55–65, January 2004.
24. E. Herrera-Viedma, F. Herrera, and F. Chiclana, “A consensus model for multiper-
son decision making with diﬀerent preference structures,” Trans. Sys. Man Cyber.
Part A, vol. 32, pp. 394–402, May 2002.

A Treasury System for Cryptocurrencies 45
25. S. Boroushaki and J. Malczewski, “Measuring consensus for collaborative decision-
making: A gis-based approach,” Computers, Environment and Urban Systems,
vol. 34, no. 4, pp. 322 – 332, 2010. Geospatial Cyberinfrastructure.
26. R. R. YAGER and D. P. FILEV, “Parameterized and-uke and or-like owa op-
erators,” International Journal of General Systems, vol. 22, no. 3, pp. 297–316,
1994.
27. R. Viglione, R. Versluis, and J. Lippencott, “Zen white paper,” 2017.
28. B. Zhang and H. Zhou, “Brief announcement: Statement voting and liquid democ-
racy,” in PODC 2017, pp. 359–361, 2017.
29. B. Zhang and H.-S. Zhou, “Statement voting,” in FC ’19, 2019.
30. D. Lomax, “Beyond politics, an introduction,” January 1, 2003. Online; date last
accessed: 2017-10-21.
31. P. Boldi, F. Bonchi, C. Castillo, and S. Vigna, “Voting in social networks,” in Pro-
ceedings of the 18th ACM conference on Information and knowledge management,
pp. 777–786, ACM, 2009.
32. M. Nordfors, “Democracy 2.1: How to make a bunch of lazy and selﬁsh people
work together,” 2003. Online; date last accessed: 2017-10-21.
33. J. Green-Armytage, “Direct voting and proxy voting,” Constitutional Political
Economy, vol. 26, no. 2, pp. 190–220, 2015.
34. J. Ito, “Emergent democracy,” arXiv:1807.06953, vol. 17, 2018.
35. S. Hardt and L. C. Lopes, “Google votes: A liquid democracy experiment on a
corporate social network,” 2015.
36. Proxy.me, “Voteﬂow,” 2015. Online; date last accessed: 2017-10-21.
37. LiquidFeedback, “LiquidFeedback oﬃcial website.” Online; date last accessed:
2017-10-21.
38. Adhocracy, “Adhocracy oﬃcial website.” Online; date last accessed: 2017-10-21.
39. J. Degrave, “Getopinionated.” GitHub repository; date last accessed: 2017-10-21.
40. Democracy Earth, “The social smart contract. an open source white paper.,”
September 1, 2017. Online; date last accessed: 2017-10-21.
41. S. McCarthy, “Wasa2il,” 2016. GitHub repository; date last accessed: 2017-10-21.
42. nVotes, “3 crypto schemes for liquid democracy (iii),” July 19 2017. Online; date
last accessed: 2017-10-21.
43. Agora, “Bringing our voting systems into the 21st century, version 0.2,” 2018.
44. K. Lee, J. James, T. Ejeta, and H. Kim, “Electronic voting service using block-
chain,” Journal of Digital Forensics, Security and Law, 2016.
45. S. Bistarelli, M. Mantilacci, P. Santancini, and F. Santini, “An end-to-end voting-
system based on bitcoin,” in SAC ’17, pp. 1836–1841, 2017.
46. “Cardano monetary policy. treasury and fees,” 2018.
47. “Cardano roadmap. voltaire,” 2018.
48. “Horizen roadmap. dao treasury protocol-level voting system,” 2018.

46 B. Zhang, R. Oliynykov and H. Balogun
A Our Treasury System DKG Protocol
Distributed key generation (DKG) is a fundamental building block of the vot-
ing process in our proposed treasury system. To ensure robustness, distributed
key generation protocol needs to be employed. Ideally, the protocol termination
should be guaranteed when up to t = ⌈n
2 ⌉− 1 out of n committee members
are corrupted. A naive way of achieving threshold distributed key generation
is as follows. Each of the voting committee members Ci ﬁrst generates a pub-
lic/private key pair (pki,ski) ←KeyGenE(param). Each Ci then posts pki to the
blockchain and use ( t+ 1,n)-threshold veriﬁable secret sharing (VSS) to share
ski to all the other committee members. The combined voting public key can
then be deﬁned as pk := ∏n
i=1 pki.
However, this approach is problematic in the sense that the adversary can
inﬂuence the distribution of the ﬁnal voting public key by letting the corrupted
committee members abort selectively. See more in [9]. Alternatively, we will
adopt the distributed key generation protocol proposed by Gennaroet al. [9]. In a
nutshell, the protocol lets the committee membersCi ﬁrst posts a “commitment”
of pki. After sharing the corresponding ski via ( t+ 1,n)-threshold VSS, the
committee members Ci then reveals pki. We will use the blockchain to realises
the broadcast channel and peer-to-peer channels. We give a full description of
our distributed key generation protocol. It is adapted from the DKG proposed
by Gennaro et al. which allows us to accommodate up to t < n/2 malicious
players in the protocol. That is, guaranteeing that with ⌊n
2 ⌋+ 1 honest players,
all the players should be able to agree on a uniformly random public key pk such
that no malicious players can inﬂuence the distribution of the generated public
key. The corresponding secret key is shared among all the players.
Protocol description. Given (g,h) as the Common Reference String (CRS),
Let C := {C1,C2,..., Ck}be the set of election committee members, and let
pki be the public key associated with Ci,i ∈[k] and the adversary is able to
corrupt up to t < k/2 committee members. Each committee member Ci picks
a random ai,0,...ai,t and random a′
i,0,...,a ′
i,t where t is maximum number of
members that can be corrupted. Each member then deﬁne two polynomials of
degree t of the form:
fi(x) = ai,0 + ai,1x+ ...+ ai,txt
and
f′
i(x) = a′
i,0 + a′
i,1x+ ...+ a′
i,txt
Therefore, each committee member Ci contributes xi = ai,0 = f(0) to the
combined secret x. Furthermore, to conﬁrm the correctness of commitments,
each member Ci posts a corresponding commitment Ei,l = gai,lha′
i,l on
the blockchain. For every other member of the election committee, each Ci
computes si,j = fi(j) and s′
i,j = f′
i(j) and posts to the blockchain, the
encryption of si,j and s′
i,j under the public key of j (note: j ̸= i). That
is, each member posts ei,j ←Encpkj (si,j) and e′
i,j ←Encpkj (s′
i,j). Note that

A Treasury System for Cryptocurrencies 47
only Cj can decrypt these commitments. This signiﬁes the end of the ﬁrst round.
In the second round, each committee member Cj fetch all ei,j and e′
i,j en-
crypted under their public key from the blockchain and decrypt them using
their private key ski to obtain their corresponding shares si,j and s′
i,j. In or-
der to verify that the shares they have received are valid or not in error,
each committee member checks if: gsi,j hs′
i,j = ∏t
l=0(Ei,l)il
for i ∈[k],i ̸= j.
Where this check fails, Cj posts a complain against Ci by revealing the evi-
dence: (si,j,s′
i,j) and π←NIZK
{
(sj,i,s′
j,i,pki,ej,i,e′
j,i),(ski) : sj,i = Decski(ej,i)
∧ s′
j,i = Decski(e′
j,i) ∧ (pki,ski) ∈RPKE
}
. Members with one valid complain
against them are disqualiﬁed from participating in the key generation process.
In the third round, following the disqualiﬁcation of no member of some
members, each qualiﬁed committee member Ci posts Ai,l := gai,l for ℓ ∈[J]
to the blockchain. Each committee member also return its secret key share as
ski := ∑
j∈[J] γi ·sj,i, where γi := ∏
ℓ∈J\{i}
ℓ
ℓ−i.
In the fourth round, each qualiﬁed committee member Ci checks if : gsj,i =∏t
ℓ=0(Aj,ℓ)iℓ
for j ∈J,j ̸= i. Where the check fails, Ci posts complain against
Cj together with the evidence (sj,i,s′
j,i) on the blockchain. Such that gsj,ihs′
j,i =∏t
ℓ=0(Ej,ℓ)iℓ
and gsj,i ̸= ∏t
ℓ=0(Aj,ℓ)iℓ
.
In the ﬁfth and ﬁnal round, each qualiﬁed committee member Ci checks if
complaints raised against qualiﬁed committee members in the fourth round are
valid. For all members against whom valid complaints were raised, other qualiﬁed
committee members posts the shares sj,i they received from the members who
have complaints against them. Therefore, allowing everyone can reconstruct the
secret share of the erring qualiﬁed committee members as: skj := ∑
i∈[J] γj·si,j
and re-deﬁne Aj,0 := gskj , where γj := ∏
ℓ∈J\{j}
ℓ
ℓ−j. Finally, the election public
key is, pk := ∏
j∈[J] Aj,0.

48 B. Zhang, R. Oliynykov and H. Balogun
Round 1: Each committee member Ci do the following:
– Pick random ai,0,ai,1,...,a i,t,bi,0,bi,1,...,b i,t ←Zp.
– Deﬁne two polynomials fi(x) := ∑t
ℓ=0 ai,ℓxℓ and f′
i(x) := ∑t
ℓ=0 bi,ℓxℓ.
– For ℓ∈[t], post Ei,ℓ := gai,ℓhbi,ℓ on the blockchain.
– For every other Cj, j ∈[k],j ̸= i, compute si,j := fi(j) and s′
i,j := f′
i(j)
and post ei,j ←Encpkj (si,j) and e′
i,j ←Encpkj (s′
i,j) on the blockchain.
(Only Cj can decrypt them.)
Round 2: Each committee member Ci do the following:
– Fetch {(ej,i,e′
j,i)}j∈[k],j̸=i from the blockchain, and use pki to decrypt
them, obtaining the corresponding shares {(sj,i,s′
j,i)}j∈[k],j̸=i.
– For j ∈[k],j ̸= i, check if gsj,ihs′
j,i = ∏t
ℓ=0(Ej,ℓ)iℓ
. If not, post complain
against Cj by revealing the evidence: ( sj,i,s′
j,i) and
π←NIZK
{(sj,i,s′
j,i,pki,ej,i,e′
j,i),(ski) :
sj,i = Decski(ej,i) ∧s′
j,i = Decski(e′
j,i) ∧(pki,ski) ∈RPKE
}
– (One valid complain against Cj, j ∈[k] will disqualify Cj.)
Round 3: Deﬁne the indices of the qualiﬁed set of committee members as
J. Each committee member Ci do the following:
– For ℓ∈[t], post Ai,ℓ := gai,ℓ to the blockchain.
– Return its secret key share as ski := ∑
j∈[J] sj,i.
Round 4: Each committee member Ci do the following:
– For j ∈J,j ̸= i, check if gsj,i = ∏t
ℓ=0(Aj,ℓ)iℓ
. If not, post complain
against Cj together with the evidence ( sj,i,s′
j,i) on the blockchain. Such
that gsj,ihs′
j,i = ∏t
ℓ=0(Ej,ℓ)iℓ
and gsj,i ̸= ∏t
ℓ=0(Aj,ℓ)iℓ
.
Round 5: Each committee member Ci do the following:
– If there is a valid complain against Cj, j ∈J, then post the share sj,i
on the blockchain. (Everyone can reconstruct ˜skj := ∑
i∈[J] γi ·sj,i and
re-deﬁne Aj,0 := g
˜skj , where γj := ∏
ℓ∈J\{j}
ℓ
ℓ−j.)
– Return the election public key as pk := ∏
j∈[J] Aj,0.
Distributed key generation ΠDKG
Fig. 17: Distributed key generation ΠDKG